{
  "exito": false,
  "fase_actual": "representacion_matematica_error",
  "pseudocodigo_original": "quickSort(int A[], int izq, int der)\nbegin\n    int pivote\n\n    if (izq < der) then\n    begin\n        pivote ðŸ¡¨ CALL particionar(A[], izq, der)\n        CALL quickSort(A[], izq, pivote - 1)\n        CALL quickSort(A[], pivote + 1, der)\n    end\nend\n\nparticionar(int A[], int izq, int der)\nbegin\n    int pivote, i, j, temp\n\n    pivote ðŸ¡¨ A[der]\n    i ðŸ¡¨ izq - 1\n\n    for j ðŸ¡¨ izq to der - 1 do\n    begin\n        if (A[j] â‰¤ pivote) then\n        begin\n            i ðŸ¡¨ i + 1\n            temp ðŸ¡¨ A[i]\n            A[i] ðŸ¡¨ A[j]\n            A[j] ðŸ¡¨ temp\n        end\n    end\n\n    temp ðŸ¡¨ A[i + 1]\n    A[i + 1] ðŸ¡¨ A[der]\n    A[der] ðŸ¡¨ temp\n\n    return i + 1\nend\n",
  "pseudocodigo_validado": "quickSort(int A[], int izq, int der)\nbegin\n    int pivote\n\n    if (izq < der) then\n    begin\n        pivote ðŸ¡¨ CALL particionar(A[], izq, der)\n        CALL quickSort(A[], izq, pivote - 1)\n        CALL quickSort(A[], pivote + 1, der)\n    end\nend\n\nparticionar(int A[], int izq, int der)\nbegin\n    int pivote, i, j, temp\n\n    pivote ðŸ¡¨ A[der]\n    i ðŸ¡¨ izq - 1\n\n    for j ðŸ¡¨ izq to der - 1 do\n    begin\n        if (A[j] â‰¤ pivote) then\n        begin\n            i ðŸ¡¨ i + 1\n            temp ðŸ¡¨ A[i]\n            A[i] ðŸ¡¨ A[j]\n            A[j] ðŸ¡¨ temp\n        end\n    end\n\n    temp ðŸ¡¨ A[i + 1]\n    A[i + 1] ðŸ¡¨ A[der]\n    A[der] ðŸ¡¨ temp\n\n    return i + 1\nend\n",
  "validacion": {
    "valido_general": true,
    "tipo_algoritmo": "Recursivo",
    "algorithm_name": "quickSort",
    "parameters": {
      "A[]": "array",
      "izq": "int",
      "der": "int"
    },
    "capas": {
      "1_LEXICA": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Iniciando anÃ¡lisis lÃ©xico...",
          "âœ“ Todos los caracteres son vÃ¡lidos",
          "âœ“ 177 tokens reconocidos",
          "âœ“ 30 lÃ­neas de cÃ³digo vÃ¡lidas"
        ]
      },
      "2_DECLARACIONES": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando declaraciones con tipado",
          "âœ“ ParÃ¡metro 1 de quickSort: int A[]",
          "âœ“ ParÃ¡metro 2 de quickSort: int izq",
          "âœ“ ParÃ¡metro 3 de quickSort: int der",
          "âœ“ Variable local en quickSort: int pivote",
          "âœ“ ParÃ¡metro 1 de particionar: int A[]",
          "âœ“ ParÃ¡metro 2 de particionar: int izq",
          "âœ“ ParÃ¡metro 3 de particionar: int der",
          "âœ“ DeclaraciÃ³n mÃºltiple en particionar: int pivote, i, j, temp"
        ]
      },
      "3_ESTRUCTURA": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando estructura del programa...",
          "âœ“ 2 subrutina(s) despuÃ©s de clases",
          "âœ“ BEGIN/END balanceados en quickSort",
          "âœ“ REPEAT/UNTIL balanceados en quickSort",
          "âœ“ BEGIN/END balanceados en particionar",
          "âœ“ REPEAT/UNTIL balanceados en particionar"
        ]
      },
      "4_EXPRESIONES": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando expresiones...",
          "âœ“ Operadores aritmÃ©ticos: +, -",
          "âœ“ Operadores relacionales: <, â‰¤"
        ]
      },
      "5_SENTENCIAS": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando sentencias...",
          "âœ“ 2 sentencia(s) IF",
          "âœ“ 1 sentencia(s) FOR",
          "âœ“ 9 sentencia(s) ASIGNACIONES",
          "âœ“ 1 sentencia(s) RETURN"
        ]
      },
      "6_SUBRUTINAS": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando subrutinas y llamadas...",
          "âš  RecursiÃ³n detectada: quickSort se llama a sÃ­ misma",
          "âš  RecursiÃ³n detectada: quickSort se llama a sÃ­ misma",
          "âœ“ 3 llamada(s) CALL encontradas",
          "âœ“ Tipo de algoritmo: Recursivo"
        ]
      },
      "7_SEMANTICA": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando semÃ¡ntica...",
          "âœ“ Todas las variables tienen tipo explÃ­cito (2 declaraciones)",
          "âœ“ Todos los parÃ¡metros tienen tipo (gramÃ¡tica v2.0)",
          "âœ“ Variables declaradas al inicio de cada subrutina (scope vÃ¡lido)"
        ]
      }
    },
    "resumen": {
      "total_lineas": 30,
      "clases_encontradas": 0,
      "subrutinas_encontradas": 2,
      "errores_totales": 0
    }
  },
  "validacion_inicial": {
    "valido_general": true,
    "tipo_algoritmo": "Recursivo",
    "algorithm_name": "quickSort",
    "parameters": {
      "A[]": "array",
      "izq": "int",
      "der": "int"
    },
    "capas": {
      "1_LEXICA": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Iniciando anÃ¡lisis lÃ©xico...",
          "âœ“ Todos los caracteres son vÃ¡lidos",
          "âœ“ 177 tokens reconocidos",
          "âœ“ 30 lÃ­neas de cÃ³digo vÃ¡lidas"
        ]
      },
      "2_DECLARACIONES": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando declaraciones con tipado",
          "âœ“ ParÃ¡metro 1 de quickSort: int A[]",
          "âœ“ ParÃ¡metro 2 de quickSort: int izq",
          "âœ“ ParÃ¡metro 3 de quickSort: int der",
          "âœ“ Variable local en quickSort: int pivote",
          "âœ“ ParÃ¡metro 1 de particionar: int A[]",
          "âœ“ ParÃ¡metro 2 de particionar: int izq",
          "âœ“ ParÃ¡metro 3 de particionar: int der",
          "âœ“ DeclaraciÃ³n mÃºltiple en particionar: int pivote, i, j, temp"
        ]
      },
      "3_ESTRUCTURA": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando estructura del programa...",
          "âœ“ 2 subrutina(s) despuÃ©s de clases",
          "âœ“ BEGIN/END balanceados en quickSort",
          "âœ“ REPEAT/UNTIL balanceados en quickSort",
          "âœ“ BEGIN/END balanceados en particionar",
          "âœ“ REPEAT/UNTIL balanceados en particionar"
        ]
      },
      "4_EXPRESIONES": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando expresiones...",
          "âœ“ Operadores aritmÃ©ticos: +, -",
          "âœ“ Operadores relacionales: <, â‰¤"
        ]
      },
      "5_SENTENCIAS": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando sentencias...",
          "âœ“ 2 sentencia(s) IF",
          "âœ“ 1 sentencia(s) FOR",
          "âœ“ 9 sentencia(s) ASIGNACIONES",
          "âœ“ 1 sentencia(s) RETURN"
        ]
      },
      "6_SUBRUTINAS": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando subrutinas y llamadas...",
          "âš  RecursiÃ³n detectada: quickSort se llama a sÃ­ misma",
          "âš  RecursiÃ³n detectada: quickSort se llama a sÃ­ misma",
          "âœ“ 3 llamada(s) CALL encontradas",
          "âœ“ Tipo de algoritmo: Recursivo"
        ]
      },
      "7_SEMANTICA": {
        "valido": true,
        "errores": [],
        "detalles": [
          "Validando semÃ¡ntica...",
          "âœ“ Todas las variables tienen tipo explÃ­cito (2 declaraciones)",
          "âœ“ Todos los parÃ¡metros tienen tipo (gramÃ¡tica v2.0)",
          "âœ“ Variables declaradas al inicio de cada subrutina (scope vÃ¡lido)"
        ]
      }
    },
    "resumen": {
      "total_lineas": 30,
      "clases_encontradas": 0,
      "subrutinas_encontradas": 2,
      "errores_totales": 0
    }
  },
  "correccion": null,
  "costos_por_linea": {
    "algorithm_name": "quickSort",
    "scenarios": [
      {
        "id": "S_best_case_fallback",
        "semantic_id": "best_case_fallback",
        "condition": "Mejor caso (fallback heurÃ­stico)",
        "state": "BEST_CASE",
        "cost_T": "T(n) = 1",
        "probability_P": "1"
      },
      {
        "id": "S_worst_case_fallback",
        "semantic_id": "worst_case_fallback",
        "condition": "Peor caso (fallback heurÃ­stico)",
        "state": "WORST_CASE",
        "cost_T": "T(n) = T(n-1) + 1",
        "probability_P": "1"
      }
    ],
    "control_variables": [],
    "metadata": {
      "algorithm_type": "recursive",
      "loop_count": 0,
      "nesting_level": 0,
      "parameters": {
        "A[]": "array",
        "izq": "int",
        "der": "int"
      },
      "llm_analysis": {},
      "best_case": {},
      "worst_case": {},
      "average_case": {}
    }
  },
  "ecuaciones": null,
  "complejidades": {
    "algorithm_name": "quickSort",
    "mejor_caso": "O(1)",
    "caso_promedio": "O(n)",
    "peor_caso": "O(2^n)",
    "derivacion_caso_promedio": "T(n) = T(n-1) + O(1)"
  },
  "errores": [
    "Error en representaciÃ³n matemÃ¡tica: Error code: 400 - {'type': 'error', 'error': {'type': 'invalid_request_error', 'message': 'Your credit balance is too low to access the Anthropic API. Please go to Plans & Billing to upgrade or purchase credits.'}, 'request_id': 'req_011CVpyg7tSbw7yVsv6hZPcM'}",
    "UnicodeEncodeError: 'charmap' codec can't encode character '\\U0001f50d' in position 2: character maps to <undefined>"
  ]
}