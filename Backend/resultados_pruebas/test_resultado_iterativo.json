{
  "pseudocode": "busquedaLineal(int A[], int n, int x)\nbegin\n    int i\n    bool encontrado\n\n    encontrado ðŸ¡¨ F\n    i ðŸ¡¨ 1\n\n    while (i â‰¤ n and not encontrado) do\n    begin\n        if (A[i] = x) then\n        begin\n            encontrado ðŸ¡¨ T\n        end\n        i ðŸ¡¨ i + 1\n    end\n\n    return encontrado\nend\n",
  "algorithm_name": "busqueda_lineal",
  "is_iterative": true,
  "parameters": {
    "arr": "array",
    "objetivo": "int"
  },
  "lines": [
    "busquedaLineal(int A[], int n, int x)",
    "begin",
    "    int i",
    "    bool encontrado",
    "",
    "    encontrado ðŸ¡¨ F",
    "    i ðŸ¡¨ 1",
    "",
    "    while (i â‰¤ n and not encontrado) do",
    "    begin",
    "        if (A[i] = x) then",
    "        begin",
    "            encontrado ðŸ¡¨ T",
    "        end",
    "        i ðŸ¡¨ i + 1",
    "    end",
    "",
    "    return encontrado",
    "end"
  ],
  "loops": [],
  "recursive_calls": [],
  "is_recursive": false,
  "control_variables": [],
  "raw_scenarios": [
    {
      "id": "S_best_case_fallback",
      "semantic_id": "best_case_fallback",
      "condition": "Mejor caso (fallback heurÃ­stico)",
      "state": "BEST_CASE",
      "cost_T": "1",
      "probability_P": "1",
      "input_description": "Mejor caso (fallback heurÃ­stico)",
      "input_characteristics": {},
      "is_iterative": true
    },
    {
      "id": "S_worst_case_fallback",
      "semantic_id": "worst_case_fallback",
      "condition": "Peor caso (fallback heurÃ­stico)",
      "state": "WORST_CASE",
      "cost_T": "n",
      "probability_P": "1",
      "input_description": "Peor caso (fallback heurÃ­stico)",
      "input_characteristics": {},
      "is_iterative": true
    },
    {
      "id": "S_1",
      "semantic_id": "S_intermediate_1",
      "condition": "Encontrado en posicin 1",
      "state": "INTERMEDIATE",
      "cost_T": "c1 + c2*2 + c3 + c4",
      "probability_P": "1/(n+1)",
      "input_description": "Encontrado en posicin 1",
      "input_characteristics": {}
    },
    {
      "id": "S_2",
      "semantic_id": "S_intermediate_2",
      "condition": "Encontrado en posicin 2",
      "state": "INTERMEDIATE",
      "cost_T": "c1 + c2*3 + c3*2 + c4",
      "probability_P": "1/(n+1)",
      "input_description": "Encontrado en posicin 2",
      "input_characteristics": {}
    },
    {
      "id": "S_k",
      "semantic_id": "S_intermediate_3",
      "condition": "Encontrado en posicin k (general)",
      "state": "INTERMEDIATE",
      "cost_T": "c1 + c2*(k+1) + c3*k + c4",
      "probability_P": "1/(n+1)",
      "input_description": "Encontrado en posicin k (general)",
      "input_characteristics": {}
    },
    {
      "id": "S_n",
      "semantic_id": "S_intermediate_4",
      "condition": "Encontrado en posicin n",
      "state": "INTERMEDIATE",
      "cost_T": "c1 + c2*(n+1) + c3*n + c4",
      "probability_P": "1/(n+1)",
      "input_description": "Encontrado en posicin n",
      "input_characteristics": {}
    },
    {
      "id": "S_empty",
      "semantic_id": "S_intermediate_5",
      "condition": "No encontrado",
      "state": "INTERMEDIATE",
      "cost_T": "c1 + c2*(n+1) + c3*n + c7",
      "probability_P": "1/(n+1)",
      "input_description": "No encontrado",
      "input_characteristics": {}
    },
    {
      "id": "S_avg",
      "semantic_id": "average_case",
      "condition": "Promedio sobre todos los escenarios posibles",
      "state": "AVERAGE",
      "cost_T": "c1 + c2*(n+3)/2 + c3*(n+1)/2 + c4*n/(n+1) + c7/(n+1)",
      "probability_P": "1",
      "input_description": "Promedio sobre todos los escenarios posibles",
      "input_characteristics": {},
      "average_cost_formula": "E[T] = (1/(n+1)) * [SUM(k=1 to n)(c1 + c2*(k+1) + c3*k + c4) + (c1 + c2*(n+1) + c3*n + c7)]",
      "average_cost_simplified": "c1 + c2*(n+3)/2 + c3*(n+1)/2 + c4*n/(n+1) + c7/(n+1)"
    }
  ],
  "llm_analysis": {
    "average_case": {
      "scenario_id": "S_avg_case",
      "scenario_type": "average_case",
      "input_condition": "Promedio sobre todos los escenarios posibles",
      "probability_model": "Se consideran n+1 casos equiprobables: elemento encontrado en posicin k (k=1 a n), o no encontrado. Cada caso tiene probabilidad 1/(n+1).",
      "scenarios_breakdown": [
        {
          "scenario_id": "S_1",
          "description": "Encontrado en posicin 1",
          "T": "c1 + c2*2 + c3 + c4",
          "P": "1/(n+1)"
        },
        {
          "scenario_id": "S_2",
          "description": "Encontrado en posicin 2",
          "T": "c1 + c2*3 + c3*2 + c4",
          "P": "1/(n+1)"
        },
        {
          "scenario_id": "S_k",
          "description": "Encontrado en posicin k (general)",
          "T": "c1 + c2*(k+1) + c3*k + c4",
          "P": "1/(n+1)"
        },
        {
          "scenario_id": "S_n",
          "description": "Encontrado en posicin n",
          "T": "c1 + c2*(n+1) + c3*n + c4",
          "P": "1/(n+1)"
        },
        {
          "scenario_id": "S_empty",
          "description": "No encontrado",
          "T": "c1 + c2*(n+1) + c3*n + c7",
          "P": "1/(n+1)"
        }
      ],
      "average_cost_formula": "E[T] = (1/(n+1)) * [SUM(k=1 to n)(c1 + c2*(k+1) + c3*k + c4) + (c1 + c2*(n+1) + c3*n + c7)]",
      "T_of_S": "c1 + c2*((n+3)/2) + c3*((n+1)/2) + c4*(n/(n+1)) + c7*(1/(n+1))",
      "T_of_S_simplified": "c1 + c2*(n+3)/2 + c3*(n+1)/2 + c4*n/(n+1) + c7/(n+1)",
      "T_of_S_explanation": "Costo esperado calculado como suma ponderada de todos los escenarios. Para los n casos de encontrado: E[T_encontrado] = c1 + c2*(1/(n+1))*SUM(k=1 to n)(k+1) + c3*(1/(n+1))*SUM(k=1 to n)(k) + c4*(n/(n+1)). Usando SUM(k=1 to n)(k) = n*(n+1)/2 y SUM(k=1 to n)(k+1) = n*(n+3)/2, obtenemos la expresin simplificada. El trmino c7 aparece solo en el caso no encontrado con probabilidad 1/(n+1).",
      "P_of_S": "1",
      "P_of_S_explanation": "El caso promedio engloba todos los escenarios posibles con sus probabilidades respectivas, por lo que la probabilidad total es 1",
      "line_by_line_analysis": [
        {
          "line_number": 1,
          "code": "encontrado <- F",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Inicializacion de variable booleana. Se ejecuta exactamente una vez en todos los escenarios."
        },
        {
          "line_number": 2,
          "code": "i <- 1",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Inicializacion del contador. Se ejecuta exactamente una vez en todos los escenarios. (Nota: se usa la misma constante c1 para todas las asignaciones simples)"
        },
        {
          "line_number": 3,
          "code": "while (i <= n and not encontrado) do",
          "C_op": "c2",
          "Freq": "(n+3)/2",
          "Total": "c2*(n+3)/2",
          "explanation": "Encabezado del while con dos comparaciones y una operacion logica. En promedio, el loop se detiene a mitad del arreglo cuando encuentra el elemento, o recorre todo cuando no lo encuentra. Frecuencia promedio: (1/(n+1))*[SUM(k=1 to n)(k+1) + (n+1)] = (1/(n+1))*[n*(n+3)/2 + (n+1)] = (n+3)/2."
        },
        {
          "line_number": 4,
          "code": "if (A[i] = x) then",
          "C_op": "c3",
          "Freq": "(n+1)/2",
          "Total": "c3*(n+1)/2",
          "explanation": "Comparacion del elemento actual con x (incluye acceso a arreglo). Se ejecuta en promedio: (1/(n+1))*[SUM(k=1 to n)(k) + n] = (1/(n+1))*[n*(n+1)/2 + n] = (n+1)/2 veces."
        },
        {
          "line_number": 5,
          "code": "encontrado <- T",
          "C_op": "c4",
          "Freq": "n/(n+1)",
          "Total": "c4*n/(n+1)",
          "explanation": "Asignacion cuando se encuentra el elemento. Se ejecuta en n de los n+1 casos, con probabilidad total n/(n+1)."
        },
        {
          "line_number": 6,
          "code": "i <- i + 1",
          "C_op": "c3",
          "Freq": "(n+1)/2",
          "Total": "c3*(n+1)/2",
          "explanation": "Incremento del contador (suma y asignacion). Se ejecuta el mismo numero de veces que el cuerpo del while, es decir (n+1)/2 veces en promedio. (Nota: se usa c3 para operaciones aritmeticas con asignacion)"
        },
        {
          "line_number": 7,
          "code": "return encontrado",
          "C_op": "c7",
          "Freq": "1",
          "Total": "c7",
          "explanation": "Retorno del resultado. Se ejecuta exactamente una vez en todos los escenarios."
        }
      ]
    }
  },
  "omega_table": {
    "algorithm_name": "busqueda_lineal",
    "scenarios": [
      {
        "id": "S_best_case_fallback",
        "semantic_id": "best_case_fallback",
        "condition": "Mejor caso (fallback heurÃ­stico)",
        "state": "BEST_CASE",
        "cost_T": "1",
        "probability_P": "1"
      },
      {
        "id": "S_worst_case_fallback",
        "semantic_id": "worst_case_fallback",
        "condition": "Peor caso (fallback heurÃ­stico)",
        "state": "WORST_CASE",
        "cost_T": "n",
        "probability_P": "1"
      },
      {
        "id": "S_1",
        "semantic_id": "S_intermediate_1",
        "condition": "Encontrado en posicin 1",
        "state": "INTERMEDIATE",
        "cost_T": "c1 + c2*2 + c3 + c4",
        "probability_P": "1/(n+1)"
      },
      {
        "id": "S_2",
        "semantic_id": "S_intermediate_2",
        "condition": "Encontrado en posicin 2",
        "state": "INTERMEDIATE",
        "cost_T": "c1 + c2*3 + c3*2 + c4",
        "probability_P": "1/(n+1)"
      },
      {
        "id": "S_k",
        "semantic_id": "S_intermediate_3",
        "condition": "Encontrado en posicin k (general)",
        "state": "INTERMEDIATE",
        "cost_T": "c1 + c2*(k+1) + c3*k + c4",
        "probability_P": "1/(n+1)"
      },
      {
        "id": "S_n",
        "semantic_id": "S_intermediate_4",
        "condition": "Encontrado en posicin n",
        "state": "INTERMEDIATE",
        "cost_T": "c1 + c2*(n+1) + c3*n + c4",
        "probability_P": "1/(n+1)"
      },
      {
        "id": "S_empty",
        "semantic_id": "S_intermediate_5",
        "condition": "No encontrado",
        "state": "INTERMEDIATE",
        "cost_T": "c1 + c2*(n+1) + c3*n + c7",
        "probability_P": "1/(n+1)"
      },
      {
        "id": "S_avg",
        "semantic_id": "average_case",
        "condition": "Promedio sobre todos los escenarios posibles",
        "state": "AVERAGE",
        "cost_T": "c1 + c2*(n+3)/2 + c3*(n+1)/2 + c4*n/(n+1) + c7/(n+1)",
        "probability_P": "1"
      }
    ],
    "control_variables": [],
    "metadata": {
      "algorithm_type": "iterative",
      "loop_count": 0,
      "nesting_level": 0,
      "parameters": {
        "arr": "array",
        "objetivo": "int"
      },
      "llm_analysis": {
        "average_case": {
          "scenario_id": "S_avg_case",
          "scenario_type": "average_case",
          "input_condition": "Promedio sobre todos los escenarios posibles",
          "probability_model": "Se consideran n+1 casos equiprobables: elemento encontrado en posicin k (k=1 a n), o no encontrado. Cada caso tiene probabilidad 1/(n+1).",
          "scenarios_breakdown": [
            {
              "scenario_id": "S_1",
              "description": "Encontrado en posicin 1",
              "T": "c1 + c2*2 + c3 + c4",
              "P": "1/(n+1)"
            },
            {
              "scenario_id": "S_2",
              "description": "Encontrado en posicin 2",
              "T": "c1 + c2*3 + c3*2 + c4",
              "P": "1/(n+1)"
            },
            {
              "scenario_id": "S_k",
              "description": "Encontrado en posicin k (general)",
              "T": "c1 + c2*(k+1) + c3*k + c4",
              "P": "1/(n+1)"
            },
            {
              "scenario_id": "S_n",
              "description": "Encontrado en posicin n",
              "T": "c1 + c2*(n+1) + c3*n + c4",
              "P": "1/(n+1)"
            },
            {
              "scenario_id": "S_empty",
              "description": "No encontrado",
              "T": "c1 + c2*(n+1) + c3*n + c7",
              "P": "1/(n+1)"
            }
          ],
          "average_cost_formula": "E[T] = (1/(n+1)) * [SUM(k=1 to n)(c1 + c2*(k+1) + c3*k + c4) + (c1 + c2*(n+1) + c3*n + c7)]",
          "T_of_S": "c1 + c2*((n+3)/2) + c3*((n+1)/2) + c4*(n/(n+1)) + c7*(1/(n+1))",
          "T_of_S_simplified": "c1 + c2*(n+3)/2 + c3*(n+1)/2 + c4*n/(n+1) + c7/(n+1)",
          "T_of_S_explanation": "Costo esperado calculado como suma ponderada de todos los escenarios. Para los n casos de encontrado: E[T_encontrado] = c1 + c2*(1/(n+1))*SUM(k=1 to n)(k+1) + c3*(1/(n+1))*SUM(k=1 to n)(k) + c4*(n/(n+1)). Usando SUM(k=1 to n)(k) = n*(n+1)/2 y SUM(k=1 to n)(k+1) = n*(n+3)/2, obtenemos la expresin simplificada. El trmino c7 aparece solo en el caso no encontrado con probabilidad 1/(n+1).",
          "P_of_S": "1",
          "P_of_S_explanation": "El caso promedio engloba todos los escenarios posibles con sus probabilidades respectivas, por lo que la probabilidad total es 1",
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "encontrado <- F",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion de variable booleana. Se ejecuta exactamente una vez en todos los escenarios."
            },
            {
              "line_number": 2,
              "code": "i <- 1",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion del contador. Se ejecuta exactamente una vez en todos los escenarios. (Nota: se usa la misma constante c1 para todas las asignaciones simples)"
            },
            {
              "line_number": 3,
              "code": "while (i <= n and not encontrado) do",
              "C_op": "c2",
              "Freq": "(n+3)/2",
              "Total": "c2*(n+3)/2",
              "explanation": "Encabezado del while con dos comparaciones y una operacion logica. En promedio, el loop se detiene a mitad del arreglo cuando encuentra el elemento, o recorre todo cuando no lo encuentra. Frecuencia promedio: (1/(n+1))*[SUM(k=1 to n)(k+1) + (n+1)] = (1/(n+1))*[n*(n+3)/2 + (n+1)] = (n+3)/2."
            },
            {
              "line_number": 4,
              "code": "if (A[i] = x) then",
              "C_op": "c3",
              "Freq": "(n+1)/2",
              "Total": "c3*(n+1)/2",
              "explanation": "Comparacion del elemento actual con x (incluye acceso a arreglo). Se ejecuta en promedio: (1/(n+1))*[SUM(k=1 to n)(k) + n] = (1/(n+1))*[n*(n+1)/2 + n] = (n+1)/2 veces."
            },
            {
              "line_number": 5,
              "code": "encontrado <- T",
              "C_op": "c4",
              "Freq": "n/(n+1)",
              "Total": "c4*n/(n+1)",
              "explanation": "Asignacion cuando se encuentra el elemento. Se ejecuta en n de los n+1 casos, con probabilidad total n/(n+1)."
            },
            {
              "line_number": 6,
              "code": "i <- i + 1",
              "C_op": "c3",
              "Freq": "(n+1)/2",
              "Total": "c3*(n+1)/2",
              "explanation": "Incremento del contador (suma y asignacion). Se ejecuta el mismo numero de veces que el cuerpo del while, es decir (n+1)/2 veces en promedio. (Nota: se usa c3 para operaciones aritmeticas con asignacion)"
            },
            {
              "line_number": 7,
              "code": "return encontrado",
              "C_op": "c7",
              "Freq": "1",
              "Total": "c7",
              "explanation": "Retorno del resultado. Se ejecuta exactamente una vez en todos los escenarios."
            }
          ]
        }
      },
      "best_case": {},
      "worst_case": {},
      "average_case": {}
    }
  },
  "errors": [
    "Error en anÃ¡lisis LLM de mejor caso: Error en anÃ¡lisis LLM del mejor caso: C_op debe ser constante simbÃ³lica (c1, c2, c3...), recibido: 0",
    "Error en anÃ¡lisis LLM de peor caso: Error en anÃ¡lisis LLM del peor caso: C_op debe ser constante simbÃ³lica (c1, c2, c3...), recibido: 0"
  ],
  "warnings": []
}