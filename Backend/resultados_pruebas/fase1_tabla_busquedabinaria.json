{
  "pseudocode": "busquedaBinaria(int A[], int n, int x)\nbegin\n    int izq, der, medio\n    bool encontrado\n\n    izq ðŸ¡¨ 1\n    der ðŸ¡¨ n\n    encontrado ðŸ¡¨ F\n\n    while (izq â‰¤ der and not encontrado) do\n    begin\n        medio ðŸ¡¨ â””(izq + der) / 2â”˜\n\n        if (A[medio] = x) then\n        begin\n            encontrado ðŸ¡¨ T\n        end\n        else\n        begin\n            if (A[medio] < x) then\n            begin\n                izq ðŸ¡¨ medio + 1\n            end\n            else\n            begin\n                der ðŸ¡¨ medio - 1\n            end\n        end\n    end\n\n    return encontrado\nend",
  "algorithm_name": "busquedaBinaria",
  "is_iterative": true,
  "parameters": {},
  "lines": [],
  "loops": [],
  "recursive_calls": [],
  "is_recursive": false,
  "control_variables": [],
  "raw_scenarios": [],
  "llm_analysis": {},
  "omega_table": {
    "algorithm_name": "busquedaBinaria",
    "scenarios": [
      {
        "id": "S_best_case",
        "semantic_id": "best_case",
        "condition": "El elemento buscado x se encuentra exactamente en la posicion media del arreglo en la primera iteracion",
        "state": "BEST_CASE",
        "cost_T": "c1 + c1 + c1 + c1 + c1 + c2*2 + c3 + c3 + c4 + c1",
        "probability_P": "q/n"
      },
      {
        "id": "S_worst_case",
        "semantic_id": "worst_case",
        "condition": "Elemento no encontrado en el array ordenado, lo que causa que el algoritmo realice el maximo numero de divisiones binarias posibles hasta que izq > der",
        "state": "WORST_CASE",
        "cost_T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7",
        "probability_P": "1"
      },
      {
        "id": "S_1",
        "semantic_id": "S_intermediate_1",
        "condition": "Encontrado en nivel 1 (raz del rbol binario, 1 comparacin)",
        "state": "INTERMEDIATE",
        "cost_T": "5*c1 + c2*2 + c3 + c3 + c4",
        "probability_P": "q/n"
      },
      {
        "id": "S_2",
        "semantic_id": "S_intermediate_2",
        "condition": "Encontrado en nivel 2 (2 comparaciones)",
        "state": "INTERMEDIATE",
        "cost_T": "5*c1 + c2*3 + c3*2 + c3*2 + c3 + c4",
        "probability_P": "q*2/n"
      },
      {
        "id": "S_k",
        "semantic_id": "S_intermediate_3",
        "condition": "Encontrado en nivel k (k comparaciones, k<=log2(n))",
        "state": "INTERMEDIATE",
        "cost_T": "5*c1 + c2*(k+1) + c3*k + c3*k + c3*(k-1)/2 + c3*(k-1)/2 + c4",
        "probability_P": "q*2^(k-1)/n"
      },
      {
        "id": "S_log",
        "semantic_id": "S_intermediate_4",
        "condition": "Encontrado en nivel log2(n) (mximo nmero de comparaciones para encontrar)",
        "state": "INTERMEDIATE",
        "cost_T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*(log2(n)-1)/2 + c3*(log2(n)-1)/2 + c4",
        "probability_P": "q*(n-2^(log2(n)-1))/n"
      },
      {
        "id": "S_not_found",
        "semantic_id": "S_intermediate_5",
        "condition": "No encontrado (log2(n)+1 comparaciones)",
        "state": "INTERMEDIATE",
        "cost_T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7",
        "probability_P": "1-q"
      },
      {
        "id": "S_avg",
        "semantic_id": "average_case",
        "condition": "Promedio sobre todos los escenarios posibles en bsqueda binaria",
        "state": "AVERAGE",
        "cost_T": "5*c1 + c2*(log2(n)+1) + 3*c3*log2(n) + q*c4 + (1-q)*c7",
        "probability_P": "1"
      }
    ],
    "control_variables": [],
    "metadata": {
      "algorithm_type": "iterative",
      "loop_count": 0,
      "nesting_level": 0,
      "parameters": {},
      "llm_analysis": {
        "best_case": {
          "scenario_type": "best_case",
          "input_description": "El elemento buscado x se encuentra exactamente en la posicion media del arreglo en la primera iteracion",
          "input_characteristics": {
            "position": "n/2",
            "found": true,
            "iterations": "1"
          },
          "is_iterative": true,
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "int izq, der, medio",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Declaracion de variables enteras. Se ejecuta exactamente una vez al inicio del algoritmo."
            },
            {
              "line_number": 2,
              "code": "bool encontrado",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Declaracion de variable booleana. Se ejecuta exactamente una vez al inicio del algoritmo."
            },
            {
              "line_number": 3,
              "code": "izq <- 1",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion de limite izquierdo. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 4,
              "code": "der <- n",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion de limite derecho. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 5,
              "code": "encontrado <- F",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion de bandera booleana en falso. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 6,
              "code": "while (izq <= der and not encontrado) do",
              "C_op": "c2",
              "Freq": "2",
              "Total": "c2*2",
              "explanation": "Encabezado del while con dos comparaciones logicas. En el mejor caso se ejecuta 2 veces: una para entrar al loop (condicion verdadera) y otra para salir (condicion falsa porque encontrado es T)."
            },
            {
              "line_number": 7,
              "code": "medio <- (izq + der) / 2",
              "C_op": "c3",
              "Freq": "1",
              "Total": "c3",
              "explanation": "Calculo del punto medio con suma, division y floor. Se ejecuta 1 vez en el mejor caso."
            },
            {
              "line_number": 8,
              "code": "if (A[medio] = x) then",
              "C_op": "c3",
              "Freq": "1",
              "Total": "c3",
              "explanation": "Comparacion con acceso a array. Se ejecuta 1 vez y la condicion es verdadera en el mejor caso."
            },
            {
              "line_number": 9,
              "code": "encontrado <- T",
              "C_op": "c4",
              "Freq": "1",
              "Total": "c4",
              "explanation": "Asignacion cuando se encuentra el elemento. Se ejecuta 1 vez en el mejor caso."
            },
            {
              "line_number": 10,
              "code": "if (A[medio] < x) then",
              "C_op": "c3",
              "Freq": "0",
              "Total": "0",
              "explanation": "Esta comparacion NO se ejecuta en el mejor caso porque el if anterior fue verdadero y se ejecuto su bloque, saltando el else completo."
            },
            {
              "line_number": 11,
              "code": "izq <- medio + 1",
              "C_op": "c1",
              "Freq": "0",
              "Total": "0",
              "explanation": "Esta asignacion NO se ejecuta en el mejor caso porque esta dentro del else que no se ejecuta."
            },
            {
              "line_number": 12,
              "code": "der <- medio - 1",
              "C_op": "c1",
              "Freq": "0",
              "Total": "0",
              "explanation": "Esta asignacion NO se ejecuta en el mejor caso porque esta dentro del else anidado que no se ejecuta."
            },
            {
              "line_number": 13,
              "code": "return encontrado",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Retorno del resultado booleano. Se ejecuta exactamente una vez al final del algoritmo."
            }
          ],
          "total_cost_T": "c1 + c1 + c1 + c1 + c1 + c2*2 + c3 + c3 + c4 + c1",
          "total_cost_explanation": "Suma de todos los costos linea por linea. Simplificando: 6*c1 + 2*c2 + 2*c3 + c4. El mejor caso ocurre cuando el elemento buscado esta exactamente en la posicion media calculada en la primera iteracion, lo que causa que el algoritmo termine inmediatamente despues de una sola comparacion exitosa.",
          "probability_P": "q/n",
          "probability_explanation": "La probabilidad de que el elemento buscado este en una posicion especifica (la posicion media) es q/n, donde q es la probabilidad de que el elemento exista en el arreglo y 1/n es la probabilidad de que este en esa posicion particular. Si asumimos que el elemento siempre existe (q=1), entonces P(S) = 1/n."
        },
        "worst_case": {
          "scenario_type": "worst_case",
          "input_description": "Elemento no encontrado en el array ordenado, lo que causa que el algoritmo realice el maximo numero de divisiones binarias posibles hasta que izq > der",
          "input_characteristics": {
            "found": false,
            "iterations": "log2(n)"
          },
          "is_iterative": true,
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "int izq, der, medio",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Declaracion de variables enteras. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 2,
              "code": "bool encontrado",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Declaracion de variable booleana. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 3,
              "code": "izq <- 1",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion del limite izquierdo. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 4,
              "code": "der <- n",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion del limite derecho. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 5,
              "code": "encontrado <- F",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion de la bandera encontrado en falso. Se ejecuta exactamente una vez."
            },
            {
              "line_number": 6,
              "code": "while (izq <= der and not encontrado) do",
              "C_op": "c2",
              "Freq": "log2(n)+1",
              "Total": "c2*(log2(n)+1)",
              "explanation": "Encabezado del while con dos condiciones. En el peor caso (elemento no encontrado), el loop se ejecuta log2(n) veces, por lo que el encabezado se evalua log2(n)+1 veces."
            },
            {
              "line_number": 7,
              "code": "medio <- (izq + der) / 2",
              "C_op": "c3",
              "Freq": "log2(n)",
              "Total": "c3*log2(n)",
              "explanation": "Calculo del punto medio con suma, division y asignacion. Se ejecuta log2(n) veces en el peor caso."
            },
            {
              "line_number": 8,
              "code": "if (A[medio] = x) then",
              "C_op": "c3",
              "Freq": "log2(n)",
              "Total": "c3*log2(n)",
              "explanation": "Comparacion del elemento medio con x, incluye acceso a array. Se ejecuta log2(n) veces. En el peor caso esta condicion siempre es falsa."
            },
            {
              "line_number": 9,
              "code": "encontrado <- T",
              "C_op": "c4",
              "Freq": "0",
              "Total": "0",
              "explanation": "Asignacion dentro del if cuando se encuentra el elemento. En el peor caso (elemento no encontrado) esta linea nunca se ejecuta."
            },
            {
              "line_number": 10,
              "code": "if (A[medio] < x) then",
              "C_op": "c3",
              "Freq": "log2(n)",
              "Total": "c3*log2(n)",
              "explanation": "Comparacion para determinar en que mitad buscar, incluye acceso a array. Se ejecuta log2(n) veces en el peor caso."
            },
            {
              "line_number": 11,
              "code": "izq <- medio + 1",
              "C_op": "c3",
              "Freq": "log2(n)/2",
              "Total": "c3*log2(n)/2",
              "explanation": "Actualizacion del limite izquierdo. Se ejecuta aproximadamente la mitad de las iteraciones cuando el elemento buscado seria mayor que el medio."
            },
            {
              "line_number": 12,
              "code": "der <- medio - 1",
              "C_op": "c3",
              "Freq": "log2(n)/2",
              "Total": "c3*log2(n)/2",
              "explanation": "Actualizacion del limite derecho. Se ejecuta aproximadamente la mitad de las iteraciones cuando el elemento buscado seria menor que el medio."
            },
            {
              "line_number": 13,
              "code": "return encontrado",
              "C_op": "c7",
              "Freq": "1",
              "Total": "c7",
              "explanation": "Retorno del resultado. Se ejecuta exactamente una vez al finalizar el algoritmo."
            }
          ],
          "total_cost_T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7",
          "total_cost_explanation": "Suma de todos los costos linea por linea. Simplificando: 5*c1 + c2*(log2(n)+1) + 4*c3*log2(n) + c7. El termino dominante es log2(n), lo que confirma la complejidad O(log n) de la busqueda binaria en el peor caso.",
          "probability_P": "1",
          "probability_explanation": "En el contexto de analisis de peor caso, consideramos el escenario que maximiza las operaciones. Para busqueda binaria, esto ocurre cuando el elemento no esta presente, forzando al algoritmo a realizar todas las divisiones posibles hasta que el espacio de busqueda se agote (izq > der)."
        },
        "average_case": {
          "scenario_type": "average_case",
          "input_condition": "Promedio sobre todos los escenarios posibles en bsqueda binaria",
          "probability_model": "Se consideran log2(n)+1 casos posibles donde el elemento puede ser encontrado (en cada nivel del rbol binario), ms el caso de no encontrado. Con parmetro q: P(encontrado en nivel k) = q*(2^(k-1))/n para k=1 a log2(n), P(encontrado en hoja) = q*(n-2^(log2(n))+1)/n, P(no encontrado) = 1-q.",
          "scenarios_breakdown": [
            {
              "scenario_id": "S_1",
              "description": "Encontrado en nivel 1 (raz del rbol binario, 1 comparacin)",
              "T": "5*c1 + c2*2 + c3 + c3 + c4",
              "P": "q/n"
            },
            {
              "scenario_id": "S_2",
              "description": "Encontrado en nivel 2 (2 comparaciones)",
              "T": "5*c1 + c2*3 + c3*2 + c3*2 + c3 + c4",
              "P": "q*2/n"
            },
            {
              "scenario_id": "S_k",
              "description": "Encontrado en nivel k (k comparaciones, k<=log2(n))",
              "T": "5*c1 + c2*(k+1) + c3*k + c3*k + c3*(k-1)/2 + c3*(k-1)/2 + c4",
              "P": "q*2^(k-1)/n"
            },
            {
              "scenario_id": "S_log",
              "description": "Encontrado en nivel log2(n) (mximo nmero de comparaciones para encontrar)",
              "T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*(log2(n)-1)/2 + c3*(log2(n)-1)/2 + c4",
              "P": "q*(n-2^(log2(n)-1))/n"
            },
            {
              "scenario_id": "S_not_found",
              "description": "No encontrado (log2(n)+1 comparaciones)",
              "T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7",
              "P": "1-q"
            }
          ],
          "average_cost_formula": "E[T] = q*SUM(k=1 to log2(n))[2^(k-1)/n * (5*c1 + c2*(k+1) + c3*k + c3*k + c3*(k-1)/2 + c3*(k-1)/2 + c4)] + (1-q)*(5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7)",
          "T_of_S": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + q*c4 + (1-q)*c7",
          "T_of_S_simplified": "5*c1 + c2*(log2(n)+1) + 3*c3*log2(n) + q*c4 + (1-q)*c7",
          "T_of_S_explanation": "Costo esperado calculado como suma ponderada de todos los escenarios. En bsqueda binaria, el costo promedio es aproximadamente log2(n) comparaciones, similar al peor caso, debido a la estructura balanceada del rbol de decisin. La probabilidad q pondera entre encontrar el elemento (con costo c4) y no encontrarlo (con costo c7).",
          "P_of_S": "1",
          "P_of_S_explanation": "El caso promedio engloba todos los escenarios posibles con sus probabilidades respectivas, sumando a 1",
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "izq <- 1",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion del limite izquierdo. Se ejecuta exactamente una vez en todos los escenarios."
            },
            {
              "line_number": 2,
              "code": "der <- n",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion del limite derecho. Se ejecuta exactamente una vez en todos los escenarios."
            },
            {
              "line_number": 3,
              "code": "encontrado <- F",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion de variable booleana. Se ejecuta exactamente una vez en todos los escenarios."
            },
            {
              "line_number": 4,
              "code": "while (izq <= der and not encontrado) do",
              "C_op": "c2",
              "Freq": "log2(n)+1",
              "Total": "c2*(log2(n)+1)",
              "explanation": "Encabezado del while con dos comparaciones y operacion logica. En promedio, el loop ejecuta aproximadamente log2(n) iteraciones (similar al peor caso en bsqueda binaria), por lo que el encabezado se evala log2(n)+1 veces."
            },
            {
              "line_number": 5,
              "code": "medio <- floor((izq + der) / 2)",
              "C_op": "c3",
              "Freq": "log2(n)",
              "Total": "c3*log2(n)",
              "explanation": "Calculo del punto medio con suma, division y floor. Se ejecuta en cada iteracion del while, aproximadamente log2(n) veces en promedio."
            },
            {
              "line_number": 6,
              "code": "if (A[medio] = x) then",
              "C_op": "c3",
              "Freq": "log2(n)",
              "Total": "c3*log2(n)",
              "explanation": "Comparacion del elemento medio con x (acceso a array y comparacion). Se ejecuta en cada iteracion del while, aproximadamente log2(n) veces en promedio."
            },
            {
              "line_number": 7,
              "code": "encontrado <- T",
              "C_op": "c4",
              "Freq": "q",
              "Total": "q*c4",
              "explanation": "Asignacion cuando se encuentra el elemento. Se ejecuta con probabilidad q (probabilidad de que el elemento exista en el arreglo)."
            },
            {
              "line_number": 8,
              "code": "if (A[medio] < x) then",
              "C_op": "c3",
              "Freq": "log2(n)/2",
              "Total": "c3*log2(n)/2",
              "explanation": "Comparacion para decidir si buscar en mitad derecha. Se ejecuta aproximadamente en la mitad de las iteraciones (cuando no se encuentra en la comparacion anterior)."
            },
            {
              "line_number": 9,
              "code": "izq <- medio + 1",
              "C_op": "c3",
              "Freq": "log2(n)/2",
              "Total": "c3*log2(n)/2",
              "explanation": "Actualizacion del limite izquierdo. Se ejecuta aproximadamente en la mitad de las iteraciones (cuando A[medio] < x)."
            },
            {
              "line_number": 10,
              "code": "der <- medio - 1",
              "C_op": "c3",
              "Freq": "log2(n)/2",
              "Total": "c3*log2(n)/2",
              "explanation": "Actualizacion del limite derecho. Se ejecuta aproximadamente en la mitad de las iteraciones (cuando A[medio] > x)."
            },
            {
              "line_number": 11,
              "code": "return encontrado",
              "C_op": "c7",
              "Freq": "1",
              "Total": "c7",
              "explanation": "Retorno del resultado. Se ejecuta exactamente una vez en todos los escenarios."
            }
          ],
          "average_cost_simplified": "5*c1 + c2*(log2(n)+1) + 3*c3*log2(n) + q*c4 + (1-q)*c7"
        }
      },
      "best_case": {
        "scenario_id": "S_best_case",
        "semantic_id": "best_case",
        "T": "c1 + c1 + c1 + c1 + c1 + c2*2 + c3 + c3 + c4 + c1",
        "P": "q/n",
        "description": "El elemento buscado x se encuentra exactamente en la posicion media del arreglo en la primera iteracion",
        "input_characteristics": {
          "position": "n/2",
          "found": true,
          "iterations": "1"
        }
      },
      "worst_case": {
        "scenario_id": "S_worst_case",
        "semantic_id": "worst_case",
        "T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7",
        "P": "1",
        "description": "Elemento no encontrado en el array ordenado, lo que causa que el algoritmo realice el maximo numero de divisiones binarias posibles hasta que izq > der",
        "input_characteristics": {
          "found": false,
          "iterations": "log2(n)"
        }
      },
      "average_case": {
        "scenario_id": "S_avg",
        "semantic_id": "average_case",
        "T_avg": "5*c1 + c2*(log2(n)+1) + 3*c3*log2(n) + q*c4 + (1-q)*c7",
        "formula": "E[T] = q*SUM(k=1 to log2(n))[2^(k-1)/n * (5*c1 + c2*(k+1) + c3*k + c3*k + c3*(k-1)/2 + c3*(k-1)/2 + c4)] + (1-q)*(5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7)",
        "simplified": "5*c1 + c2*(log2(n)+1) + 3*c3*log2(n) + q*c4 + (1-q)*c7",
        "description": "Promedio sobre todos los escenarios posibles en bsqueda binaria",
        "scenarios_breakdown": [
          {
            "scenario_id": "S_1",
            "description": "Encontrado en nivel 1 (raz del rbol binario, 1 comparacin)",
            "T": "5*c1 + c2*2 + c3 + c3 + c4",
            "P": "q/n"
          },
          {
            "scenario_id": "S_2",
            "description": "Encontrado en nivel 2 (2 comparaciones)",
            "T": "5*c1 + c2*3 + c3*2 + c3*2 + c3 + c4",
            "P": "q*2/n"
          },
          {
            "scenario_id": "S_k",
            "description": "Encontrado en nivel k (k comparaciones, k<=log2(n))",
            "T": "5*c1 + c2*(k+1) + c3*k + c3*k + c3*(k-1)/2 + c3*(k-1)/2 + c4",
            "P": "q*2^(k-1)/n"
          },
          {
            "scenario_id": "S_log",
            "description": "Encontrado en nivel log2(n) (mximo nmero de comparaciones para encontrar)",
            "T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*(log2(n)-1)/2 + c3*(log2(n)-1)/2 + c4",
            "P": "q*(n-2^(log2(n)-1))/n"
          },
          {
            "scenario_id": "S_not_found",
            "description": "No encontrado (log2(n)+1 comparaciones)",
            "T": "5*c1 + c2*(log2(n)+1) + c3*log2(n) + c3*log2(n) + c3*log2(n)/2 + c3*log2(n)/2 + c7",
            "P": "1-q"
          }
        ]
      }
    }
  },
  "errors": [],
  "warnings": []
}