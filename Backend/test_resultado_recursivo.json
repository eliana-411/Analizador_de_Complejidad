{
  "pseudocode": "fibonacci(int n)\nbegin\n    if (n ≤ 1) then\n    begin\n        return n\n    end\n    else\n    begin\n        return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)\n    end\nend\n",
  "algorithm_name": "busqueda_binaria",
  "is_iterative": false,
  "parameters": {
    "arr": "array",
    "objetivo": "int",
    "inicio": "int",
    "fin": "int"
  },
  "lines": [
    "fibonacci(int n)",
    "begin",
    "    if (n ≤ 1) then",
    "    begin",
    "        return n",
    "    end",
    "    else",
    "    begin",
    "        return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)",
    "    end",
    "end"
  ],
  "loops": [],
  "recursive_calls": [],
  "is_recursive": false,
  "control_variables": [],
  "raw_scenarios": [
    {
      "id": "S_best_case",
      "semantic_id": "best_case",
      "condition": "n = 2 (el valor minimo no trivial que requiere recursion). Para n=2, el algoritmo hace dos llamadas recursivas a fibonacci(1) y fibonacci(0), ambos casos base que retornan inmediatamente sin mas recursion.",
      "state": "BEST_CASE",
      "cost_T": "T(n) = T(n-1) + T(n-2) + c1 + c3",
      "probability_P": "1",
      "input_description": "n = 2 (el valor minimo no trivial que requiere recursion). Para n=2, el algoritmo hace dos llamadas recursivas a fibonacci(1) y fibonacci(0), ambos casos base que retornan inmediatamente sin mas recursion.",
      "input_characteristics": {},
      "is_iterative": false,
      "recurrence_relation": "",
      "base_case_cost": "",
      "base_case_condition": ""
    },
    {
      "id": "S_worst_case",
      "semantic_id": "worst_case",
      "condition": "Cualquier valor de n mayor que 1, ya que Fibonacci siempre genera el arbol recursivo completo con dos llamadas por nivel hasta llegar a los casos base",
      "state": "WORST_CASE",
      "cost_T": "T(n) = T(n-1) + T(n-2) + c1 + c3",
      "probability_P": "1",
      "input_description": "Cualquier valor de n mayor que 1, ya que Fibonacci siempre genera el arbol recursivo completo con dos llamadas por nivel hasta llegar a los casos base",
      "input_characteristics": {},
      "is_iterative": false,
      "recurrence_relation": "",
      "base_case_cost": "",
      "base_case_condition": ""
    },
    {
      "id": "S_base_case",
      "semantic_id": "S_intermediate_1",
      "condition": "Caso base cuando n <= 1",
      "state": "INTERMEDIATE",
      "cost_T": "c1",
      "probability_P": "Despreciable para n grande",
      "input_description": "Caso base cuando n <= 1",
      "input_characteristics": {}
    },
    {
      "id": "S_recursive_case",
      "semantic_id": "S_intermediate_2",
      "condition": "Caso recursivo cuando n > 1",
      "state": "INTERMEDIATE",
      "cost_T": "T(n-1) + T(n-2) + c1 + c2",
      "probability_P": "Dominante para n >= 2",
      "input_description": "Caso recursivo cuando n > 1",
      "input_characteristics": {}
    },
    {
      "id": "S_avg",
      "semantic_id": "average_case",
      "condition": "Valores de n distribuidos uniformemente en el rango de entradas tpicas. El caso promedio de Fibonacci considera el comportamiento esperado sobre todas las posibles entradas n >= 0.",
      "state": "AVERAGE",
      "cost_T": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
      "probability_P": "1",
      "input_description": "Valores de n distribuidos uniformemente en el rango de entradas tpicas. El caso promedio de Fibonacci considera el comportamiento esperado sobre todas las posibles entradas n >= 0.",
      "input_characteristics": {},
      "average_cost_formula": "E[T(n)] = T(n-1) + T(n-2) + c1 + c3 para n > 1; E[T(n)] = c1 + c2 para n <= 1",
      "average_cost_simplified": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3"
    }
  ],
  "llm_analysis": {
    "best_case": {
      "scenario_id": "S_best_case",
      "scenario_type": "best_case",
      "input_condition": "n = 2 (el valor minimo no trivial que requiere recursion). Para n=2, el algoritmo hace dos llamadas recursivas a fibonacci(1) y fibonacci(0), ambos casos base que retornan inmediatamente sin mas recursion.",
      "line_by_line_analysis": [
        {
          "line_number": 1,
          "code": "if (n <= 1) then",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Comparacion del caso base, se ejecuta una vez por cada llamada recursiva"
        },
        {
          "line_number": 2,
          "code": "return n",
          "C_op": "c2",
          "Freq": "0",
          "Total": "0",
          "explanation": "Para n=2, esta linea NO se ejecuta porque la condicion es falsa. Solo se ejecuta en casos base (n=0 o n=1)"
        },
        {
          "line_number": 3,
          "code": "return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)",
          "C_op": "c3",
          "Freq": "2 llamadas",
          "Total": "T(1) + T(0) + c3",
          "explanation": "Se realizan dos llamadas recursivas: fibonacci(1) y fibonacci(0). Ambas son casos base con costo constante. El costo c3 incluye la suma y el retorno"
        }
      ],
      "T_of_S": "T(n) = T(n-1) + T(n-2) + c1 + c3",
      "T_of_S_explanation": "Para el mejor caso (n=2), se realizan dos llamadas recursivas a T(n-1)=T(1) y T(n-2)=T(0), que son casos base con costo constante c2 cada uno. El costo local incluye la comparacion inicial (c1) y la operacion de suma y retorno (c3). Aunque T(1) y T(0) son constantes, la forma general de la recurrencia para cualquier n>=2 es T(n) = T(n-1) + T(n-2) + c1 + c3, donde el mejor caso minimiza la profundidad del arbol recursivo eligiendo el n mas pequeno posible (n=2).",
      "P_of_S": "1",
      "P_of_S_explanation": "Para un valor especifico de n=2, la probabilidad es 1 (deterministico). Si consideramos una distribucion uniforme sobre posibles valores de entrada n en rango [2, N], entonces P(n=2) = 1/(N-1), pero dado que el mejor caso se define para n=2 especificamente, usamos P=1.",
      "probability_model": "Modelo deterministico: dado que el mejor caso se define como n=2 (el valor minimo no trivial), no hay aleatoriedad en la entrada. El algoritmo siempre ejecutara exactamente dos llamadas recursivas a casos base cuando n=2."
    },
    "worst_case": {
      "scenario_id": "S_worst_case",
      "scenario_type": "worst_case",
      "input_condition": "Cualquier valor de n mayor que 1, ya que Fibonacci siempre genera el arbol recursivo completo con dos llamadas por nivel hasta llegar a los casos base",
      "line_by_line_analysis": [
        {
          "line_number": 1,
          "code": "if (n <= 1) then",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Comparacion del caso base, se ejecuta una vez en cada llamada"
        },
        {
          "line_number": 2,
          "code": "return n",
          "C_op": "c2",
          "Freq": "0",
          "Total": "0",
          "explanation": "En el peor caso (n > 1), esta linea NO se ejecuta, solo se ejecuta en casos base"
        },
        {
          "line_number": 3,
          "code": "return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)",
          "C_op": "c3",
          "Freq": "2 llamadas",
          "Total": "T(n-1) + T(n-2) + c3",
          "explanation": "Dos llamadas recursivas: una con tamano n-1 y otra con tamano n-2, mas el costo de la suma (c3)"
        }
      ],
      "T_of_S": "T(n) = T(n-1) + T(n-2) + c1 + c3",
      "T_of_S_explanation": "Recurrencia de Fibonacci clasica: dos llamadas recursivas con tamanos n-1 y n-2, mas el costo local de la comparacion (c1) y la suma (c3). Esta recurrencia genera un arbol binario completo de profundidad n, resultando en crecimiento exponencial",
      "P_of_S": "1",
      "P_of_S_explanation": "Para cualquier n > 1, el algoritmo siempre ejecuta ambas llamadas recursivas, generando el arbol completo. No hay variabilidad en el comportamiento",
      "probability_model": "Deterministico: Fibonacci no depende de la entrada de datos sino solo del valor de n. Para todo n > 1, siempre se generan exactamente 2 llamadas recursivas, por lo que la probabilidad del peor caso es 1 (certeza)"
    },
    "average_case": {
      "scenario_id": "S_avg_case",
      "scenario_type": "average_case",
      "input_condition": "Valores de n distribuidos uniformemente en el rango de entradas tpicas. El caso promedio de Fibonacci considera el comportamiento esperado sobre todas las posibles entradas n >= 0.",
      "probability_model": "Para Fibonacci, el caso promedio es idntico al peor caso porque el algoritmo recursivo siempre realiza las mismas dos llamadas recursivas T(n-1) y T(n-2) independientemente del valor especfico de n. No hay variabilidad en la estructura de las llamadas recursivas basada en los datos de entrada, solo en el tamao n.",
      "scenarios_breakdown": [
        {
          "scenario_id": "S_base_case",
          "description": "Caso base cuando n <= 1",
          "T": "c1",
          "P": "Despreciable para n grande"
        },
        {
          "scenario_id": "S_recursive_case",
          "description": "Caso recursivo cuando n > 1",
          "T": "T(n-1) + T(n-2) + c1 + c2",
          "P": "Dominante para n >= 2"
        }
      ],
      "line_by_line_analysis": [
        {
          "line_number": 1,
          "code": "if (n <= 1) then",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Comparacin ejecutada en cada llamada para verificar caso base"
        },
        {
          "line_number": 2,
          "code": "return n",
          "C_op": "c2",
          "Freq": "1 (solo si n <= 1)",
          "Total": "c2",
          "explanation": "Retorno del caso base, ejecutado solo cuando n <= 1"
        },
        {
          "line_number": 3,
          "code": "return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)",
          "C_op": "c3",
          "Freq": "1 (solo si n > 1)",
          "Total": "T(n-1) + T(n-2) + c3",
          "explanation": "Dos llamadas recursivas mas la suma de resultados. El costo c3 incluye la operacion de suma y el retorno"
        }
      ],
      "T_of_S": "E[T(n)] = T(n-1) + T(n-2) + c1 + c3 para n > 1; E[T(n)] = c1 + c2 para n <= 1",
      "T_of_S_simplified": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
      "T_of_S_explanation": "Para Fibonacci recursivo, el caso promedio es idntico al peor caso porque no existe variabilidad en el patrn de ejecucin. Cada llamada con n > 1 siempre genera exactamente dos llamadas recursivas: T(n-1) y T(n-2), ms un costo constante c4 para la comparacin inicial y la suma final. Esta recurrencia es determinstica y no depende de ninguna distribucin probabilstica de datos de entrada.",
      "P_of_S": "1",
      "P_of_S_explanation": "P = 1 porque el caso promedio representa el comportamiento universal del algoritmo. A diferencia de algoritmos como QuickSort o bsqueda, Fibonacci no tiene variabilidad basada en la distribucin de datos: para cualquier n dado, siempre ejecuta exactamente el mismo rbol de llamadas recursivas. Por lo tanto, mejor caso = peor caso = caso promedio en trminos de estructura de recurrencia.",
      "average_cost_simplified": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
      "average_cost_formula": "E[T(n)] = T(n-1) + T(n-2) + c1 + c3 para n > 1; E[T(n)] = c1 + c2 para n <= 1"
    }
  },
  "omega_table": {
    "algorithm_name": "busqueda_binaria",
    "scenarios": [
      {
        "id": "S_best_case",
        "semantic_id": "best_case",
        "condition": "n = 2 (el valor minimo no trivial que requiere recursion). Para n=2, el algoritmo hace dos llamadas recursivas a fibonacci(1) y fibonacci(0), ambos casos base que retornan inmediatamente sin mas recursion.",
        "state": "BEST_CASE",
        "cost_T": "T(n) = T(n-1) + T(n-2) + c1 + c3",
        "probability_P": "1"
      },
      {
        "id": "S_worst_case",
        "semantic_id": "worst_case",
        "condition": "Cualquier valor de n mayor que 1, ya que Fibonacci siempre genera el arbol recursivo completo con dos llamadas por nivel hasta llegar a los casos base",
        "state": "WORST_CASE",
        "cost_T": "T(n) = T(n-1) + T(n-2) + c1 + c3",
        "probability_P": "1"
      },
      {
        "id": "S_base_case",
        "semantic_id": "S_intermediate_1",
        "condition": "Caso base cuando n <= 1",
        "state": "INTERMEDIATE",
        "cost_T": "c1",
        "probability_P": "Despreciable para n grande"
      },
      {
        "id": "S_recursive_case",
        "semantic_id": "S_intermediate_2",
        "condition": "Caso recursivo cuando n > 1",
        "state": "INTERMEDIATE",
        "cost_T": "T(n-1) + T(n-2) + c1 + c2",
        "probability_P": "Dominante para n >= 2"
      },
      {
        "id": "S_avg",
        "semantic_id": "average_case",
        "condition": "Valores de n distribuidos uniformemente en el rango de entradas tpicas. El caso promedio de Fibonacci considera el comportamiento esperado sobre todas las posibles entradas n >= 0.",
        "state": "AVERAGE",
        "cost_T": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
        "probability_P": "1"
      }
    ],
    "control_variables": [],
    "metadata": {
      "algorithm_type": "recursive",
      "loop_count": 0,
      "nesting_level": 0,
      "parameters": {
        "arr": "array",
        "objetivo": "int",
        "inicio": "int",
        "fin": "int"
      },
      "llm_analysis": {
        "best_case": {
          "scenario_id": "S_best_case",
          "scenario_type": "best_case",
          "input_condition": "n = 2 (el valor minimo no trivial que requiere recursion). Para n=2, el algoritmo hace dos llamadas recursivas a fibonacci(1) y fibonacci(0), ambos casos base que retornan inmediatamente sin mas recursion.",
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "if (n <= 1) then",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Comparacion del caso base, se ejecuta una vez por cada llamada recursiva"
            },
            {
              "line_number": 2,
              "code": "return n",
              "C_op": "c2",
              "Freq": "0",
              "Total": "0",
              "explanation": "Para n=2, esta linea NO se ejecuta porque la condicion es falsa. Solo se ejecuta en casos base (n=0 o n=1)"
            },
            {
              "line_number": 3,
              "code": "return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)",
              "C_op": "c3",
              "Freq": "2 llamadas",
              "Total": "T(1) + T(0) + c3",
              "explanation": "Se realizan dos llamadas recursivas: fibonacci(1) y fibonacci(0). Ambas son casos base con costo constante. El costo c3 incluye la suma y el retorno"
            }
          ],
          "T_of_S": "T(n) = T(n-1) + T(n-2) + c1 + c3",
          "T_of_S_explanation": "Para el mejor caso (n=2), se realizan dos llamadas recursivas a T(n-1)=T(1) y T(n-2)=T(0), que son casos base con costo constante c2 cada uno. El costo local incluye la comparacion inicial (c1) y la operacion de suma y retorno (c3). Aunque T(1) y T(0) son constantes, la forma general de la recurrencia para cualquier n>=2 es T(n) = T(n-1) + T(n-2) + c1 + c3, donde el mejor caso minimiza la profundidad del arbol recursivo eligiendo el n mas pequeno posible (n=2).",
          "P_of_S": "1",
          "P_of_S_explanation": "Para un valor especifico de n=2, la probabilidad es 1 (deterministico). Si consideramos una distribucion uniforme sobre posibles valores de entrada n en rango [2, N], entonces P(n=2) = 1/(N-1), pero dado que el mejor caso se define para n=2 especificamente, usamos P=1.",
          "probability_model": "Modelo deterministico: dado que el mejor caso se define como n=2 (el valor minimo no trivial), no hay aleatoriedad en la entrada. El algoritmo siempre ejecutara exactamente dos llamadas recursivas a casos base cuando n=2."
        },
        "worst_case": {
          "scenario_id": "S_worst_case",
          "scenario_type": "worst_case",
          "input_condition": "Cualquier valor de n mayor que 1, ya que Fibonacci siempre genera el arbol recursivo completo con dos llamadas por nivel hasta llegar a los casos base",
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "if (n <= 1) then",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Comparacion del caso base, se ejecuta una vez en cada llamada"
            },
            {
              "line_number": 2,
              "code": "return n",
              "C_op": "c2",
              "Freq": "0",
              "Total": "0",
              "explanation": "En el peor caso (n > 1), esta linea NO se ejecuta, solo se ejecuta en casos base"
            },
            {
              "line_number": 3,
              "code": "return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)",
              "C_op": "c3",
              "Freq": "2 llamadas",
              "Total": "T(n-1) + T(n-2) + c3",
              "explanation": "Dos llamadas recursivas: una con tamano n-1 y otra con tamano n-2, mas el costo de la suma (c3)"
            }
          ],
          "T_of_S": "T(n) = T(n-1) + T(n-2) + c1 + c3",
          "T_of_S_explanation": "Recurrencia de Fibonacci clasica: dos llamadas recursivas con tamanos n-1 y n-2, mas el costo local de la comparacion (c1) y la suma (c3). Esta recurrencia genera un arbol binario completo de profundidad n, resultando en crecimiento exponencial",
          "P_of_S": "1",
          "P_of_S_explanation": "Para cualquier n > 1, el algoritmo siempre ejecuta ambas llamadas recursivas, generando el arbol completo. No hay variabilidad en el comportamiento",
          "probability_model": "Deterministico: Fibonacci no depende de la entrada de datos sino solo del valor de n. Para todo n > 1, siempre se generan exactamente 2 llamadas recursivas, por lo que la probabilidad del peor caso es 1 (certeza)"
        },
        "average_case": {
          "scenario_id": "S_avg_case",
          "scenario_type": "average_case",
          "input_condition": "Valores de n distribuidos uniformemente en el rango de entradas tpicas. El caso promedio de Fibonacci considera el comportamiento esperado sobre todas las posibles entradas n >= 0.",
          "probability_model": "Para Fibonacci, el caso promedio es idntico al peor caso porque el algoritmo recursivo siempre realiza las mismas dos llamadas recursivas T(n-1) y T(n-2) independientemente del valor especfico de n. No hay variabilidad en la estructura de las llamadas recursivas basada en los datos de entrada, solo en el tamao n.",
          "scenarios_breakdown": [
            {
              "scenario_id": "S_base_case",
              "description": "Caso base cuando n <= 1",
              "T": "c1",
              "P": "Despreciable para n grande"
            },
            {
              "scenario_id": "S_recursive_case",
              "description": "Caso recursivo cuando n > 1",
              "T": "T(n-1) + T(n-2) + c1 + c2",
              "P": "Dominante para n >= 2"
            }
          ],
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "if (n <= 1) then",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Comparacin ejecutada en cada llamada para verificar caso base"
            },
            {
              "line_number": 2,
              "code": "return n",
              "C_op": "c2",
              "Freq": "1 (solo si n <= 1)",
              "Total": "c2",
              "explanation": "Retorno del caso base, ejecutado solo cuando n <= 1"
            },
            {
              "line_number": 3,
              "code": "return CALL fibonacci(n - 1) + CALL fibonacci(n - 2)",
              "C_op": "c3",
              "Freq": "1 (solo si n > 1)",
              "Total": "T(n-1) + T(n-2) + c3",
              "explanation": "Dos llamadas recursivas mas la suma de resultados. El costo c3 incluye la operacion de suma y el retorno"
            }
          ],
          "T_of_S": "E[T(n)] = T(n-1) + T(n-2) + c1 + c3 para n > 1; E[T(n)] = c1 + c2 para n <= 1",
          "T_of_S_simplified": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
          "T_of_S_explanation": "Para Fibonacci recursivo, el caso promedio es idntico al peor caso porque no existe variabilidad en el patrn de ejecucin. Cada llamada con n > 1 siempre genera exactamente dos llamadas recursivas: T(n-1) y T(n-2), ms un costo constante c4 para la comparacin inicial y la suma final. Esta recurrencia es determinstica y no depende de ninguna distribucin probabilstica de datos de entrada.",
          "P_of_S": "1",
          "P_of_S_explanation": "P = 1 porque el caso promedio representa el comportamiento universal del algoritmo. A diferencia de algoritmos como QuickSort o bsqueda, Fibonacci no tiene variabilidad basada en la distribucin de datos: para cualquier n dado, siempre ejecuta exactamente el mismo rbol de llamadas recursivas. Por lo tanto, mejor caso = peor caso = caso promedio en trminos de estructura de recurrencia.",
          "average_cost_simplified": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
          "average_cost_formula": "E[T(n)] = T(n-1) + T(n-2) + c1 + c3 para n > 1; E[T(n)] = c1 + c2 para n <= 1"
        }
      },
      "best_case": {
        "scenario_id": "S_best_case",
        "semantic_id": "best_case",
        "T": "T(n) = T(n-1) + T(n-2) + c1 + c3",
        "P": "1",
        "description": "n = 2 (el valor minimo no trivial que requiere recursion). Para n=2, el algoritmo hace dos llamadas recursivas a fibonacci(1) y fibonacci(0), ambos casos base que retornan inmediatamente sin mas recursion.",
        "input_characteristics": {}
      },
      "worst_case": {
        "scenario_id": "S_worst_case",
        "semantic_id": "worst_case",
        "T": "T(n) = T(n-1) + T(n-2) + c1 + c3",
        "P": "1",
        "description": "Cualquier valor de n mayor que 1, ya que Fibonacci siempre genera el arbol recursivo completo con dos llamadas por nivel hasta llegar a los casos base",
        "input_characteristics": {}
      },
      "average_case": {
        "scenario_id": "S_avg",
        "semantic_id": "average_case",
        "T_avg": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
        "formula": "E[T(n)] = T(n-1) + T(n-2) + c1 + c3 para n > 1; E[T(n)] = c1 + c2 para n <= 1",
        "simplified": "E[T(n)] = T(n-1) + T(n-2) + c4 donde c4 = c1 + c3",
        "description": "Valores de n distribuidos uniformemente en el rango de entradas tpicas. El caso promedio de Fibonacci considera el comportamiento esperado sobre todas las posibles entradas n >= 0.",
        "scenarios_breakdown": [
          {
            "scenario_id": "S_base_case",
            "description": "Caso base cuando n <= 1",
            "T": "c1",
            "P": "Despreciable para n grande"
          },
          {
            "scenario_id": "S_recursive_case",
            "description": "Caso recursivo cuando n > 1",
            "T": "T(n-1) + T(n-2) + c1 + c2",
            "P": "Dominante para n >= 2"
          }
        ]
      }
    }
  },
  "errors": [],
  "warnings": []
}