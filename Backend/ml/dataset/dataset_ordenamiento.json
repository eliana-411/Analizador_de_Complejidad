[
  {
    "id": "ordenamiento_bubble_1",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion ordenarBurbuja(arreglo, n)\n    para i desde 0 hasta n-1\n        para j desde 0 hasta n-i-1\n            si arreglo[j] > arreglo[j+1] entonces\n                temp = arreglo[j]\n                arreglo[j] = arreglo[j+1]\n                arreglo[j+1] = temp\n            fin si\n        fin para\n    fin para\n    retornar arreglo\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_2",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Algoritmo de ordenamiento burbuja optimizado\nfuncion bubbleSort(lista, tamaño)\n    intercambio = verdadero\n    mientras intercambio == verdadero\n        intercambio = falso\n        para indice desde 1 hasta tamaño-1\n            si lista[indice-1] > lista[indice] entonces\n                aux = lista[indice-1]\n                lista[indice-1] = lista[indice]\n                lista[indice] = aux\n                intercambio = verdadero\n            fin si\n        fin para\n        tamaño = tamaño - 1\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_3",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion ordenamiento_burbuja(datos, longitud)\n    repetir = verdadero\n    pasada = 0\n    mientras repetir == verdadero\n        repetir = falso\n        para pos desde 0 hasta longitud-pasada-2\n            si datos[pos] > datos[pos+1] entonces\n                temporal = datos[pos]\n                datos[pos] = datos[pos+1]\n                datos[pos+1] = temporal\n                repetir = verdadero\n            fin si\n        fin para\n        pasada = pasada + 1\n    fin mientras\n    retornar datos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_4",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion burbuja(vec, tam)\n    para vuelta desde 1 hasta tam-1\n        para elemento desde 0 hasta tam-vuelta-1\n            si vec[elemento] > vec[elemento+1] entonces\n                intercambiar(vec[elemento], vec[elemento+1])\n            fin si\n        fin para\n    fin para\nfin funcion\n\nfuncion intercambiar(a, b)\n    temp = a\n    a = b\n    b = temp\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_5",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Versión simple de ordenamiento burbuja\nfuncion ordenar(A, N)\n    para i desde 0 hasta N-2\n        para j desde 0 hasta N-2\n            si A[j] > A[j+1] entonces\n                guardar = A[j]\n                A[j] = A[j+1]\n                A[j+1] = guardar\n            fin si\n        fin para\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_6",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion metodo_burbuja(coleccion, cantidad)\n    limite = cantidad\n    mientras limite > 1\n        nuevo_limite = 0\n        para k desde 1 hasta limite-1\n            si coleccion[k-1] > coleccion[k] entonces\n                swap = coleccion[k-1]\n                coleccion[k-1] = coleccion[k]\n                coleccion[k] = swap\n                nuevo_limite = k\n            fin si\n        fin para\n        limite = nuevo_limite\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_7",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion bubble_ordenar(array, size)\n    ordenado = falso\n    mientras ordenado == falso\n        ordenado = verdadero\n        para idx desde 0 hasta size-2\n            si array[idx] > array[idx+1] entonces\n                temp_val = array[idx]\n                array[idx] = array[idx+1]\n                array[idx+1] = temp_val\n                ordenado = falso\n            fin si\n        fin para\n    fin mientras\n    retornar array\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_8",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Implementación con contador de pasadas\nfuncion ordenar_por_burbuja(secuencia, len)\n    contador = 0\n    para pasada desde 0 hasta len-1\n        para posicion desde 0 hasta len-pasada-2\n            si secuencia[posicion] > secuencia[posicion+1] entonces\n                buffer = secuencia[posicion]\n                secuencia[posicion] = secuencia[posicion+1]\n                secuencia[posicion+1] = buffer\n                contador = contador + 1\n            fin si\n        fin para\n    fin para\n    retornar contador\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_9",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion burbuja_mejorada(valores, total)\n    para ronda desde total hasta 2\n        cambios = 0\n        para p desde 1 hasta ronda-1\n            si valores[p-1] > valores[p] entonces\n                t = valores[p-1]\n                valores[p-1] = valores[p]\n                valores[p] = t\n                cambios = cambios + 1\n            fin si\n        fin para\n        si cambios == 0 entonces\n            romper\n        fin si\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_10",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion sort_bubble(elementos, num_elementos)\n    para externo desde num_elementos-1 hasta 1\n        para interno desde 0 hasta externo-1\n            si elementos[interno] > elementos[interno+1] entonces\n                auxiliar = elementos[interno]\n                elementos[interno] = elementos[interno+1]\n                elementos[interno+1] = auxiliar\n            fin si\n        fin para\n    fin para\n    retornar elementos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_11",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Burbuja bidireccional (cocktail sort)\nfuncion burbuja_bidireccional(arr, n)\n    inicio = 0\n    final = n - 1\n    mientras inicio < final\n        para i desde inicio hasta final-1\n            si arr[i] > arr[i+1] entonces\n                tmp = arr[i]\n                arr[i] = arr[i+1]\n                arr[i+1] = tmp\n            fin si\n        fin para\n        final = final - 1\n        para i desde final hasta inicio+1\n            si arr[i-1] > arr[i] entonces\n                tmp = arr[i-1]\n                arr[i-1] = arr[i]\n                arr[i] = tmp\n            fin si\n        fin para\n        inicio = inicio + 1\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_12",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion ordenamiento_ascendente(lista, longitud_lista)\n    hubo_cambio = 1\n    iteracion = 0\n    mientras hubo_cambio == 1\n        hubo_cambio = 0\n        para indice_actual desde 0 hasta longitud_lista-iteracion-2\n            si lista[indice_actual] > lista[indice_actual+1] entonces\n                variable_temporal = lista[indice_actual]\n                lista[indice_actual] = lista[indice_actual+1]\n                lista[indice_actual+1] = variable_temporal\n                hubo_cambio = 1\n            fin si\n        fin para\n        iteracion = iteracion + 1\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_13",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion bubble(vector, dimension)\n    para ciclo_externo desde 0 hasta dimension-2\n        minimo_encontrado = verdadero\n        para ciclo_interno desde 0 hasta dimension-ciclo_externo-2\n            si vector[ciclo_interno] > vector[ciclo_interno+1] entonces\n                respaldo = vector[ciclo_interno]\n                vector[ciclo_interno] = vector[ciclo_interno+1]\n                vector[ciclo_interno+1] = respaldo\n                minimo_encontrado = falso\n            fin si\n        fin para\n        si minimo_encontrado == verdadero entonces\n            retornar vector\n        fin si\n    fin para\n    retornar vector\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_14",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Ordenamiento burbuja con verificación de orden\nfuncion ordenar_elementos(conjunto, tam_conjunto)\n    para vuelta_externa desde 1 hasta tam_conjunto-1\n        esta_ordenado = verdadero\n        para comparacion desde 0 hasta tam_conjunto-vuelta_externa-1\n            primero = conjunto[comparacion]\n            segundo = conjunto[comparacion+1]\n            si primero > segundo entonces\n                conjunto[comparacion] = segundo\n                conjunto[comparacion+1] = primero\n                esta_ordenado = falso\n            fin si\n        fin para\n        si esta_ordenado entonces\n            salir\n        fin si\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_15",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion algoritmo_burbuja(datos, numero_datos)\n    tope = numero_datos\n    mientras tope > 0\n        ultima_pos = 0\n        para pos_actual desde 1 hasta tope-1\n            si datos[pos_actual-1] > datos[pos_actual] entonces\n                valor_temp = datos[pos_actual-1]\n                datos[pos_actual-1] = datos[pos_actual]\n                datos[pos_actual] = valor_temp\n                ultima_pos = pos_actual\n            fin si\n        fin para\n        tope = ultima_pos\n    fin mientras\n    retornar datos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_1",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion ordenamientoSeleccion(arreglo, n)\n    para i desde 0 hasta n-2 hacer\n        minimo = i\n        para j desde i+1 hasta n-1 hacer\n            si arreglo[j] < arreglo[minimo] entonces\n                minimo = j\n            fin si\n        fin para\n        temporal = arreglo[i]\n        arreglo[i] = arreglo[minimo]\n        arreglo[minimo] = temporal\n    fin para\n    retornar arreglo\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_2",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento selectionSort(lista, tamaño)\n    indice = 0\n    mientras indice < tamaño - 1 hacer\n        posicionMinima = indice\n        k = indice + 1\n        mientras k < tamaño hacer\n            si lista[k] < lista[posicionMinima] entonces\n                posicionMinima = k\n            fin si\n            k = k + 1\n        fin mientras\n        aux = lista[indice]\n        lista[indice] = lista[posicionMinima]\n        lista[posicionMinima] = aux\n        indice = indice + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_3",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "// Ordenamiento por selección con búsqueda de máximo\nfuncion ordenarPorSeleccion(vector, longitud)\n    para pos desde longitud-1 hasta 1 decrementando hacer\n        indiceMayor = 0\n        para buscar desde 1 hasta pos hacer\n            si vector[buscar] > vector[indiceMayor] entonces\n                indiceMayor = buscar\n            fin si\n        fin para\n        intercambiar(vector[pos], vector[indiceMayor])\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_4",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "algoritmo ordenacionSeleccion(datos, cantidad)\n    contador = 0\n    repetir\n        menor = contador\n        explorador = contador + 1\n        mientras explorador <= cantidad - 1 hacer\n            si datos[explorador] < datos[menor] entonces\n                menor = explorador\n            fin si\n            explorador = explorador + 1\n        fin mientras\n        si menor != contador entonces\n            temp = datos[contador]\n            datos[contador] = datos[menor]\n            datos[menor] = temp\n        fin si\n        contador = contador + 1\n    hasta que contador >= cantidad - 1\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_5",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion seleccion(A, num_elementos)\n    // Recorre todo el arreglo excepto el último elemento\n    para i desde 0 hasta num_elementos-2 hacer\n        indice_menor = i\n        // Busca el elemento más pequeño en la parte no ordenada\n        para j desde i+1 hasta num_elementos-1 hacer\n            si A[j] < A[indice_menor] entonces\n                indice_menor = j\n            fin si\n        fin para\n        // Intercambia si se encontró un menor\n        si indice_menor != i entonces\n            swap = A[i]\n            A[i] = A[indice_menor]\n            A[indice_menor] = swap\n        fin si\n    fin para\n    retornar A\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_6",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento ordenar_seleccion(secuencia, total)\n    x = 0\n    mientras x < total hacer\n        y = x\n        mientras y < total hacer\n            si secuencia[y] < secuencia[x] entonces\n                almacen = secuencia[x]\n                secuencia[x] = secuencia[y]\n                secuencia[y] = almacen\n            fin si\n            y = y + 1\n        fin mientras\n        x = x + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_7",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion selection_sort(coleccion, tam)\n    inicio = 0\n    repetir\n        posMin = inicio\n        actual = inicio + 1\n        repetir\n            si coleccion[actual] < coleccion[posMin] entonces\n                posMin = actual\n            fin si\n            actual = actual + 1\n        hasta que actual >= tam\n        buffer = coleccion[inicio]\n        coleccion[inicio] = coleccion[posMin]\n        coleccion[posMin] = buffer\n        inicio = inicio + 1\n    hasta que inicio >= tam - 1\n    retornar coleccion\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_8",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "algoritmo ordenamiento_por_seleccion(array, dimension)\n    para indice_actual desde 0 hasta dimension-2 hacer\n        posicion_minimo = indice_actual\n        para indice_comparacion desde indice_actual+1 hasta dimension-1 hacer\n            si array[indice_comparacion] < array[posicion_minimo] entonces\n                posicion_minimo = indice_comparacion\n            fin si\n        fin para\n        valor_temporal = array[indice_actual]\n        array[indice_actual] = array[posicion_minimo]\n        array[posicion_minimo] = valor_temporal\n    fin para\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_9",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "// Selection sort iterativo básico\nprocedimiento ordenarSeleccion(elementos, n)\n    c1 = 0\n    mientras c1 < n-1 hacer\n        min_pos = c1\n        c2 = c1 + 1\n        mientras c2 < n hacer\n            si elementos[c2] < elementos[min_pos] entonces\n                min_pos = c2\n            fin si\n            c2 = c2 + 1\n        fin mientras\n        t = elementos[c1]\n        elementos[c1] = elementos[min_pos]\n        elementos[min_pos] = t\n        c1 = c1 + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_10",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion selectionSortAscendente(numeros, tamanio)\n    para p desde 0 hasta tamanio-2 hacer\n        menor_indice = p\n        para q desde p+1 hasta tamanio-1 hacer\n            si numeros[q] < numeros[menor_indice] entonces\n                menor_indice = q\n            fin si\n        fin para\n        si p != menor_indice entonces\n            respaldo = numeros[p]\n            numeros[p] = numeros[menor_indice]\n            numeros[menor_indice] = respaldo\n        fin si\n    fin para\n    retornar numeros\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_11",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "algoritmo ordenacion_seleccion(valores, longitud)\n    // Ordenamiento por selección del mínimo\n    limite = longitud - 1\n    para ext desde 0 hasta limite-1 hacer\n        idx_min = ext\n        para int desde ext+1 hasta limite hacer\n            si valores[int] < valores[idx_min] entonces\n                idx_min = int\n            fin si\n        fin para\n        auxiliar = valores[ext]\n        valores[ext] = valores[idx_min]\n        valores[idx_min] = auxiliar\n    fin para\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_12",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento sort_by_selection(lista, size)\n    outer = 0\n    mientras outer < size - 1 hacer\n        smallest = outer\n        inner = outer + 1\n        mientras inner < size hacer\n            si lista[inner] < lista[smallest] entonces\n                smallest = inner\n            fin si\n            inner = inner + 1\n        fin mientras\n        hold = lista[outer]\n        lista[outer] = lista[smallest]\n        lista[smallest] = hold\n        outer = outer + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_13",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion ordenar_por_seleccion_minimo(arr, len)\n    para index desde 0 hasta len-2 hacer\n        min_index = index\n        para search desde index+1 hasta len-1 hacer\n            si arr[search] < arr[min_index] entonces\n                min_index = search\n            fin si\n        fin para\n        tmp = arr[index]\n        arr[index] = arr[min_index]\n        arr[min_index] = tmp\n    fin para\n    retornar arr\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_14",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "// Algoritmo de ordenamiento por selección\nalgoritmo seleccion_ordenar(data, num)\n    i = 0\n    repetir\n        min = i\n        j = i + 1\n        repetir\n            si data[j] < data[min] entonces\n                min = j\n            fin si\n            j = j + 1\n        hasta que j >= num\n        si i != min entonces\n            backup = data[i]\n            data[i] = data[min]\n            data[min] = backup\n        fin si\n        i = i + 1\n    hasta que i >= num - 1\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_15",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento selection_ordenamiento(conjunto, total_elementos)\n    para primera_pos desde 0 hasta total_elementos-2 hacer\n        pos_menor_valor = primera_pos\n        para segunda_pos desde primera_pos+1 hasta total_elementos-1 hacer\n            si conjunto[segunda_pos] < conjunto[pos_menor_valor] entonces\n                pos_menor_valor = segunda_pos\n            fin si\n        fin para\n        variable_temp = conjunto[primera_pos]\n        conjunto[primera_pos] = conjunto[pos_menor_valor]\n        conjunto[pos_menor_valor] = variable_temp\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_1",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenamientoInsercion(arreglo, n)\n    para i desde 1 hasta n-1 hacer\n        clave = arreglo[i]\n        j = i - 1\n        mientras j >= 0 y arreglo[j] > clave hacer\n            arreglo[j + 1] = arreglo[j]\n            j = j - 1\n        fin mientras\n        arreglo[j + 1] = clave\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_2",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insertSort(lista, tamaño)\n    // Ordenamiento por inserción básico\n    para indice desde 1 hasta tamaño-1 hacer\n        elementoActual = lista[indice]\n        posicion = indice - 1\n        mientras posicion >= 0 y lista[posicion] > elementoActual hacer\n            lista[posicion + 1] = lista[posicion]\n            posicion = posicion - 1\n        fin mientras\n        lista[posicion + 1] = elementoActual\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_3",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenarPorInsercion(datos)\n    longitud = obtenerLongitud(datos)\n    para k desde 1 hasta longitud-1 hacer\n        temporal = datos[k]\n        m = k - 1\n        mientras m >= 0 hacer\n            si datos[m] > temporal entonces\n                datos[m + 1] = datos[m]\n                m = m - 1\n            sino\n                romper\n            fin si\n        fin mientras\n        datos[m + 1] = temporal\n    fin para\n    retornar datos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_4",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insertionSort(A, cantidad)\n    para idx desde 1 hasta cantidad-1 hacer\n        valorInsertar = A[idx]\n        posicionInsercion = idx\n        mientras posicionInsercion > 0 y A[posicionInsercion - 1] > valorInsertar hacer\n            A[posicionInsercion] = A[posicionInsercion - 1]\n            posicionInsercion = posicionInsercion - 1\n        fin mientras\n        A[posicionInsercion] = valorInsertar\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_5",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenar(vector, tam)\n    // Recorre desde el segundo elemento\n    para contador desde 1 hasta tam-1 hacer\n        aux = vector[contador]\n        indiceAnterior = contador - 1\n        // Desplaza elementos mayores hacia la derecha\n        mientras indiceAnterior >= 0 y vector[indiceAnterior] > aux hacer\n            vector[indiceAnterior + 1] = vector[indiceAnterior]\n            indiceAnterior = indiceAnterior - 1\n        fin mientras\n        // Inserta el elemento en su posición correcta\n        vector[indiceAnterior + 1] = aux\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_6",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insercionDirecta(secuencia, numElementos)\n    para p desde 1 hasta numElementos-1 hacer\n        guardado = secuencia[p]\n        q = p - 1\n        mientras q >= 0 hacer\n            si secuencia[q] <= guardado entonces\n                romper\n            fin si\n            secuencia[q + 1] = secuencia[q]\n            q = q - 1\n        fin mientras\n        secuencia[q + 1] = guardado\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_7",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion insertionSortAlgoritmo(array)\n    limite = longitud(array)\n    para i desde 1 hasta limite-1 hacer\n        elemento = array[i]\n        j = i - 1\n        encontrado = falso\n        mientras j >= 0 y no encontrado hacer\n            si array[j] > elemento entonces\n                array[j + 1] = array[j]\n                j = j - 1\n            sino\n                encontrado = verdadero\n            fin si\n        fin mientras\n        array[j + 1] = elemento\n    fin para\n    retornar array\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_8",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento ordenamientoInsertar(coleccion, total)\n    para x desde 1 hasta total-1 hacer\n        itemActual = coleccion[x]\n        y = x - 1\n        mientras y >= 0 y coleccion[y] > itemActual hacer\n            coleccion[y + 1] = coleccion[y]\n            y = y - 1\n        fin mientras\n        coleccion[y + 1] = itemActual\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_9",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion insertar(arr, len)\n    para index desde 1 hasta len-1 hacer\n        key = arr[index]\n        prevIndex = index - 1\n        mientras prevIndex >= 0 hacer\n            si arr[prevIndex] <= key entonces\n                salir\n            fin si\n            arr[prevIndex + 1] = arr[prevIndex]\n            prevIndex = prevIndex - 1\n        fin mientras\n        arr[prevIndex + 1] = key\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_10",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento sortInsercion(numeros, cantidadNumeros)\n    // Algoritmo de ordenamiento por inserción\n    para posActual desde 1 hasta cantidadNumeros-1 hacer\n        valorActual = numeros[posActual]\n        posComparacion = posActual - 1\n        // Buscar posición correcta\n        mientras posComparacion >= 0 y numeros[posComparacion] > valorActual hacer\n            numeros[posComparacion + 1] = numeros[posComparacion]\n            posComparacion = posComparacion - 1\n        fin mientras\n        numeros[posComparacion + 1] = valorActual\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_11",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenacionInsercion(elementos, n)\n    para indiceExterno desde 1 hasta n-1 hacer\n        temp = elementos[indiceExterno]\n        indiceInterno = indiceExterno - 1\n        mientras indiceInterno >= 0 y elementos[indiceInterno] > temp hacer\n            elementos[indiceInterno + 1] = elementos[indiceInterno]\n            indiceInterno = indiceInterno - 1\n        fin mientras\n        elementos[indiceInterno + 1] = temp\n    fin para\n    retornar elementos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_12",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insertarOrdenado(lista, tamanio)\n    para cont desde 1 hasta tamanio-1 hacer\n        valorTemporal = lista[cont]\n        posAnterior = cont - 1\n        mientras posAnterior >= 0 hacer\n            si lista[posAnterior] > valorTemporal entonces\n                lista[posAnterior + 1] = lista[posAnterior]\n                posAnterior = posAnterior - 1\n            sino\n                romper ciclo\n            fin si\n        fin mientras\n        lista[posAnterior + 1] = valorTemporal\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_13",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenarInsercion(vec, dimension)\n    para r desde 1 hasta dimension-1 hacer\n        elementoAInsertar = vec[r]\n        s = r - 1\n        mientras s >= 0 y vec[s] > elementoAInsertar hacer\n            vec[s + 1] = vec[s]\n            s = s - 1\n        fin mientras\n        vec[s + 1] = elementoAInsertar\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_14",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insercionSort(datos, numDatos)\n    // Ordenar usando inserción\n    para pos desde 1 hasta numDatos-1 hacer\n        valorGuardado = datos[pos]\n        posIzq = pos - 1\n        // Mover elementos mayores\n        mientras posIzq >= 0 y datos[posIzq] > valorGuardado hacer\n            datos[posIzq + 1] = datos[posIzq]\n            posIzq = posIzq - 1\n        fin mientras\n        // Colocar valor en posición correcta\n        datos[posIzq + 1] = valorGuardado\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_15",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion insertionOrdenamiento(arreglo, size)\n    para iterador desde 1 hasta size-1 hacer\n        actual = arreglo[iterador]\n        anterior = iterador - 1\n        mientras anterior >= 0 y arreglo[anterior] > actual hacer\n            arreglo[anterior + 1] = arreglo[anterior]\n            anterior = anterior - 1\n        fin mientras\n        arreglo[anterior + 1] = actual\n    fin para\n    retornar arreglo\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_1",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion ordenarMezcla(arreglo)\n    si longitud(arreglo) <= 1 entonces\n        retornar arreglo\n    fin si\n    \n    mitad = longitud(arreglo) / 2\n    izq = ordenarMezcla(arreglo[0...mitad])\n    der = ordenarMezcla(arreglo[mitad...fin])\n    \n    retornar mezclar(izq, der)\nfin funcion\n\nfuncion mezclar(izq, der)\n    resultado = []\n    i = 0, j = 0\n    \n    mientras i < longitud(izq) Y j < longitud(der) hacer\n        si izq[i] <= der[j] entonces\n            agregar izq[i] a resultado\n            i = i + 1\n        sino\n            agregar der[j] a resultado\n            j = j + 1\n        fin si\n    fin mientras\n    \n    agregar resto de izq a resultado\n    agregar resto de der a resultado\n    retornar resultado\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_2",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento mergeSort(A, inicio, fin)\n    si inicio < fin entonces\n        medio = (inicio + fin) / 2\n        mergeSort(A, inicio, medio)\n        mergeSort(A, medio + 1, fin)\n        combinar(A, inicio, medio, fin)\n    fin si\nfin procedimiento\n\nprocedimiento combinar(A, p, q, r)\n    n1 = q - p + 1\n    n2 = r - q\n    crear L[n1] y R[n2]\n    \n    para k = 0 hasta n1 - 1 hacer\n        L[k] = A[p + k]\n    fin para\n    \n    para k = 0 hasta n2 - 1 hacer\n        R[k] = A[q + 1 + k]\n    fin para\n    \n    i = 0, j = 0, k = p\n    \n    mientras i < n1 Y j < n2 hacer\n        si L[i] <= R[j] entonces\n            A[k] = L[i]\n            i = i + 1\n        sino\n            A[k] = R[j]\n            j = j + 1\n        fin si\n        k = k + 1\n    fin mientras\n    \n    mientras i < n1 hacer\n        A[k] = L[i]\n        i = i + 1\n        k = k + 1\n    fin mientras\n    \n    mientras j < n2 hacer\n        A[k] = R[j]\n        j = j + 1\n        k = k + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_3",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion ordenamiento_fusion(lista)\n    tam = longitud(lista)\n    si tam == 1 entonces\n        retornar lista\n    fin si\n    \n    punto_medio = tam dividido 2\n    sublista_a = lista[0 hasta punto_medio]\n    sublista_b = lista[punto_medio hasta tam]\n    \n    sublista_a = ordenamiento_fusion(sublista_a)\n    sublista_b = ordenamiento_fusion(sublista_b)\n    \n    retornar fusion(sublista_a, sublista_b)\nfin funcion\n\nfuncion fusion(a, b)\n    c = arreglo_vacio\n    indice_a = 0\n    indice_b = 0\n    \n    mientras indice_a < longitud(a) Y indice_b < longitud(b) hacer\n        si a[indice_a] < b[indice_b] entonces\n            insertar a[indice_a] en c\n            indice_a = indice_a + 1\n        sino\n            insertar b[indice_b] en c\n            indice_b = indice_b + 1\n        fin si\n    fin mientras\n    \n    mientras indice_a < longitud(a) hacer\n        insertar a[indice_a] en c\n        indice_a = indice_a + 1\n    fin mientras\n    \n    mientras indice_b < longitud(b) hacer\n        insertar b[indice_b] en c\n        indice_b = indice_b + 1\n    fin mientras\n    \n    retornar c\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_4",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento MS(datos, primero, ultimo)\n    si primero >= ultimo entonces\n        retornar\n    fin si\n    \n    centro = (primero + ultimo) div 2\n    MS(datos, primero, centro)\n    MS(datos, centro + 1, ultimo)\n    unir(datos, primero, centro, ultimo)\nfin procedimiento\n\nprocedimiento unir(datos, ini, cen, fin)\n    temporal = nuevo_arreglo[fin - ini + 1]\n    pos1 = ini\n    pos2 = cen + 1\n    pos_temp = 0\n    \n    mientras pos1 <= cen Y pos2 <= fin hacer\n        si datos[pos1] < datos[pos2] entonces\n            temporal[pos_temp] = datos[pos1]\n            pos1 = pos1 + 1\n        sino\n            temporal[pos_temp] = datos[pos2]\n            pos2 = pos2 + 1\n        fin si\n        pos_temp = pos_temp + 1\n    fin mientras\n    \n    mientras pos1 <= cen hacer\n        temporal[pos_temp] = datos[pos1]\n        pos1 = pos1 + 1\n        pos_temp = pos_temp + 1\n    fin mientras\n    \n    mientras pos2 <= fin hacer\n        temporal[pos_temp] = datos[pos2]\n        pos2 = pos2 + 1\n        pos_temp = pos_temp + 1\n    fin mientras\n    \n    para idx = 0 hasta longitud(temporal) - 1 hacer\n        datos[ini + idx] = temporal[idx]\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_5",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion merge_sort_recursivo(vector)\n    n = tamaño(vector)\n    \n    si n <= 1 entonces\n        retornar vector\n    fin si\n    \n    mitad = n / 2\n    parte_izquierda = vector[0 : mitad]\n    parte_derecha = vector[mitad : n]\n    \n    parte_izquierda = merge_sort_recursivo(parte_izquierda)\n    parte_derecha = merge_sort_recursivo(parte_derecha)\n    \n    retornar intercalar(parte_izquierda, parte_derecha)\nfin funcion\n\nfuncion intercalar(v1, v2)\n    resultado = []\n    idx1 = 0\n    idx2 = 0\n    \n    mientras idx1 < tamaño(v1) Y idx2 < tamaño(v2) hacer\n        si v1[idx1] <= v2[idx2] entonces\n            añadir v1[idx1] a resultado\n            idx1 = idx1 + 1\n        sino\n            añadir v2[idx2] a resultado\n            idx2 = idx2 + 1\n        fin si\n    fin mientras\n    \n    para k = idx1 hasta tamaño(v1) - 1 hacer\n        añadir v1[k] a resultado\n    fin para\n    \n    para k = idx2 hasta tamaño(v2) - 1 hacer\n        añadir v2[k] a resultado\n    fin para\n    \n    retornar resultado\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_6",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento ordenar_por_mezcla(arr, izquierda, derecha)\n    si izquierda < derecha entonces\n        medio = izquierda + (derecha - izquierda) / 2\n        ordenar_por_mezcla(arr, izquierda, medio)\n        ordenar_por_mezcla(arr, medio + 1, derecha)\n        mezclar_subarreglos(arr, izquierda, medio, derecha)\n    fin si\nfin procedimiento\n\nprocedimiento mezclar_subarreglos(arr, izq, med, der)\n    tam_izq = med - izq + 1\n    tam_der = der - med\n    \n    arreglo_izq = nuevo arreglo[tam_izq]\n    arreglo_der = nuevo arreglo[tam_der]\n    \n    para x = 0 hasta tam_izq - 1 hacer\n        arreglo_izq[x] = arr[izq + x]\n    fin para\n    \n    para y = 0 hasta tam_der - 1 hacer\n        arreglo_der[y] = arr[med + 1 + y]\n    fin para\n    \n    x = 0\n    y = 0\n    z = izq\n    \n    mientras x < tam_izq Y y < tam_der hacer\n        si arreglo_izq[x] <= arreglo_der[y] entonces\n            arr[z] = arreglo_izq[x]\n            x = x + 1\n        sino\n            arr[z] = arreglo_der[y]\n            y = y + 1\n        fin si\n        z = z + 1\n    fin mientras\n    \n    mientras x < tam_izq hacer\n        arr[z] = arreglo_izq[x]\n        x = x + 1\n        z = z + 1\n    fin mientras\n    \n    mientras y < tam_der hacer\n        arr[z] = arreglo_der[y]\n        y = y + 1\n        z = z + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_7",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion sort_merge(secuencia)\n    longitud_sec = contar_elementos(secuencia)\n    \n    si longitud_sec == 1 O longitud_sec == 0 entonces\n        retornar secuencia\n    fin si\n    \n    division = longitud_sec / 2\n    mitad_1 = secuencia desde 0 hasta division\n    mitad_2 = secuencia desde division hasta longitud_sec\n    \n    mitad_1_ordenada = sort_merge(mitad_1)\n    mitad_2_ordenada = sort_merge(mitad_2)\n    \n    retornar merge_secuencias(mitad_1_ordenada, mitad_2_ordenada)\nfin funcion\n\nfuncion merge_secuencias(sec1, sec2)\n    nueva_secuencia = secuencia_vacia\n    p1 = 0\n    p2 = 0\n    \n    mientras p1 < contar_elementos(sec1) Y p2 < contar_elementos(sec2) hacer\n        si sec1[p1] < sec2[p2] entonces\n            agregar sec1[p1] a nueva_secuencia\n            p1 = p1 + 1\n        de_lo_contrario\n            agregar sec2[p2] a nueva_secuencia\n            p2 = p2 + 1\n        fin si\n    fin mientras\n    \n    si p1 < contar_elementos(sec1) entonces\n        agregar sec1[p1...fin] a nueva_secuencia\n    fin si\n    \n    si p2 < contar_elementos(sec2) entonces\n        agregar sec2[p2...fin] a nueva_secuencia\n    fin si\n    \n    retornar nueva_secuencia\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_8",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento divide_y_conquista(coleccion, bajo, alto)\n    si bajo < alto entonces\n        punto_division = (bajo + alto) div 2\n        \n        divide_y_conquista(coleccion, bajo, punto_division)\n        divide_y_conquista(coleccion, punto_division + 1, alto)\n        \n        fusionar(coleccion, bajo, punto_division, alto)\n    fin si\nfin procedimiento\n\nprocedimiento fusionar(coleccion, inicio, mitad, final)\n    aux = arreglo_auxiliar[final - inicio + 1]\n    pos_izq = inicio\n    pos_der = mitad + 1\n    contador = 0\n    \n    mientras pos_izq <= mitad Y pos_der <= final hacer\n        si coleccion[pos_izq] <= coleccion[pos_der] entonces\n            aux[contador] = coleccion[pos_izq]\n            pos_izq = pos_izq + 1\n        de_otro_modo\n            aux[contador] = coleccion[pos_der]\n            pos_der = pos_der + 1\n        fin si\n        contador = contador + 1\n    fin mientras\n    \n    mientras pos_izq <= mitad hacer\n        aux[contador] = coleccion[pos_izq]\n        pos_izq = pos_izq + 1\n        contador = contador + 1\n    fin mientras\n    \n    mientras pos_der <= final hacer\n        aux[contador] = coleccion[pos_der]\n        pos_der = pos_der + 1\n        contador = contador + 1\n    fin mientras\n    \n    para i = 0 hasta contador - 1 hacer\n        coleccion[inicio + i] = aux[i]\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_9",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion ordenamiento_mezcla(elementos)\n    cantidad = longitud(elementos)\n    si cantidad <= 1 entonces retornar elementos\n    \n    centro = cantidad div 2\n    grupo_izquierdo = []\n    grupo_derecho = []\n    \n    para indice = 0 hasta centro - 1 hacer\n        grupo_izquierdo[indice] = elementos[indice]\n    fin para\n    \n    para indice = centro hasta cantidad - 1 hacer\n        grupo_derecho[indice - centro] = elementos[indice]\n    fin para\n    \n    grupo_izquierdo = ordenamiento_mezcla(grupo_izquierdo)\n    grupo_derecho = ordenamiento_mezcla(grupo_derecho)\n    \n    retornar combinar_grupos(grupo_izquierdo, grupo_derecho)\nfin funcion\n\nfuncion combinar_grupos(g1, g2)\n    combinado = []\n    i = 0, j = 0, k = 0\n    \n    mientras i < longitud(g1) Y j < longitud(g2) hacer\n        si g1[i] <= g2[j] entonces\n            combinado[k] = g1[i]\n            i = i + 1\n        sino\n            combinado[k] = g2[j]\n            j = j + 1\n        fin si\n        k = k + 1\n    fin mientras\n    \n    mientras i < longitud(g1) hacer\n        combinado[k] = g1[i]\n        i = i + 1\n        k = k + 1\n    fin mientras\n    \n    mientras j < longitud(g2) hacer\n        combinado[k] = g2[j]\n        j = j + 1\n        k = k + 1\n    fin mientras\n    \n    retornar combinado\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_1",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quicksort(arreglo, inicio, fin)\n    si inicio < fin entonces\n        pivote = particionar(arreglo, inicio, fin)\n        quicksort(arreglo, inicio, pivote - 1)\n        quicksort(arreglo, pivote + 1, fin)\n    fin si\nfin funcion\n\nfuncion particionar(arreglo, inicio, fin)\n    valorPivote = arreglo[fin]\n    i = inicio - 1\n    para j desde inicio hasta fin - 1 hacer\n        si arreglo[j] <= valorPivote entonces\n            i = i + 1\n            intercambiar(arreglo[i], arreglo[j])\n        fin si\n    fin para\n    intercambiar(arreglo[i + 1], arreglo[fin])\n    retornar i + 1\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_2",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento ordenarRapido(lista, izq, der)\n    si izq < der entonces\n        p = izq\n        q = der\n        elemento_central = lista[(izq + der) / 2]\n        \n        mientras p <= q hacer\n            mientras lista[p] < elemento_central hacer\n                p = p + 1\n            fin mientras\n            mientras lista[q] > elemento_central hacer\n                q = q - 1\n            fin mientras\n            si p <= q entonces\n                temp = lista[p]\n                lista[p] = lista[q]\n                lista[q] = temp\n                p = p + 1\n                q = q - 1\n            fin si\n        fin mientras\n        \n        ordenarRapido(lista, izq, q)\n        ordenarRapido(lista, p, der)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_3",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quick(A, bajo, alto)\n    si bajo < alto entonces\n        indice = dividir(A, bajo, alto)\n        quick(A, bajo, indice - 1)\n        quick(A, indice + 1, alto)\n    fin si\nfin funcion\n\nfuncion dividir(A, bajo, alto)\n    pivote = A[bajo]\n    i = bajo + 1\n    j = alto\n    \n    mientras verdadero hacer\n        mientras i <= j y A[i] <= pivote hacer\n            i = i + 1\n        fin mientras\n        mientras A[j] > pivote hacer\n            j = j - 1\n        fin mientras\n        si i < j entonces\n            swap(A[i], A[j])\n        sino\n            salir del ciclo\n        fin si\n    fin mientras\n    \n    swap(A[bajo], A[j])\n    retornar j\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_4",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento qSort(datos[], primero, ultimo)\n    // Ordenamiento rápido recursivo\n    centro = (primero + ultimo) / 2\n    pivot = datos[centro]\n    i = primero\n    j = ultimo\n    \n    mientras i <= j hacer\n        mientras datos[i] < pivot hacer\n            i = i + 1\n        fin mientras\n        mientras datos[j] > pivot hacer\n            j = j - 1\n        fin mientras\n        si i <= j entonces\n            aux = datos[i]\n            datos[i] = datos[j]\n            datos[j] = aux\n            i = i + 1\n            j = j - 1\n        fin si\n    fin mientras\n    \n    si primero < j entonces\n        qSort(datos, primero, j)\n    fin si\n    si i < ultimo entonces\n        qSort(datos, i, ultimo)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_5",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion ordenamientoQuick(vector, left, right)\n    si left >= right entonces\n        retornar\n    fin si\n    \n    pos = particion(vector, left, right)\n    ordenamientoQuick(vector, left, pos - 1)\n    ordenamientoQuick(vector, pos + 1, right)\nfin funcion\n\nfuncion particion(vector, left, right)\n    referencia = vector[right]\n    menor = left\n    \n    para mayor desde left hasta right - 1 hacer\n        si vector[mayor] < referencia entonces\n            temporal = vector[menor]\n            vector[menor] = vector[mayor]\n            vector[mayor] = temporal\n            menor = menor + 1\n        fin si\n    fin para\n    \n    temporal = vector[menor]\n    vector[menor] = vector[right]\n    vector[right] = temporal\n    \n    retornar menor\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_6",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento quickSort(arr, inicio, final)\n    si inicio < final entonces\n        medio = partir(arr, inicio, final)\n        quickSort(arr, inicio, medio - 1)\n        quickSort(arr, medio + 1, final)\n    fin si\nfin procedimiento\n\nprocedimiento partir(arr, inicio, final)\n    x = arr[final]\n    indice = inicio\n    \n    para k desde inicio hasta final - 1 hacer\n        si arr[k] <= x entonces\n            intercambiar arr[indice] con arr[k]\n            indice = indice + 1\n        fin si\n    fin para\n    \n    intercambiar arr[indice] con arr[final]\n    retornar indice\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_7",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion qs(secuencia, min, max)\n    // Implementación con pivote aleatorio\n    si min < max entonces\n        pos_pivote = min + aleatorio(max - min + 1)\n        intercambiar(secuencia[pos_pivote], secuencia[max])\n        \n        valor_p = secuencia[max]\n        idx = min\n        \n        para z desde min hasta max - 1 hacer\n            si secuencia[z] < valor_p entonces\n                intercambiar(secuencia[z], secuencia[idx])\n                idx = idx + 1\n            fin si\n        fin para\n        \n        intercambiar(secuencia[idx], secuencia[max])\n        qs(secuencia, min, idx - 1)\n        qs(secuencia, idx + 1, max)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_8",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento ordenar_quick(coleccion, a, b)\n    si a >= b entonces\n        retornar\n    fin si\n    \n    piv = coleccion[a]\n    izquierda = a + 1\n    derecha = b\n    \n    mientras izquierda <= derecha hacer\n        si coleccion[izquierda] <= piv entonces\n            izquierda = izquierda + 1\n        sino si coleccion[derecha] > piv entonces\n            derecha = derecha - 1\n        sino\n            temp = coleccion[izquierda]\n            coleccion[izquierda] = coleccion[derecha]\n            coleccion[derecha] = temp\n        fin si\n    fin mientras\n    \n    coleccion[a] = coleccion[derecha]\n    coleccion[derecha] = piv\n    \n    ordenar_quick(coleccion, a, derecha - 1)\n    ordenar_quick(coleccion, derecha + 1, b)\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_9",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quicksort_mejorado(array, low, high)\n    si low < high entonces\n        punto = separar(array, low, high)\n        quicksort_mejorado(array, low, punto)\n        quicksort_mejorado(array, punto + 1, high)\n    fin si\nfin funcion\n\nfuncion separar(array, low, high)\n    mitad = (low + high) / 2\n    elem_pivote = array[mitad]\n    i = low - 1\n    j = high + 1\n    \n    mientras verdadero hacer\n        repetir\n            i = i + 1\n        hasta que array[i] >= elem_pivote\n        \n        repetir\n            j = j - 1\n        hasta que array[j] <= elem_pivote\n        \n        si i >= j entonces\n            retornar j\n        fin si\n        \n        cambiar(array[i], array[j])\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_10",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento quick_sort(elementos, comienzo, termino)\n    c = comienzo\n    t = termino\n    central = elementos[(comienzo + termino) / 2]\n    \n    mientras c <= t hacer\n        mientras elementos[c] < central hacer\n            c = c + 1\n        fin mientras\n        mientras elementos[t] > central hacer\n            t = t - 1\n        fin mientras\n        si c <= t entonces\n            auxiliar = elementos[c]\n            elementos[c] = elementos[t]\n            elementos[t] = auxiliar\n            c = c + 1\n            t = t - 1\n        fin si\n    fin mientras\n    \n    si comienzo < t entonces\n        quick_sort(elementos, comienzo, t)\n    fin si\n    si c < termino entonces\n        quick_sort(elementos, c, termino)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_11",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion qsort(tabla, primero, ultimo)\n    si primero < ultimo entonces\n        pivote_final = organizar(tabla, primero, ultimo)\n        qsort(tabla, primero, pivote_final - 1)\n        qsort(tabla, pivote_final + 1, ultimo)\n    fin si\nfin funcion\n\nfuncion organizar(tabla, primero, ultimo)\n    valor_referencia = tabla[ultimo]\n    posicion_menor = primero - 1\n    \n    para posicion_actual desde primero hasta ultimo - 1 hacer\n        si tabla[posicion_actual] <= valor_referencia entonces\n            posicion_menor = posicion_menor + 1\n            tmp = tabla[posicion_menor]\n            tabla[posicion_menor] = tabla[posicion_actual]\n            tabla[posicion_actual] = tmp\n        fin si\n    fin para\n    \n    tmp = tabla[posicion_menor + 1]\n    tabla[posicion_menor + 1] = tabla[ultimo]\n    tabla[ultimo] = tmp\n    \n    retornar posicion_menor + 1\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_12",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento sort_quick(nums, start, end)\n    // Caso base\n    si start >= end entonces\n        retornar\n    fin si\n    \n    // Seleccionar pivote y particionar\n    pivot_index = start\n    pivot_value = nums[end]\n    \n    para scan desde start hasta end - 1 hacer\n        si nums[scan] < pivot_value entonces\n            swap(nums[scan], nums[pivot_index])\n            pivot_index = pivot_index + 1\n        fin si\n    fin para\n    \n    swap(nums[pivot_index], nums[end])\n    \n    // Llamadas recursivas\n    sort_quick(nums, start, pivot_index - 1)\n    sort_quick(nums, pivot_index + 1, end)\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_13",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quicksort_clasico(L, inferior, superior)\n    si inferior < superior entonces\n        separador = L[superior]\n        frontera = inferior\n        \n        para explorador desde inferior hasta superior - 1 hacer\n            si L[explorador] <= separador entonces\n                temporal = L[frontera]\n                L[frontera] = L[explorador]\n                L[explorador] = temporal\n                frontera = frontera + 1\n            fin si\n        fin para\n        \n        temporal = L[frontera]\n        L[frontera] = L[superior]\n        L[superior] = temporal\n        \n        quicksort_clasico(L, inferior, frontera - 1)\n        quicksort_clasico(L, frontera + 1, superior)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_14",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento ordenamiento_rapido(serie, ini, fin)\n    si ini < fin entonces\n        p_izq = ini\n        p_der = fin\n        medio = serie[(ini + fin) / 2]\n        \n        mientras p_izq <= p_der hacer\n            mientras serie[p_izq] < medio hacer\n                p_izq = p_izq + 1\n            fin mientras\n            \n            mientras serie[p_der] > medio hacer\n                p_der = p_der - 1\n            fin mientras\n            \n            si p_izq <= p_der entonces\n                temp = serie[p_izq]\n                serie[p_izq] = serie[p_der]\n                serie[p_der] = temp\n                p_izq = p_izq + 1\n                p_der = p_der - 1\n            fin si\n        fin mientras\n        \n        ordenamiento_rapido(serie, ini, p_der)\n        ordenamiento_rapido(serie, p_izq, fin)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_15",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quick_ordenar(valores, l, r)\n    si l >= r entonces\n        retornar\n    fin si\n    \n    indice_division = partition_values(valores, l, r)\n    quick_ordenar(valores, l, indice_division - 1)\n    quick_ordenar(valores, indice_division + 1, r)\nfin funcion\n\nfuncion partition_values(valores, l, r)\n    elemento_pivote = valores[r]\n    posicion = l\n    \n    para indice desde l hasta r - 1 hacer\n        si valores[indice] < elemento_pivote entonces\n            tmp = valores[posicion]\n            valores[posicion] = valores[indice]\n            valores[indice] = tmp\n            posicion = posicion + 1\n        fin si\n    fin para\n    \n    tmp = valores[posicion]\n    valores[posicion] = valores[r]\n    valores[r] = tmp\n    \n    retornar posicion\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_1",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion heapSort(arreglo, n)\n    para i desde n/2 - 1 hasta 0 decrementando\n        heapificar(arreglo, n, i)\n    fin para\n    \n    para i desde n-1 hasta 1 decrementando\n        intercambiar(arreglo[0], arreglo[i])\n        heapificar(arreglo, i, 0)\n    fin para\nfin funcion\n\nfuncion heapificar(arreglo, tamaño, raiz)\n    mayor = raiz\n    izq = 2 * raiz + 1\n    der = 2 * raiz + 2\n    \n    si izq < tamaño y arreglo[izq] > arreglo[mayor] entonces\n        mayor = izq\n    fin si\n    \n    si der < tamaño y arreglo[der] > arreglo[mayor] entonces\n        mayor = der\n    fin si\n    \n    si mayor != raiz entonces\n        intercambiar(arreglo[raiz], arreglo[mayor])\n        heapificar(arreglo, tamaño, mayor)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_2",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento ordenarPorMontículo(lista, longitud)\n    construirMonticulo(lista, longitud)\n    \n    mientras longitud > 1 hacer\n        temporal = lista[0]\n        lista[0] = lista[longitud - 1]\n        lista[longitud - 1] = temporal\n        longitud = longitud - 1\n        hundirElemento(lista, 0, longitud)\n    fin mientras\nfin procedimiento\n\nprocedimiento construirMonticulo(lista, longitud)\n    inicio = longitud / 2 - 1\n    mientras inicio >= 0 hacer\n        hundirElemento(lista, inicio, longitud)\n        inicio = inicio - 1\n    fin mientras\nfin procedimiento\n\nprocedimiento hundirElemento(lista, pos, limite)\n    hijoIzq = 2 * pos + 1\n    hijoDer = 2 * pos + 2\n    maximo = pos\n    \n    si hijoIzq < limite y lista[hijoIzq] > lista[maximo] entonces\n        maximo = hijoIzq\n    fin si\n    \n    si hijoDer < limite y lista[hijoDer] > lista[maximo] entonces\n        maximo = hijoDer\n    fin si\n    \n    si maximo != pos entonces\n        swap = lista[pos]\n        lista[pos] = lista[maximo]\n        lista[maximo] = swap\n        hundirElemento(lista, maximo, limite)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_3",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion ordenamientoHeap(datos[], cant)\n    para indice desde cant/2-1 hasta 0 paso -1\n        ajustarHeap(datos, cant, indice)\n    fin para\n    \n    para indice desde cant-1 hasta 1 paso -1\n        temp = datos[0]\n        datos[0] = datos[indice]\n        datos[indice] = temp\n        ajustarHeap(datos, indice, 0)\n    fin para\nfin funcion\n\nfuncion ajustarHeap(datos[], tam, nodo)\n    masGrande = nodo\n    hijo1 = 2*nodo + 1\n    hijo2 = 2*nodo + 2\n    \n    si hijo1 < tam entonces\n        si datos[hijo1] > datos[masGrande] entonces\n            masGrande = hijo1\n        fin si\n    fin si\n    \n    si hijo2 < tam entonces\n        si datos[hijo2] > datos[masGrande] entonces\n            masGrande = hijo2\n        fin si\n    fin si\n    \n    si masGrande != nodo entonces\n        aux = datos[nodo]\n        datos[nodo] = datos[masGrande]\n        datos[masGrande] = aux\n        ajustarHeap(datos, tam, masGrande)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_4",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento heapSort(A, size)\n    buildMaxHeap(A, size)\n    heapSize = size\n    \n    para j desde size hasta 2 paso -1\n        exchange(A[1], A[j])\n        heapSize = heapSize - 1\n        maxHeapify(A, 1, heapSize)\n    fin para\nfin procedimiento\n\nprocedimiento buildMaxHeap(A, size)\n    para k desde size/2 hasta 1 paso -1\n        maxHeapify(A, k, size)\n    fin para\nfin procedimiento\n\nprocedimiento maxHeapify(A, i, heapSize)\n    left = 2 * i\n    right = 2 * i + 1\n    largest = i\n    \n    si left <= heapSize y A[left] > A[largest] entonces\n        largest = left\n    fin si\n    \n    si right <= heapSize y A[right] > A[largest] entonces\n        largest = right\n    fin si\n    \n    si largest != i entonces\n        exchange(A[i], A[largest])\n        maxHeapify(A, largest, heapSize)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_5",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion sort_heap(vector, num_elementos)\n    crear_heap_maximo(vector, num_elementos)\n    \n    tope = num_elementos - 1\n    mientras tope > 0 hacer\n        permutar(vector[0], vector[tope])\n        tope = tope - 1\n        reajustar_heap(vector, 0, tope)\n    fin mientras\nfin funcion\n\nfuncion crear_heap_maximo(vector, num_elementos)\n    primer_padre = (num_elementos / 2) - 1\n    para p desde primer_padre hasta 0 decrementando\n        reajustar_heap(vector, p, num_elementos - 1)\n    fin para\nfin funcion\n\nfuncion reajustar_heap(vector, padre, ultimo)\n    hijo_izq = padre * 2 + 1\n    hijo_der = padre * 2 + 2\n    mayor_valor = padre\n    \n    si hijo_izq <= ultimo y vector[hijo_izq] > vector[mayor_valor] entonces\n        mayor_valor = hijo_izq\n    fin si\n    \n    si hijo_der <= ultimo y vector[hijo_der] > vector[mayor_valor] entonces\n        mayor_valor = hijo_der\n    fin si\n    \n    si mayor_valor != padre entonces\n        permutar(vector[padre], vector[mayor_valor])\n        reajustar_heap(vector, mayor_valor, ultimo)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_6",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento ordenar_monticulo(elementos[], total)\n    // Construir heap inicial\n    para pos desde total/2-1 hasta 0 paso -1\n        filtrar_abajo(elementos, pos, total)\n    fin para\n    \n    // Extraer elementos uno por uno\n    para pos desde total-1 hasta 1 paso -1\n        cambiar(elementos[0], elementos[pos])\n        filtrar_abajo(elementos, 0, pos)\n    fin para\nfin procedimiento\n\nprocedimiento filtrar_abajo(elementos[], raiz, limite)\n    nodo_actual = raiz\n    continuar = verdadero\n    \n    mientras 2*nodo_actual+1 < limite y continuar hacer\n        hijo_izq = 2*nodo_actual + 1\n        hijo_der = 2*nodo_actual + 2\n        hijo_mayor = hijo_izq\n        \n        si hijo_der < limite entonces\n            si elementos[hijo_der] > elementos[hijo_izq] entonces\n                hijo_mayor = hijo_der\n            fin si\n        fin si\n        \n        si elementos[hijo_mayor] > elementos[nodo_actual] entonces\n            cambiar(elementos[nodo_actual], elementos[hijo_mayor])\n            nodo_actual = hijo_mayor\n        sino\n            continuar = falso\n        fin si\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_7",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion heapsort(coleccion, dimension)\n    formar_heap(coleccion, dimension)\n    \n    para idx desde dimension-1 hasta 1 paso -1\n        t = coleccion[0]\n        coleccion[0] = coleccion[idx]\n        coleccion[idx] = t\n        mantener_propiedad_heap(coleccion, 0, idx)\n    fin para\n    \n    retornar coleccion\nfin funcion\n\nfuncion formar_heap(coleccion, dimension)\n    inicio = dimension / 2 - 1\n    para idx desde inicio hasta 0 paso -1\n        mantener_propiedad_heap(coleccion, idx, dimension)\n    fin para\nfin funcion\n\nfuncion mantener_propiedad_heap(coleccion, raiz, tope)\n    maximo = raiz\n    izquierdo = 2 * raiz + 1\n    derecho = 2 * raiz + 2\n    \n    si izquierdo < tope entonces\n        si coleccion[izquierdo] > coleccion[maximo] entonces\n            maximo = izquierdo\n        fin si\n    fin si\n    \n    si derecho < tope entonces\n        si coleccion[derecho] > coleccion[maximo] entonces\n            maximo = derecho\n        fin si\n    fin si\n    \n    si maximo != raiz entonces\n        t = coleccion[raiz]\n        coleccion[raiz] = coleccion[maximo]\n        coleccion[maximo] = t\n        mantener_propiedad_heap(coleccion, maximo, tope)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_8",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento heap_sort(arr, n)\n    construir_max_heap(arr, n)\n    longitud_heap = n\n    \n    para i desde n-1 hasta 1 paso -1\n        intercambiar_valores(arr, 0, i)\n        longitud_heap = longitud_heap - 1\n        max_heapify(arr, 0, longitud_heap)\n    fin para\nfin procedimiento\n\nprocedimiento construir_max_heap(arr, n)\n    mitad = n / 2\n    para i desde mitad hasta 0 paso -1\n        max_heapify(arr, i, n)\n    fin para\nfin procedimiento\n\nprocedimiento max_heapify(arr, indice, tam_heap)\n    izq = indice * 2 + 1\n    der = indice * 2 + 2\n    mas_grande = indice\n    \n    si izq < tam_heap y arr[izq] > arr[mas_grande] entonces\n        mas_grande = izq\n    fin si\n    \n    si der < tam_heap y arr[der] > arr[mas_grande] entonces\n        mas_grande = der\n    fin si\n    \n    si mas_grande != indice entonces\n        intercambiar_valores(arr, indice, mas_grande)\n        max_heapify(arr, mas_grande, tam_heap)\n    fin si\nfin procedimiento\n\nprocedimiento intercambiar_valores(arr, pos1, pos2)\n    temporal = arr[pos1]\n    arr[pos1] = arr[pos2]\n    arr[pos2] = temporal\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_9",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion ordenamiento_por_heap(secuencia, len)\n    preparar_estructura_heap(secuencia, len)\n    \n    contador = len - 1\n    mientras contador >= 1 hacer\n        mover_elemento(secuencia, 0, contador)\n        contador = contador - 1\n        reorganizar_desde_raiz(secuencia, 0, contador)\n    fin mientras\nfin funcion\n\nfuncion preparar_estructura_heap(secuencia, len)\n    posicion_inicial = len / 2 - 1\n    mientras posicion_inicial >= 0 hacer\n        reorganizar_desde_raiz(secuencia, posicion_inicial, len - 1)\n        posicion_inicial = posicion_inicial - 1\n    fin mientras\nfin funcion\n\nfuncion reorganizar_desde_raiz(secuencia, nodo, final)\n    descendiente_izq = nodo * 2 + 1\n    descendiente_der = nodo * 2 + 2\n    posicion_mayor = nodo\n    \n    si descendiente_izq <= final entonces\n        si secuencia[descendiente_izq] > secuencia[posicion_mayor] entonces\n            posicion_mayor = descendiente_izq\n        fin si\n    fin si\n    \n    si descendiente_der <= final entonces\n        si secuencia[descendiente_der] > secuencia[posicion_mayor] entonces\n            posicion_mayor = descendiente_der\n        fin si\n    fin si\n    \n    si posicion_mayor != nodo entonces\n        mover_elemento(secuencia, nodo, posicion_mayor)\n        reorganizar_desde_raiz(secuencia, posicion_mayor, final)\n    fin si\nfin funcion\n\nfuncion mover_elemento(secuencia, a, b)\n    valor_temp = secuencia[a]\n    secuencia[a] = secuencia[b]\n    secuencia[b] = valor_temp\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_10",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento ordenar_con_heap(nums, cantidad)\n    inicializar_heap(nums, cantidad)\n    \n    para indice_actual desde cantidad-1 hasta 1 paso -1\n        realizar_swap(nums, 0, indice_actual)\n        balancear_heap(nums, 0, indice_actual)\n    fin para\nfin procedimiento\n\nprocedimiento inicializar_heap(nums, cantidad)\n    ultimo_padre = (cantidad / 2) - 1\n    \n    para p desde ultimo_padre hasta 0 paso -1\n        balancear_heap(nums, p, cantidad)\n    fin para\nfin procedimiento\n\nprocedimiento balancear_heap(nums, padre, limite)\n    rama_izq = padre * 2 + 1\n    rama_der = padre * 2 + 2\n    indice_max = padre\n    \n    si rama_izq < limite y nums[rama_izq] > nums[indice_max] entonces\n        indice_max = rama_izq\n    fin si\n    \n    si rama_der < limite y nums[rama_der] > nums[indice_max] entonces\n        indice_max = rama_der\n    fin si\n    \n    si indice_max != padre entonces\n        realizar_swap(nums, padre, indice_max)\n        balancear_heap(nums, indice_max, limite)\n    fin si\nfin procedimiento\n\nprocedimiento realizar_swap(nums, i, j)\n    aux = nums[i]\n    nums[i] = nums[j]\n    nums[j] = aux\nfin procedimiento",
    "label": "ordenamiento"
  }
]