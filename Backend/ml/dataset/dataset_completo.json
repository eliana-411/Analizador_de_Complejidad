[
  {
    "id": "busqueda_lineal_1",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion busquedaLineal(arreglo, valor)\n    para i desde 0 hasta longitud(arreglo) - 1\n        si arreglo[i] == valor entonces\n            retornar i\n        fin si\n    fin para\n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_2",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion buscarElemento(lista, objetivo)\n    indice = 0\n    mientras indice < tamaño(lista)\n        si lista[indice] == objetivo entonces\n            retornar indice\n        fin si\n        indice = indice + 1\n    fin mientras\n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_3",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "// Búsqueda lineal con contador de comparaciones\nfuncion buscar(datos, elemento_buscado)\n    comparaciones = 0\n    para posicion desde 0 hasta longitud(datos) - 1\n        comparaciones = comparaciones + 1\n        si datos[posicion] == elemento_buscado entonces\n            retornar posicion\n        fin si\n    fin para\n    retornar nulo\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_4",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion encontrarValor(vector, x)\n    n = longitud(vector)\n    para j desde 0 hasta n - 1\n        si vector[j] == x entonces\n            retornar verdadero\n        fin si\n    fin para\n    retornar falso\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_5",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion busquedaSecuencial(coleccion, item)\n    pos = 0\n    encontrado = falso\n    mientras pos < tamaño(coleccion) y no encontrado\n        si coleccion[pos] == item entonces\n            encontrado = verdadero\n        sino\n            pos = pos + 1\n        fin si\n    fin mientras\n    retornar encontrado\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_6",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "// Retorna la posición del elemento o mensaje de error\nfuncion localizarElemento(A, clave)\n    para k desde 0 hasta longitud(A) - 1\n        si A[k] == clave entonces\n            retornar k\n        fin si\n    fin para\n    retornar \"Elemento no encontrado\"\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_7",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion buscarEnArreglo(numeros, valorBuscado)\n    indiceActual = 0\n    longitudTotal = tamaño(numeros)\n    mientras indiceActual < longitudTotal\n        elementoActual = numeros[indiceActual]\n        si elementoActual == valorBuscado entonces\n            retornar indiceActual\n        fin si\n        indiceActual = indiceActual + 1\n    fin mientras\n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_8",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion busquedaSimple(arr, target)\n    para idx en rango(0, longitud(arr))\n        si arr[idx] == target entonces\n            retornar idx\n        fin si\n    fin para\n    retornar nulo\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_9",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "// Búsqueda que retorna todas las posiciones donde aparece el elemento\nfuncion buscarTodasOcurrencias(secuencia, elem)\n    posiciones = []\n    para i desde 0 hasta longitud(secuencia) - 1\n        si secuencia[i] == elem entonces\n            agregar(posiciones, i)\n        fin si\n    fin para\n    retornar posiciones\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_10",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion busquedaLinealMejorada(array, buscar)\n    limite = longitud(array)\n    contador = 0\n    mientras contador < limite\n        si array[contador] == buscar entonces\n            retornar contador\n        fin si\n        contador = contador + 1\n    fin mientras\n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_11",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion localizarDato(listaValores, datoObjetivo)\n    existe = falso\n    ubicacion = -1\n    para p desde 0 hasta tamaño(listaValores) - 1\n        si listaValores[p] == datoObjetivo entonces\n            existe = verdadero\n            ubicacion = p\n            romper\n        fin si\n    fin para\n    retornar ubicacion\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_12",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "// Búsqueda lineal con validación de entrada\nfuncion buscarElementoSeguro(contenedor, valorABuscar)\n    si contenedor == nulo o vacio(contenedor) entonces\n        retornar -1\n    fin si\n    para index desde 0 hasta longitud(contenedor) - 1\n        si contenedor[index] == valorABuscar entonces\n            retornar index\n        fin si\n    fin para\n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_13",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion busquedaEnLista(L, e)\n    i = 0\n    n = tamaño(L)\n    mientras i < n\n        si L[i] == e entonces\n            retornar verdadero\n        fin si\n        i = i + 1\n    fin mientras\n    retornar falso\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_14",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "funcion encontrarPosicion(matriz_unidimensional, numero)\n    para posicion_actual desde 0 hasta longitud(matriz_unidimensional) - 1\n        elemento = matriz_unidimensional[posicion_actual]\n        si elemento == numero entonces\n            retornar posicion_actual\n        fin si\n    fin para\n    retornar \"No existe\"\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_lineal_15",
    "categoria": "busqueda",
    "subcategoria": "lineal",
    "pseudocodigo": "// Búsqueda lineal que cuenta iteraciones realizadas\nfuncion buscarConEstadisticas(datos, objetivo)\n    iteraciones = 0\n    resultado = -1\n    para pos desde 0 hasta longitud(datos) - 1\n        iteraciones = iteraciones + 1\n        si datos[pos] == objetivo entonces\n            resultado = pos\n            romper\n        fin si\n    fin para\n    retornar [resultado, iteraciones]\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_1",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion busquedaBinaria(arreglo, objetivo)\n    inicio = 0\n    fin = longitud(arreglo) - 1\n    \n    mientras inicio <= fin hacer\n        medio = (inicio + fin) / 2\n        \n        si arreglo[medio] == objetivo entonces\n            retornar medio\n        sino si arreglo[medio] < objetivo entonces\n            inicio = medio + 1\n        sino\n            fin = medio - 1\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_2",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion buscar(lista, valor_buscado)\n    izq = 0\n    der = tamaño(lista) - 1\n    \n    mientras izq <= der hacer\n        centro = izq + (der - izq) / 2\n        \n        si lista[centro] == valor_buscado entonces\n            retornar centro\n        fin si\n        \n        si lista[centro] < valor_buscado entonces\n            izq = centro + 1\n        sino\n            der = centro - 1\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_3",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "// Búsqueda binaria recursiva\nfuncion busquedaRecursiva(arr, elemento, inferior, superior)\n    si inferior > superior entonces\n        retornar -1\n    fin si\n    \n    punto_medio = (inferior + superior) / 2\n    \n    si arr[punto_medio] == elemento entonces\n        retornar punto_medio\n    sino si arr[punto_medio] > elemento entonces\n        retornar busquedaRecursiva(arr, elemento, inferior, punto_medio - 1)\n    sino\n        retornar busquedaRecursiva(arr, elemento, punto_medio + 1, superior)\n    fin si\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_4",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion encontrarElemento(datos, x)\n    primero = 0\n    ultimo = longitud(datos) - 1\n    encontrado = falso\n    posicion = -1\n    \n    mientras primero <= ultimo y no encontrado hacer\n        mitad = entero((primero + ultimo) / 2)\n        \n        si datos[mitad] == x entonces\n            encontrado = verdadero\n            posicion = mitad\n        sino\n            si x < datos[mitad] entonces\n                ultimo = mitad - 1\n            sino\n                primero = mitad + 1\n            fin si\n        fin si\n    fin mientras\n    \n    retornar posicion\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_5",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion binarySearch(vector, target)\n    low = 0\n    high = vector.longitud - 1\n    \n    mientras low <= high hacer\n        mid = low + entero((high - low) / 2)\n        elemento_medio = vector[mid]\n        \n        si elemento_medio == target entonces\n            retornar mid\n        sino si elemento_medio < target entonces\n            low = mid + 1\n        sino\n            high = mid - 1\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_6",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "// Implementación iterativa simple\nfuncion buscar_binario(coleccion, clave)\n    min = 0\n    max = longitud(coleccion) - 1\n    \n    repetir mientras min <= max\n        indice_central = (min + max) dividido 2\n        valor_central = coleccion[indice_central]\n        \n        si valor_central == clave entonces\n            retornar indice_central\n        fin si\n        \n        si valor_central > clave entonces\n            max = indice_central - 1\n        sino\n            min = indice_central + 1\n        fin si\n    fin repetir\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_7",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion busquedaDicotomica(A, n, valorBuscado)\n    // A: arreglo ordenado\n    // n: número de elementos\n    // valorBuscado: elemento a buscar\n    \n    limiteInferior = 0\n    limiteSuperior = n - 1\n    \n    mientras limiteInferior <= limiteSuperior hacer\n        indiceMedio = limiteInferior + (limiteSuperior - limiteInferior) / 2\n        \n        si A[indiceMedio] == valorBuscado entonces\n            retornar indiceMedio\n        sino si A[indiceMedio] < valorBuscado entonces\n            limiteInferior = indiceMedio + 1\n        sino\n            limiteSuperior = indiceMedio - 1\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_8",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion busquedaBinariaRecursiva(secuencia, item, inicio, final)\n    si inicio > final entonces\n        retornar -1\n    sino\n        medio = (inicio + final) dividido_entero 2\n        \n        si secuencia[medio] == item entonces\n            retornar medio\n        sino si secuencia[medio] > item entonces\n            retornar busquedaBinariaRecursiva(secuencia, item, inicio, medio - 1)\n        sino\n            retornar busquedaBinariaRecursiva(secuencia, item, medio + 1, final)\n        fin si\n    fin si\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_9",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion buscarValor(tabla, val)\n    pos_inicial = 0\n    pos_final = dimension(tabla) - 1\n    resultado = -1\n    \n    mientras pos_inicial <= pos_final y resultado == -1 hacer\n        pos_media = (pos_inicial + pos_final) / 2\n        \n        si tabla[pos_media] == val entonces\n            resultado = pos_media\n        sino si tabla[pos_media] < val entonces\n            pos_inicial = pos_media + 1\n        sino\n            pos_final = pos_media - 1\n        fin si\n    fin mientras\n    \n    retornar resultado\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_10",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion busqueda_binaria_iterativa(array, elemento_buscar)\n    indice_bajo = 0\n    indice_alto = tamaño(array) - 1\n    \n    mientras indice_bajo <= indice_alto hacer\n        indice_medio = piso((indice_bajo + indice_alto) / 2)\n        valor_medio = array[indice_medio]\n        \n        si valor_medio == elemento_buscar entonces\n            retornar indice_medio\n        fin si\n        \n        si elemento_buscar < valor_medio entonces\n            indice_alto = indice_medio - 1\n        sino\n            indice_bajo = indice_medio + 1\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_11",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion buscarEnArreglo(arr, x, izquierda, derecha)\n    si izquierda > derecha entonces\n        retornar -1\n    fin si\n    \n    centro = izquierda + entero((derecha - izquierda) / 2)\n    \n    si arr[centro] == x entonces\n        retornar centro\n    fin si\n    \n    si arr[centro] > x entonces\n        retornar buscarEnArreglo(arr, x, izquierda, centro - 1)\n    fin si\n    \n    retornar buscarEnArreglo(arr, x, centro + 1, derecha)\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_12",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "// Búsqueda binaria con validación\nfuncion busquedaSegura(lista_ordenada, elemento_objetivo)\n    si lista_ordenada esta_vacia entonces\n        retornar -1\n    fin si\n    \n    p_izquierdo = 0\n    p_derecho = longitud(lista_ordenada) - 1\n    \n    mientras p_izquierdo <= p_derecho hacer\n        p_central = (p_izquierdo + p_derecho) dividido_entero 2\n        \n        si lista_ordenada[p_central] == elemento_objetivo entonces\n            retornar p_central\n        sino si lista_ordenada[p_central] < elemento_objetivo entonces\n            p_izquierdo = p_central + 1\n        sino\n            p_derecho = p_central - 1\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_13",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion binaria(vector_ordenado, num)\n    extremo_izq = 0\n    extremo_der = longitud(vector_ordenado) - 1\n    \n    mientras extremo_izq <= extremo_der hacer\n        punto_central = extremo_izq + (extremo_der - extremo_izq) / 2\n        \n        si vector_ordenado[punto_central] == num entonces\n            retornar punto_central\n        sino\n            si num > vector_ordenado[punto_central] entonces\n                extremo_izq = punto_central + 1\n            sino\n                extremo_der = punto_central - 1\n            fin si\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_14",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion busqueda_bin_rec(datos, objetivo, inf, sup)\n    // Caso base: no encontrado\n    si inf > sup entonces\n        retornar -1\n    fin si\n    \n    // Calcular posición central\n    med = (inf + sup) / 2\n    \n    // Verificar si encontramos el objetivo\n    si datos[med] == objetivo entonces\n        retornar med\n    sino si objetivo < datos[med] entonces\n        retornar busqueda_bin_rec(datos, objetivo, inf, med - 1)\n    sino\n        retornar busqueda_bin_rec(datos, objetivo, med + 1, sup)\n    fin si\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_binaria_15",
    "categoria": "busqueda",
    "subcategoria": "binaria",
    "pseudocodigo": "funcion encontrar(arreglo_ordenado, valor_a_buscar)\n    limite_inf = 0\n    limite_sup = tamaño(arreglo_ordenado) - 1\n    iteraciones = 0\n    \n    mientras limite_inf <= limite_sup hacer\n        iteraciones = iteraciones + 1\n        posicion_media = (limite_inf + limite_sup) dividido 2\n        elemento_actual = arreglo_ordenado[posicion_media]\n        \n        si elemento_actual == valor_a_buscar entonces\n            retornar posicion_media\n        sino si elemento_actual < valor_a_buscar entonces\n            limite_inf = posicion_media + 1\n        sino\n            limite_sup = posicion_media - 1\n        fin si\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_1",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion buscarEnTablaHash(tabla, clave)\n    indice = funcionHash(clave)\n    retornar tabla[indice]\nfin funcion\n\nfuncion funcionHash(clave)\n    retornar clave mod tamaño_tabla\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_2",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "// Búsqueda con manejo de colisiones por encadenamiento\nfuncion buscar(hashTable, key)\n    pos = calcularHash(key)\n    nodo = hashTable[pos]\n    mientras nodo no sea nulo hacer\n        si nodo.clave == key entonces\n            retornar nodo.valor\n        fin si\n        nodo = nodo.siguiente\n    fin mientras\n    retornar nulo\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_3",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion encontrarElemento(diccionario, k, tamano)\n    ubicacion = k mod tamano\n    si diccionario[ubicacion].llave == k entonces\n        retornar diccionario[ubicacion].dato\n    sino\n        retornar \"No encontrado\"\n    fin si\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_4",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion busquedaHash(arregloHash, claveABuscar, capacidad)\n    // Sondeo lineal para resolver colisiones\n    posicionInicial = hash(claveABuscar, capacidad)\n    i = 0\n    mientras i < capacidad hacer\n        posActual = (posicionInicial + i) mod capacidad\n        si arregloHash[posActual].key == claveABuscar entonces\n            retornar arregloHash[posActual].value\n        fin si\n        i = i + 1\n    fin mientras\n    retornar -1\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_5",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion obtenerValor(mapa, llaveBuscada)\n    indiceHash = generarIndice(llaveBuscada)\n    bucket = mapa[indiceHash]\n    para cada elemento en bucket hacer\n        si elemento.llave == llaveBuscada entonces\n            retornar elemento.valor\n        fin para\n    fin para\n    retornar nulo\nfin funcion\n\nfuncion generarIndice(llave)\n    retornar llave mod dimension_mapa\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_6",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion consultarHash(estructura, claveConsulta, N)\n    h = claveConsulta mod N\n    celda = estructura[h]\n    si celda esta vacia entonces\n        retornar falso\n    sino\n        si celda.clave == claveConsulta entonces\n            retornar celda.informacion\n        fin si\n    fin si\n    retornar falso\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_7",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "// Búsqueda con sondeo cuadrático\nfuncion buscarConSondeoCuadratico(tablaH, keyBuscada, size)\n    idx = keyBuscada mod size\n    intento = 0\n    mientras intento < size hacer\n        posicion = (idx + intento * intento) mod size\n        si tablaH[posicion] no esta ocupada entonces\n            retornar nulo\n        fin si\n        si tablaH[posicion].clave == keyBuscada entonces\n            retornar tablaH[posicion].contenido\n        fin si\n        intento = intento + 1\n    fin mientras\n    retornar nulo\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_8",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion recuperarDato(almacen, identificador)\n    codigo = calcularCodigo(identificador)\n    lista = almacen[codigo]\n    si lista == vacia entonces\n        retornar \"Elemento inexistente\"\n    fin si\n    actual = lista.cabeza\n    mientras actual != nulo hacer\n        si actual.id == identificador entonces\n            retornar actual.datos\n        fin si\n        actual = actual.proximo\n    fin mientras\n    retornar \"Elemento inexistente\"\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_9",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion localizarEnHash(conjunto, valorBuscado, longitud)\n    direccion = funcionDispersion(valorBuscado, longitud)\n    si conjunto[direccion] == valorBuscado entonces\n        retornar verdadero\n    sino\n        retornar falso\n    fin si\nfin funcion\n\nfuncion funcionDispersion(valor, long)\n    retornar (valor * 31) mod long\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_10",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion search(hashmap, searchKey, maxSize)\n    // Hash con doble dispersión\n    hash1 = searchKey mod maxSize\n    hash2 = 1 + (searchKey mod (maxSize - 1))\n    contador = 0\n    mientras contador < maxSize hacer\n        indice = (hash1 + contador * hash2) mod maxSize\n        si hashmap[indice].key == searchKey entonces\n            retornar hashmap[indice].data\n        fin si\n        si hashmap[indice] esta vacio entonces\n            retornar nulo\n        fin si\n        contador = contador + 1\n    fin mientras\n    retornar nulo\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_11",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion buscarRegistro(registros, claveID, tam)\n    posHash = claveID mod tam\n    entrada = registros[posHash]\n    para j desde 0 hasta entrada.cantidad hacer\n        si entrada.elementos[j].identificador == claveID entonces\n            retornar entrada.elementos[j]\n        fin si\n    fin para\n    retornar nulo\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_12",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion consultarTabla(T, x)\n    // Calcula posición hash\n    p = hash_function(x)\n    // Verifica si existe\n    si T[p] existe y T[p].clave == x entonces\n        retornar T[p].valor\n    sino\n        // Busca en posiciones alternativas\n        offset = 1\n        mientras offset <= tamaño_tabla hacer\n            nueva_pos = (p + offset) mod tamaño_tabla\n            si T[nueva_pos].clave == x entonces\n                retornar T[nueva_pos].valor\n            fin si\n            offset = offset + 1\n        fin mientras\n    fin si\n    retornar \"No existe\"\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_13",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion encontrar(coleccion, llaveObjetivo, capacidadTotal)\n    ranura = llaveObjetivo mod capacidadTotal\n    listaCubeta = coleccion[ranura]\n    nodoActual = listaCubeta.primero\n    mientras nodoActual no sea nulo hacer\n        si nodoActual.llave == llaveObjetivo entonces\n            retornar nodoActual.valorAsociado\n        fin si\n        nodoActual = nodoActual.siguiente\n    fin mientras\n    retornar nulo\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_14",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "funcion obtener(mapeoHash, claveDeseada)\n    indiceCalculado = metodoHash(claveDeseada)\n    secuencia = mapeoHash[indiceCalculado]\n    si secuencia es nula entonces\n        retornar falso\n    fin si\n    para i desde 0 hasta secuencia.longitud - 1 hacer\n        si secuencia[i].clave == claveDeseada entonces\n            retornar secuencia[i].valor\n        fin si\n    fin para\n    retornar falso\nfin funcion\n\nfuncion metodoHash(clave)\n    retornar clave mod tamaño_estructura\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "busqueda_hash_15",
    "categoria": "busqueda",
    "subcategoria": "hash",
    "pseudocodigo": "// Implementación con rehashing\nfuncion buscarConRehash(tabla, key, M)\n    intento = 0\n    encontrado = falso\n    mientras intento < M y no encontrado hacer\n        pos = hashFunction(key, intento, M)\n        si tabla[pos].activo y tabla[pos].clave == key entonces\n            encontrado = verdadero\n            retornar tabla[pos].valor\n        fin si\n        intento = intento + 1\n    fin mientras\n    retornar nulo\nfin funcion\n\nfuncion hashFunction(k, i, M)\n    retornar (k + i) mod M\nfin funcion",
    "label": "busqueda"
  },
  {
    "id": "ordenamiento_bubble_1",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion ordenarBurbuja(arreglo, n)\n    para i desde 0 hasta n-1\n        para j desde 0 hasta n-i-1\n            si arreglo[j] > arreglo[j+1] entonces\n                temp = arreglo[j]\n                arreglo[j] = arreglo[j+1]\n                arreglo[j+1] = temp\n            fin si\n        fin para\n    fin para\n    retornar arreglo\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_2",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Algoritmo de ordenamiento burbuja optimizado\nfuncion bubbleSort(lista, tamaño)\n    intercambio = verdadero\n    mientras intercambio == verdadero\n        intercambio = falso\n        para indice desde 1 hasta tamaño-1\n            si lista[indice-1] > lista[indice] entonces\n                aux = lista[indice-1]\n                lista[indice-1] = lista[indice]\n                lista[indice] = aux\n                intercambio = verdadero\n            fin si\n        fin para\n        tamaño = tamaño - 1\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_3",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion ordenamiento_burbuja(datos, longitud)\n    repetir = verdadero\n    pasada = 0\n    mientras repetir == verdadero\n        repetir = falso\n        para pos desde 0 hasta longitud-pasada-2\n            si datos[pos] > datos[pos+1] entonces\n                temporal = datos[pos]\n                datos[pos] = datos[pos+1]\n                datos[pos+1] = temporal\n                repetir = verdadero\n            fin si\n        fin para\n        pasada = pasada + 1\n    fin mientras\n    retornar datos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_4",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion burbuja(vec, tam)\n    para vuelta desde 1 hasta tam-1\n        para elemento desde 0 hasta tam-vuelta-1\n            si vec[elemento] > vec[elemento+1] entonces\n                intercambiar(vec[elemento], vec[elemento+1])\n            fin si\n        fin para\n    fin para\nfin funcion\n\nfuncion intercambiar(a, b)\n    temp = a\n    a = b\n    b = temp\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_5",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Versión simple de ordenamiento burbuja\nfuncion ordenar(A, N)\n    para i desde 0 hasta N-2\n        para j desde 0 hasta N-2\n            si A[j] > A[j+1] entonces\n                guardar = A[j]\n                A[j] = A[j+1]\n                A[j+1] = guardar\n            fin si\n        fin para\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_6",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion metodo_burbuja(coleccion, cantidad)\n    limite = cantidad\n    mientras limite > 1\n        nuevo_limite = 0\n        para k desde 1 hasta limite-1\n            si coleccion[k-1] > coleccion[k] entonces\n                swap = coleccion[k-1]\n                coleccion[k-1] = coleccion[k]\n                coleccion[k] = swap\n                nuevo_limite = k\n            fin si\n        fin para\n        limite = nuevo_limite\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_7",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion bubble_ordenar(array, size)\n    ordenado = falso\n    mientras ordenado == falso\n        ordenado = verdadero\n        para idx desde 0 hasta size-2\n            si array[idx] > array[idx+1] entonces\n                temp_val = array[idx]\n                array[idx] = array[idx+1]\n                array[idx+1] = temp_val\n                ordenado = falso\n            fin si\n        fin para\n    fin mientras\n    retornar array\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_8",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Implementación con contador de pasadas\nfuncion ordenar_por_burbuja(secuencia, len)\n    contador = 0\n    para pasada desde 0 hasta len-1\n        para posicion desde 0 hasta len-pasada-2\n            si secuencia[posicion] > secuencia[posicion+1] entonces\n                buffer = secuencia[posicion]\n                secuencia[posicion] = secuencia[posicion+1]\n                secuencia[posicion+1] = buffer\n                contador = contador + 1\n            fin si\n        fin para\n    fin para\n    retornar contador\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_9",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion burbuja_mejorada(valores, total)\n    para ronda desde total hasta 2\n        cambios = 0\n        para p desde 1 hasta ronda-1\n            si valores[p-1] > valores[p] entonces\n                t = valores[p-1]\n                valores[p-1] = valores[p]\n                valores[p] = t\n                cambios = cambios + 1\n            fin si\n        fin para\n        si cambios == 0 entonces\n            romper\n        fin si\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_10",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion sort_bubble(elementos, num_elementos)\n    para externo desde num_elementos-1 hasta 1\n        para interno desde 0 hasta externo-1\n            si elementos[interno] > elementos[interno+1] entonces\n                auxiliar = elementos[interno]\n                elementos[interno] = elementos[interno+1]\n                elementos[interno+1] = auxiliar\n            fin si\n        fin para\n    fin para\n    retornar elementos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_11",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Burbuja bidireccional (cocktail sort)\nfuncion burbuja_bidireccional(arr, n)\n    inicio = 0\n    final = n - 1\n    mientras inicio < final\n        para i desde inicio hasta final-1\n            si arr[i] > arr[i+1] entonces\n                tmp = arr[i]\n                arr[i] = arr[i+1]\n                arr[i+1] = tmp\n            fin si\n        fin para\n        final = final - 1\n        para i desde final hasta inicio+1\n            si arr[i-1] > arr[i] entonces\n                tmp = arr[i-1]\n                arr[i-1] = arr[i]\n                arr[i] = tmp\n            fin si\n        fin para\n        inicio = inicio + 1\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_12",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion ordenamiento_ascendente(lista, longitud_lista)\n    hubo_cambio = 1\n    iteracion = 0\n    mientras hubo_cambio == 1\n        hubo_cambio = 0\n        para indice_actual desde 0 hasta longitud_lista-iteracion-2\n            si lista[indice_actual] > lista[indice_actual+1] entonces\n                variable_temporal = lista[indice_actual]\n                lista[indice_actual] = lista[indice_actual+1]\n                lista[indice_actual+1] = variable_temporal\n                hubo_cambio = 1\n            fin si\n        fin para\n        iteracion = iteracion + 1\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_13",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion bubble(vector, dimension)\n    para ciclo_externo desde 0 hasta dimension-2\n        minimo_encontrado = verdadero\n        para ciclo_interno desde 0 hasta dimension-ciclo_externo-2\n            si vector[ciclo_interno] > vector[ciclo_interno+1] entonces\n                respaldo = vector[ciclo_interno]\n                vector[ciclo_interno] = vector[ciclo_interno+1]\n                vector[ciclo_interno+1] = respaldo\n                minimo_encontrado = falso\n            fin si\n        fin para\n        si minimo_encontrado == verdadero entonces\n            retornar vector\n        fin si\n    fin para\n    retornar vector\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_14",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "// Ordenamiento burbuja con verificación de orden\nfuncion ordenar_elementos(conjunto, tam_conjunto)\n    para vuelta_externa desde 1 hasta tam_conjunto-1\n        esta_ordenado = verdadero\n        para comparacion desde 0 hasta tam_conjunto-vuelta_externa-1\n            primero = conjunto[comparacion]\n            segundo = conjunto[comparacion+1]\n            si primero > segundo entonces\n                conjunto[comparacion] = segundo\n                conjunto[comparacion+1] = primero\n                esta_ordenado = falso\n            fin si\n        fin para\n        si esta_ordenado entonces\n            salir\n        fin si\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_bubble_15",
    "categoria": "ordenamiento",
    "subcategoria": "bubble",
    "pseudocodigo": "funcion algoritmo_burbuja(datos, numero_datos)\n    tope = numero_datos\n    mientras tope > 0\n        ultima_pos = 0\n        para pos_actual desde 1 hasta tope-1\n            si datos[pos_actual-1] > datos[pos_actual] entonces\n                valor_temp = datos[pos_actual-1]\n                datos[pos_actual-1] = datos[pos_actual]\n                datos[pos_actual] = valor_temp\n                ultima_pos = pos_actual\n            fin si\n        fin para\n        tope = ultima_pos\n    fin mientras\n    retornar datos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_1",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion ordenamientoSeleccion(arreglo, n)\n    para i desde 0 hasta n-2 hacer\n        minimo = i\n        para j desde i+1 hasta n-1 hacer\n            si arreglo[j] < arreglo[minimo] entonces\n                minimo = j\n            fin si\n        fin para\n        temporal = arreglo[i]\n        arreglo[i] = arreglo[minimo]\n        arreglo[minimo] = temporal\n    fin para\n    retornar arreglo\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_2",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento selectionSort(lista, tamaño)\n    indice = 0\n    mientras indice < tamaño - 1 hacer\n        posicionMinima = indice\n        k = indice + 1\n        mientras k < tamaño hacer\n            si lista[k] < lista[posicionMinima] entonces\n                posicionMinima = k\n            fin si\n            k = k + 1\n        fin mientras\n        aux = lista[indice]\n        lista[indice] = lista[posicionMinima]\n        lista[posicionMinima] = aux\n        indice = indice + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_3",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "// Ordenamiento por selección con búsqueda de máximo\nfuncion ordenarPorSeleccion(vector, longitud)\n    para pos desde longitud-1 hasta 1 decrementando hacer\n        indiceMayor = 0\n        para buscar desde 1 hasta pos hacer\n            si vector[buscar] > vector[indiceMayor] entonces\n                indiceMayor = buscar\n            fin si\n        fin para\n        intercambiar(vector[pos], vector[indiceMayor])\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_4",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "algoritmo ordenacionSeleccion(datos, cantidad)\n    contador = 0\n    repetir\n        menor = contador\n        explorador = contador + 1\n        mientras explorador <= cantidad - 1 hacer\n            si datos[explorador] < datos[menor] entonces\n                menor = explorador\n            fin si\n            explorador = explorador + 1\n        fin mientras\n        si menor != contador entonces\n            temp = datos[contador]\n            datos[contador] = datos[menor]\n            datos[menor] = temp\n        fin si\n        contador = contador + 1\n    hasta que contador >= cantidad - 1\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_5",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion seleccion(A, num_elementos)\n    // Recorre todo el arreglo excepto el último elemento\n    para i desde 0 hasta num_elementos-2 hacer\n        indice_menor = i\n        // Busca el elemento más pequeño en la parte no ordenada\n        para j desde i+1 hasta num_elementos-1 hacer\n            si A[j] < A[indice_menor] entonces\n                indice_menor = j\n            fin si\n        fin para\n        // Intercambia si se encontró un menor\n        si indice_menor != i entonces\n            swap = A[i]\n            A[i] = A[indice_menor]\n            A[indice_menor] = swap\n        fin si\n    fin para\n    retornar A\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_6",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento ordenar_seleccion(secuencia, total)\n    x = 0\n    mientras x < total hacer\n        y = x\n        mientras y < total hacer\n            si secuencia[y] < secuencia[x] entonces\n                almacen = secuencia[x]\n                secuencia[x] = secuencia[y]\n                secuencia[y] = almacen\n            fin si\n            y = y + 1\n        fin mientras\n        x = x + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_7",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion selection_sort(coleccion, tam)\n    inicio = 0\n    repetir\n        posMin = inicio\n        actual = inicio + 1\n        repetir\n            si coleccion[actual] < coleccion[posMin] entonces\n                posMin = actual\n            fin si\n            actual = actual + 1\n        hasta que actual >= tam\n        buffer = coleccion[inicio]\n        coleccion[inicio] = coleccion[posMin]\n        coleccion[posMin] = buffer\n        inicio = inicio + 1\n    hasta que inicio >= tam - 1\n    retornar coleccion\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_8",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "algoritmo ordenamiento_por_seleccion(array, dimension)\n    para indice_actual desde 0 hasta dimension-2 hacer\n        posicion_minimo = indice_actual\n        para indice_comparacion desde indice_actual+1 hasta dimension-1 hacer\n            si array[indice_comparacion] < array[posicion_minimo] entonces\n                posicion_minimo = indice_comparacion\n            fin si\n        fin para\n        valor_temporal = array[indice_actual]\n        array[indice_actual] = array[posicion_minimo]\n        array[posicion_minimo] = valor_temporal\n    fin para\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_9",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "// Selection sort iterativo básico\nprocedimiento ordenarSeleccion(elementos, n)\n    c1 = 0\n    mientras c1 < n-1 hacer\n        min_pos = c1\n        c2 = c1 + 1\n        mientras c2 < n hacer\n            si elementos[c2] < elementos[min_pos] entonces\n                min_pos = c2\n            fin si\n            c2 = c2 + 1\n        fin mientras\n        t = elementos[c1]\n        elementos[c1] = elementos[min_pos]\n        elementos[min_pos] = t\n        c1 = c1 + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_10",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion selectionSortAscendente(numeros, tamanio)\n    para p desde 0 hasta tamanio-2 hacer\n        menor_indice = p\n        para q desde p+1 hasta tamanio-1 hacer\n            si numeros[q] < numeros[menor_indice] entonces\n                menor_indice = q\n            fin si\n        fin para\n        si p != menor_indice entonces\n            respaldo = numeros[p]\n            numeros[p] = numeros[menor_indice]\n            numeros[menor_indice] = respaldo\n        fin si\n    fin para\n    retornar numeros\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_11",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "algoritmo ordenacion_seleccion(valores, longitud)\n    // Ordenamiento por selección del mínimo\n    limite = longitud - 1\n    para ext desde 0 hasta limite-1 hacer\n        idx_min = ext\n        para int desde ext+1 hasta limite hacer\n            si valores[int] < valores[idx_min] entonces\n                idx_min = int\n            fin si\n        fin para\n        auxiliar = valores[ext]\n        valores[ext] = valores[idx_min]\n        valores[idx_min] = auxiliar\n    fin para\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_12",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento sort_by_selection(lista, size)\n    outer = 0\n    mientras outer < size - 1 hacer\n        smallest = outer\n        inner = outer + 1\n        mientras inner < size hacer\n            si lista[inner] < lista[smallest] entonces\n                smallest = inner\n            fin si\n            inner = inner + 1\n        fin mientras\n        hold = lista[outer]\n        lista[outer] = lista[smallest]\n        lista[smallest] = hold\n        outer = outer + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_13",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "funcion ordenar_por_seleccion_minimo(arr, len)\n    para index desde 0 hasta len-2 hacer\n        min_index = index\n        para search desde index+1 hasta len-1 hacer\n            si arr[search] < arr[min_index] entonces\n                min_index = search\n            fin si\n        fin para\n        tmp = arr[index]\n        arr[index] = arr[min_index]\n        arr[min_index] = tmp\n    fin para\n    retornar arr\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_14",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "// Algoritmo de ordenamiento por selección\nalgoritmo seleccion_ordenar(data, num)\n    i = 0\n    repetir\n        min = i\n        j = i + 1\n        repetir\n            si data[j] < data[min] entonces\n                min = j\n            fin si\n            j = j + 1\n        hasta que j >= num\n        si i != min entonces\n            backup = data[i]\n            data[i] = data[min]\n            data[min] = backup\n        fin si\n        i = i + 1\n    hasta que i >= num - 1\nfin algoritmo",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_selection_15",
    "categoria": "ordenamiento",
    "subcategoria": "selection",
    "pseudocodigo": "procedimiento selection_ordenamiento(conjunto, total_elementos)\n    para primera_pos desde 0 hasta total_elementos-2 hacer\n        pos_menor_valor = primera_pos\n        para segunda_pos desde primera_pos+1 hasta total_elementos-1 hacer\n            si conjunto[segunda_pos] < conjunto[pos_menor_valor] entonces\n                pos_menor_valor = segunda_pos\n            fin si\n        fin para\n        variable_temp = conjunto[primera_pos]\n        conjunto[primera_pos] = conjunto[pos_menor_valor]\n        conjunto[pos_menor_valor] = variable_temp\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_1",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenamientoInsercion(arreglo, n)\n    para i desde 1 hasta n-1 hacer\n        clave = arreglo[i]\n        j = i - 1\n        mientras j >= 0 y arreglo[j] > clave hacer\n            arreglo[j + 1] = arreglo[j]\n            j = j - 1\n        fin mientras\n        arreglo[j + 1] = clave\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_2",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insertSort(lista, tamaño)\n    // Ordenamiento por inserción básico\n    para indice desde 1 hasta tamaño-1 hacer\n        elementoActual = lista[indice]\n        posicion = indice - 1\n        mientras posicion >= 0 y lista[posicion] > elementoActual hacer\n            lista[posicion + 1] = lista[posicion]\n            posicion = posicion - 1\n        fin mientras\n        lista[posicion + 1] = elementoActual\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_3",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenarPorInsercion(datos)\n    longitud = obtenerLongitud(datos)\n    para k desde 1 hasta longitud-1 hacer\n        temporal = datos[k]\n        m = k - 1\n        mientras m >= 0 hacer\n            si datos[m] > temporal entonces\n                datos[m + 1] = datos[m]\n                m = m - 1\n            sino\n                romper\n            fin si\n        fin mientras\n        datos[m + 1] = temporal\n    fin para\n    retornar datos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_4",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insertionSort(A, cantidad)\n    para idx desde 1 hasta cantidad-1 hacer\n        valorInsertar = A[idx]\n        posicionInsercion = idx\n        mientras posicionInsercion > 0 y A[posicionInsercion - 1] > valorInsertar hacer\n            A[posicionInsercion] = A[posicionInsercion - 1]\n            posicionInsercion = posicionInsercion - 1\n        fin mientras\n        A[posicionInsercion] = valorInsertar\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_5",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenar(vector, tam)\n    // Recorre desde el segundo elemento\n    para contador desde 1 hasta tam-1 hacer\n        aux = vector[contador]\n        indiceAnterior = contador - 1\n        // Desplaza elementos mayores hacia la derecha\n        mientras indiceAnterior >= 0 y vector[indiceAnterior] > aux hacer\n            vector[indiceAnterior + 1] = vector[indiceAnterior]\n            indiceAnterior = indiceAnterior - 1\n        fin mientras\n        // Inserta el elemento en su posición correcta\n        vector[indiceAnterior + 1] = aux\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_6",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insercionDirecta(secuencia, numElementos)\n    para p desde 1 hasta numElementos-1 hacer\n        guardado = secuencia[p]\n        q = p - 1\n        mientras q >= 0 hacer\n            si secuencia[q] <= guardado entonces\n                romper\n            fin si\n            secuencia[q + 1] = secuencia[q]\n            q = q - 1\n        fin mientras\n        secuencia[q + 1] = guardado\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_7",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion insertionSortAlgoritmo(array)\n    limite = longitud(array)\n    para i desde 1 hasta limite-1 hacer\n        elemento = array[i]\n        j = i - 1\n        encontrado = falso\n        mientras j >= 0 y no encontrado hacer\n            si array[j] > elemento entonces\n                array[j + 1] = array[j]\n                j = j - 1\n            sino\n                encontrado = verdadero\n            fin si\n        fin mientras\n        array[j + 1] = elemento\n    fin para\n    retornar array\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_8",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento ordenamientoInsertar(coleccion, total)\n    para x desde 1 hasta total-1 hacer\n        itemActual = coleccion[x]\n        y = x - 1\n        mientras y >= 0 y coleccion[y] > itemActual hacer\n            coleccion[y + 1] = coleccion[y]\n            y = y - 1\n        fin mientras\n        coleccion[y + 1] = itemActual\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_9",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion insertar(arr, len)\n    para index desde 1 hasta len-1 hacer\n        key = arr[index]\n        prevIndex = index - 1\n        mientras prevIndex >= 0 hacer\n            si arr[prevIndex] <= key entonces\n                salir\n            fin si\n            arr[prevIndex + 1] = arr[prevIndex]\n            prevIndex = prevIndex - 1\n        fin mientras\n        arr[prevIndex + 1] = key\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_10",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento sortInsercion(numeros, cantidadNumeros)\n    // Algoritmo de ordenamiento por inserción\n    para posActual desde 1 hasta cantidadNumeros-1 hacer\n        valorActual = numeros[posActual]\n        posComparacion = posActual - 1\n        // Buscar posición correcta\n        mientras posComparacion >= 0 y numeros[posComparacion] > valorActual hacer\n            numeros[posComparacion + 1] = numeros[posComparacion]\n            posComparacion = posComparacion - 1\n        fin mientras\n        numeros[posComparacion + 1] = valorActual\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_11",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenacionInsercion(elementos, n)\n    para indiceExterno desde 1 hasta n-1 hacer\n        temp = elementos[indiceExterno]\n        indiceInterno = indiceExterno - 1\n        mientras indiceInterno >= 0 y elementos[indiceInterno] > temp hacer\n            elementos[indiceInterno + 1] = elementos[indiceInterno]\n            indiceInterno = indiceInterno - 1\n        fin mientras\n        elementos[indiceInterno + 1] = temp\n    fin para\n    retornar elementos\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_12",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insertarOrdenado(lista, tamanio)\n    para cont desde 1 hasta tamanio-1 hacer\n        valorTemporal = lista[cont]\n        posAnterior = cont - 1\n        mientras posAnterior >= 0 hacer\n            si lista[posAnterior] > valorTemporal entonces\n                lista[posAnterior + 1] = lista[posAnterior]\n                posAnterior = posAnterior - 1\n            sino\n                romper ciclo\n            fin si\n        fin mientras\n        lista[posAnterior + 1] = valorTemporal\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_13",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion ordenarInsercion(vec, dimension)\n    para r desde 1 hasta dimension-1 hacer\n        elementoAInsertar = vec[r]\n        s = r - 1\n        mientras s >= 0 y vec[s] > elementoAInsertar hacer\n            vec[s + 1] = vec[s]\n            s = s - 1\n        fin mientras\n        vec[s + 1] = elementoAInsertar\n    fin para\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_14",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "procedimiento insercionSort(datos, numDatos)\n    // Ordenar usando inserción\n    para pos desde 1 hasta numDatos-1 hacer\n        valorGuardado = datos[pos]\n        posIzq = pos - 1\n        // Mover elementos mayores\n        mientras posIzq >= 0 y datos[posIzq] > valorGuardado hacer\n            datos[posIzq + 1] = datos[posIzq]\n            posIzq = posIzq - 1\n        fin mientras\n        // Colocar valor en posición correcta\n        datos[posIzq + 1] = valorGuardado\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_insertion_15",
    "categoria": "ordenamiento",
    "subcategoria": "insertion",
    "pseudocodigo": "funcion insertionOrdenamiento(arreglo, size)\n    para iterador desde 1 hasta size-1 hacer\n        actual = arreglo[iterador]\n        anterior = iterador - 1\n        mientras anterior >= 0 y arreglo[anterior] > actual hacer\n            arreglo[anterior + 1] = arreglo[anterior]\n            anterior = anterior - 1\n        fin mientras\n        arreglo[anterior + 1] = actual\n    fin para\n    retornar arreglo\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_1",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion ordenarMezcla(arreglo)\n    si longitud(arreglo) <= 1 entonces\n        retornar arreglo\n    fin si\n    \n    mitad = longitud(arreglo) / 2\n    izq = ordenarMezcla(arreglo[0...mitad])\n    der = ordenarMezcla(arreglo[mitad...fin])\n    \n    retornar mezclar(izq, der)\nfin funcion\n\nfuncion mezclar(izq, der)\n    resultado = []\n    i = 0, j = 0\n    \n    mientras i < longitud(izq) Y j < longitud(der) hacer\n        si izq[i] <= der[j] entonces\n            agregar izq[i] a resultado\n            i = i + 1\n        sino\n            agregar der[j] a resultado\n            j = j + 1\n        fin si\n    fin mientras\n    \n    agregar resto de izq a resultado\n    agregar resto de der a resultado\n    retornar resultado\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_2",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento mergeSort(A, inicio, fin)\n    si inicio < fin entonces\n        medio = (inicio + fin) / 2\n        mergeSort(A, inicio, medio)\n        mergeSort(A, medio + 1, fin)\n        combinar(A, inicio, medio, fin)\n    fin si\nfin procedimiento\n\nprocedimiento combinar(A, p, q, r)\n    n1 = q - p + 1\n    n2 = r - q\n    crear L[n1] y R[n2]\n    \n    para k = 0 hasta n1 - 1 hacer\n        L[k] = A[p + k]\n    fin para\n    \n    para k = 0 hasta n2 - 1 hacer\n        R[k] = A[q + 1 + k]\n    fin para\n    \n    i = 0, j = 0, k = p\n    \n    mientras i < n1 Y j < n2 hacer\n        si L[i] <= R[j] entonces\n            A[k] = L[i]\n            i = i + 1\n        sino\n            A[k] = R[j]\n            j = j + 1\n        fin si\n        k = k + 1\n    fin mientras\n    \n    mientras i < n1 hacer\n        A[k] = L[i]\n        i = i + 1\n        k = k + 1\n    fin mientras\n    \n    mientras j < n2 hacer\n        A[k] = R[j]\n        j = j + 1\n        k = k + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_3",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion ordenamiento_fusion(lista)\n    tam = longitud(lista)\n    si tam == 1 entonces\n        retornar lista\n    fin si\n    \n    punto_medio = tam dividido 2\n    sublista_a = lista[0 hasta punto_medio]\n    sublista_b = lista[punto_medio hasta tam]\n    \n    sublista_a = ordenamiento_fusion(sublista_a)\n    sublista_b = ordenamiento_fusion(sublista_b)\n    \n    retornar fusion(sublista_a, sublista_b)\nfin funcion\n\nfuncion fusion(a, b)\n    c = arreglo_vacio\n    indice_a = 0\n    indice_b = 0\n    \n    mientras indice_a < longitud(a) Y indice_b < longitud(b) hacer\n        si a[indice_a] < b[indice_b] entonces\n            insertar a[indice_a] en c\n            indice_a = indice_a + 1\n        sino\n            insertar b[indice_b] en c\n            indice_b = indice_b + 1\n        fin si\n    fin mientras\n    \n    mientras indice_a < longitud(a) hacer\n        insertar a[indice_a] en c\n        indice_a = indice_a + 1\n    fin mientras\n    \n    mientras indice_b < longitud(b) hacer\n        insertar b[indice_b] en c\n        indice_b = indice_b + 1\n    fin mientras\n    \n    retornar c\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_4",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento MS(datos, primero, ultimo)\n    si primero >= ultimo entonces\n        retornar\n    fin si\n    \n    centro = (primero + ultimo) div 2\n    MS(datos, primero, centro)\n    MS(datos, centro + 1, ultimo)\n    unir(datos, primero, centro, ultimo)\nfin procedimiento\n\nprocedimiento unir(datos, ini, cen, fin)\n    temporal = nuevo_arreglo[fin - ini + 1]\n    pos1 = ini\n    pos2 = cen + 1\n    pos_temp = 0\n    \n    mientras pos1 <= cen Y pos2 <= fin hacer\n        si datos[pos1] < datos[pos2] entonces\n            temporal[pos_temp] = datos[pos1]\n            pos1 = pos1 + 1\n        sino\n            temporal[pos_temp] = datos[pos2]\n            pos2 = pos2 + 1\n        fin si\n        pos_temp = pos_temp + 1\n    fin mientras\n    \n    mientras pos1 <= cen hacer\n        temporal[pos_temp] = datos[pos1]\n        pos1 = pos1 + 1\n        pos_temp = pos_temp + 1\n    fin mientras\n    \n    mientras pos2 <= fin hacer\n        temporal[pos_temp] = datos[pos2]\n        pos2 = pos2 + 1\n        pos_temp = pos_temp + 1\n    fin mientras\n    \n    para idx = 0 hasta longitud(temporal) - 1 hacer\n        datos[ini + idx] = temporal[idx]\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_5",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion merge_sort_recursivo(vector)\n    n = tamaño(vector)\n    \n    si n <= 1 entonces\n        retornar vector\n    fin si\n    \n    mitad = n / 2\n    parte_izquierda = vector[0 : mitad]\n    parte_derecha = vector[mitad : n]\n    \n    parte_izquierda = merge_sort_recursivo(parte_izquierda)\n    parte_derecha = merge_sort_recursivo(parte_derecha)\n    \n    retornar intercalar(parte_izquierda, parte_derecha)\nfin funcion\n\nfuncion intercalar(v1, v2)\n    resultado = []\n    idx1 = 0\n    idx2 = 0\n    \n    mientras idx1 < tamaño(v1) Y idx2 < tamaño(v2) hacer\n        si v1[idx1] <= v2[idx2] entonces\n            añadir v1[idx1] a resultado\n            idx1 = idx1 + 1\n        sino\n            añadir v2[idx2] a resultado\n            idx2 = idx2 + 1\n        fin si\n    fin mientras\n    \n    para k = idx1 hasta tamaño(v1) - 1 hacer\n        añadir v1[k] a resultado\n    fin para\n    \n    para k = idx2 hasta tamaño(v2) - 1 hacer\n        añadir v2[k] a resultado\n    fin para\n    \n    retornar resultado\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_6",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento ordenar_por_mezcla(arr, izquierda, derecha)\n    si izquierda < derecha entonces\n        medio = izquierda + (derecha - izquierda) / 2\n        ordenar_por_mezcla(arr, izquierda, medio)\n        ordenar_por_mezcla(arr, medio + 1, derecha)\n        mezclar_subarreglos(arr, izquierda, medio, derecha)\n    fin si\nfin procedimiento\n\nprocedimiento mezclar_subarreglos(arr, izq, med, der)\n    tam_izq = med - izq + 1\n    tam_der = der - med\n    \n    arreglo_izq = nuevo arreglo[tam_izq]\n    arreglo_der = nuevo arreglo[tam_der]\n    \n    para x = 0 hasta tam_izq - 1 hacer\n        arreglo_izq[x] = arr[izq + x]\n    fin para\n    \n    para y = 0 hasta tam_der - 1 hacer\n        arreglo_der[y] = arr[med + 1 + y]\n    fin para\n    \n    x = 0\n    y = 0\n    z = izq\n    \n    mientras x < tam_izq Y y < tam_der hacer\n        si arreglo_izq[x] <= arreglo_der[y] entonces\n            arr[z] = arreglo_izq[x]\n            x = x + 1\n        sino\n            arr[z] = arreglo_der[y]\n            y = y + 1\n        fin si\n        z = z + 1\n    fin mientras\n    \n    mientras x < tam_izq hacer\n        arr[z] = arreglo_izq[x]\n        x = x + 1\n        z = z + 1\n    fin mientras\n    \n    mientras y < tam_der hacer\n        arr[z] = arreglo_der[y]\n        y = y + 1\n        z = z + 1\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_7",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion sort_merge(secuencia)\n    longitud_sec = contar_elementos(secuencia)\n    \n    si longitud_sec == 1 O longitud_sec == 0 entonces\n        retornar secuencia\n    fin si\n    \n    division = longitud_sec / 2\n    mitad_1 = secuencia desde 0 hasta division\n    mitad_2 = secuencia desde division hasta longitud_sec\n    \n    mitad_1_ordenada = sort_merge(mitad_1)\n    mitad_2_ordenada = sort_merge(mitad_2)\n    \n    retornar merge_secuencias(mitad_1_ordenada, mitad_2_ordenada)\nfin funcion\n\nfuncion merge_secuencias(sec1, sec2)\n    nueva_secuencia = secuencia_vacia\n    p1 = 0\n    p2 = 0\n    \n    mientras p1 < contar_elementos(sec1) Y p2 < contar_elementos(sec2) hacer\n        si sec1[p1] < sec2[p2] entonces\n            agregar sec1[p1] a nueva_secuencia\n            p1 = p1 + 1\n        de_lo_contrario\n            agregar sec2[p2] a nueva_secuencia\n            p2 = p2 + 1\n        fin si\n    fin mientras\n    \n    si p1 < contar_elementos(sec1) entonces\n        agregar sec1[p1...fin] a nueva_secuencia\n    fin si\n    \n    si p2 < contar_elementos(sec2) entonces\n        agregar sec2[p2...fin] a nueva_secuencia\n    fin si\n    \n    retornar nueva_secuencia\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_8",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "procedimiento divide_y_conquista(coleccion, bajo, alto)\n    si bajo < alto entonces\n        punto_division = (bajo + alto) div 2\n        \n        divide_y_conquista(coleccion, bajo, punto_division)\n        divide_y_conquista(coleccion, punto_division + 1, alto)\n        \n        fusionar(coleccion, bajo, punto_division, alto)\n    fin si\nfin procedimiento\n\nprocedimiento fusionar(coleccion, inicio, mitad, final)\n    aux = arreglo_auxiliar[final - inicio + 1]\n    pos_izq = inicio\n    pos_der = mitad + 1\n    contador = 0\n    \n    mientras pos_izq <= mitad Y pos_der <= final hacer\n        si coleccion[pos_izq] <= coleccion[pos_der] entonces\n            aux[contador] = coleccion[pos_izq]\n            pos_izq = pos_izq + 1\n        de_otro_modo\n            aux[contador] = coleccion[pos_der]\n            pos_der = pos_der + 1\n        fin si\n        contador = contador + 1\n    fin mientras\n    \n    mientras pos_izq <= mitad hacer\n        aux[contador] = coleccion[pos_izq]\n        pos_izq = pos_izq + 1\n        contador = contador + 1\n    fin mientras\n    \n    mientras pos_der <= final hacer\n        aux[contador] = coleccion[pos_der]\n        pos_der = pos_der + 1\n        contador = contador + 1\n    fin mientras\n    \n    para i = 0 hasta contador - 1 hacer\n        coleccion[inicio + i] = aux[i]\n    fin para\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_merge_9",
    "categoria": "ordenamiento",
    "subcategoria": "merge",
    "pseudocodigo": "funcion ordenamiento_mezcla(elementos)\n    cantidad = longitud(elementos)\n    si cantidad <= 1 entonces retornar elementos\n    \n    centro = cantidad div 2\n    grupo_izquierdo = []\n    grupo_derecho = []\n    \n    para indice = 0 hasta centro - 1 hacer\n        grupo_izquierdo[indice] = elementos[indice]\n    fin para\n    \n    para indice = centro hasta cantidad - 1 hacer\n        grupo_derecho[indice - centro] = elementos[indice]\n    fin para\n    \n    grupo_izquierdo = ordenamiento_mezcla(grupo_izquierdo)\n    grupo_derecho = ordenamiento_mezcla(grupo_derecho)\n    \n    retornar combinar_grupos(grupo_izquierdo, grupo_derecho)\nfin funcion\n\nfuncion combinar_grupos(g1, g2)\n    combinado = []\n    i = 0, j = 0, k = 0\n    \n    mientras i < longitud(g1) Y j < longitud(g2) hacer\n        si g1[i] <= g2[j] entonces\n            combinado[k] = g1[i]\n            i = i + 1\n        sino\n            combinado[k] = g2[j]\n            j = j + 1\n        fin si\n        k = k + 1\n    fin mientras\n    \n    mientras i < longitud(g1) hacer\n        combinado[k] = g1[i]\n        i = i + 1\n        k = k + 1\n    fin mientras\n    \n    mientras j < longitud(g2) hacer\n        combinado[k] = g2[j]\n        j = j + 1\n        k = k + 1\n    fin mientras\n    \n    retornar combinado\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_1",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quicksort(arreglo, inicio, fin)\n    si inicio < fin entonces\n        pivote = particionar(arreglo, inicio, fin)\n        quicksort(arreglo, inicio, pivote - 1)\n        quicksort(arreglo, pivote + 1, fin)\n    fin si\nfin funcion\n\nfuncion particionar(arreglo, inicio, fin)\n    valorPivote = arreglo[fin]\n    i = inicio - 1\n    para j desde inicio hasta fin - 1 hacer\n        si arreglo[j] <= valorPivote entonces\n            i = i + 1\n            intercambiar(arreglo[i], arreglo[j])\n        fin si\n    fin para\n    intercambiar(arreglo[i + 1], arreglo[fin])\n    retornar i + 1\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_2",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento ordenarRapido(lista, izq, der)\n    si izq < der entonces\n        p = izq\n        q = der\n        elemento_central = lista[(izq + der) / 2]\n        \n        mientras p <= q hacer\n            mientras lista[p] < elemento_central hacer\n                p = p + 1\n            fin mientras\n            mientras lista[q] > elemento_central hacer\n                q = q - 1\n            fin mientras\n            si p <= q entonces\n                temp = lista[p]\n                lista[p] = lista[q]\n                lista[q] = temp\n                p = p + 1\n                q = q - 1\n            fin si\n        fin mientras\n        \n        ordenarRapido(lista, izq, q)\n        ordenarRapido(lista, p, der)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_3",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quick(A, bajo, alto)\n    si bajo < alto entonces\n        indice = dividir(A, bajo, alto)\n        quick(A, bajo, indice - 1)\n        quick(A, indice + 1, alto)\n    fin si\nfin funcion\n\nfuncion dividir(A, bajo, alto)\n    pivote = A[bajo]\n    i = bajo + 1\n    j = alto\n    \n    mientras verdadero hacer\n        mientras i <= j y A[i] <= pivote hacer\n            i = i + 1\n        fin mientras\n        mientras A[j] > pivote hacer\n            j = j - 1\n        fin mientras\n        si i < j entonces\n            swap(A[i], A[j])\n        sino\n            salir del ciclo\n        fin si\n    fin mientras\n    \n    swap(A[bajo], A[j])\n    retornar j\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_4",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento qSort(datos[], primero, ultimo)\n    // Ordenamiento rápido recursivo\n    centro = (primero + ultimo) / 2\n    pivot = datos[centro]\n    i = primero\n    j = ultimo\n    \n    mientras i <= j hacer\n        mientras datos[i] < pivot hacer\n            i = i + 1\n        fin mientras\n        mientras datos[j] > pivot hacer\n            j = j - 1\n        fin mientras\n        si i <= j entonces\n            aux = datos[i]\n            datos[i] = datos[j]\n            datos[j] = aux\n            i = i + 1\n            j = j - 1\n        fin si\n    fin mientras\n    \n    si primero < j entonces\n        qSort(datos, primero, j)\n    fin si\n    si i < ultimo entonces\n        qSort(datos, i, ultimo)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_5",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion ordenamientoQuick(vector, left, right)\n    si left >= right entonces\n        retornar\n    fin si\n    \n    pos = particion(vector, left, right)\n    ordenamientoQuick(vector, left, pos - 1)\n    ordenamientoQuick(vector, pos + 1, right)\nfin funcion\n\nfuncion particion(vector, left, right)\n    referencia = vector[right]\n    menor = left\n    \n    para mayor desde left hasta right - 1 hacer\n        si vector[mayor] < referencia entonces\n            temporal = vector[menor]\n            vector[menor] = vector[mayor]\n            vector[mayor] = temporal\n            menor = menor + 1\n        fin si\n    fin para\n    \n    temporal = vector[menor]\n    vector[menor] = vector[right]\n    vector[right] = temporal\n    \n    retornar menor\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_6",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento quickSort(arr, inicio, final)\n    si inicio < final entonces\n        medio = partir(arr, inicio, final)\n        quickSort(arr, inicio, medio - 1)\n        quickSort(arr, medio + 1, final)\n    fin si\nfin procedimiento\n\nprocedimiento partir(arr, inicio, final)\n    x = arr[final]\n    indice = inicio\n    \n    para k desde inicio hasta final - 1 hacer\n        si arr[k] <= x entonces\n            intercambiar arr[indice] con arr[k]\n            indice = indice + 1\n        fin si\n    fin para\n    \n    intercambiar arr[indice] con arr[final]\n    retornar indice\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_7",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion qs(secuencia, min, max)\n    // Implementación con pivote aleatorio\n    si min < max entonces\n        pos_pivote = min + aleatorio(max - min + 1)\n        intercambiar(secuencia[pos_pivote], secuencia[max])\n        \n        valor_p = secuencia[max]\n        idx = min\n        \n        para z desde min hasta max - 1 hacer\n            si secuencia[z] < valor_p entonces\n                intercambiar(secuencia[z], secuencia[idx])\n                idx = idx + 1\n            fin si\n        fin para\n        \n        intercambiar(secuencia[idx], secuencia[max])\n        qs(secuencia, min, idx - 1)\n        qs(secuencia, idx + 1, max)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_8",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento ordenar_quick(coleccion, a, b)\n    si a >= b entonces\n        retornar\n    fin si\n    \n    piv = coleccion[a]\n    izquierda = a + 1\n    derecha = b\n    \n    mientras izquierda <= derecha hacer\n        si coleccion[izquierda] <= piv entonces\n            izquierda = izquierda + 1\n        sino si coleccion[derecha] > piv entonces\n            derecha = derecha - 1\n        sino\n            temp = coleccion[izquierda]\n            coleccion[izquierda] = coleccion[derecha]\n            coleccion[derecha] = temp\n        fin si\n    fin mientras\n    \n    coleccion[a] = coleccion[derecha]\n    coleccion[derecha] = piv\n    \n    ordenar_quick(coleccion, a, derecha - 1)\n    ordenar_quick(coleccion, derecha + 1, b)\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_9",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quicksort_mejorado(array, low, high)\n    si low < high entonces\n        punto = separar(array, low, high)\n        quicksort_mejorado(array, low, punto)\n        quicksort_mejorado(array, punto + 1, high)\n    fin si\nfin funcion\n\nfuncion separar(array, low, high)\n    mitad = (low + high) / 2\n    elem_pivote = array[mitad]\n    i = low - 1\n    j = high + 1\n    \n    mientras verdadero hacer\n        repetir\n            i = i + 1\n        hasta que array[i] >= elem_pivote\n        \n        repetir\n            j = j - 1\n        hasta que array[j] <= elem_pivote\n        \n        si i >= j entonces\n            retornar j\n        fin si\n        \n        cambiar(array[i], array[j])\n    fin mientras\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_10",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento quick_sort(elementos, comienzo, termino)\n    c = comienzo\n    t = termino\n    central = elementos[(comienzo + termino) / 2]\n    \n    mientras c <= t hacer\n        mientras elementos[c] < central hacer\n            c = c + 1\n        fin mientras\n        mientras elementos[t] > central hacer\n            t = t - 1\n        fin mientras\n        si c <= t entonces\n            auxiliar = elementos[c]\n            elementos[c] = elementos[t]\n            elementos[t] = auxiliar\n            c = c + 1\n            t = t - 1\n        fin si\n    fin mientras\n    \n    si comienzo < t entonces\n        quick_sort(elementos, comienzo, t)\n    fin si\n    si c < termino entonces\n        quick_sort(elementos, c, termino)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_11",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion qsort(tabla, primero, ultimo)\n    si primero < ultimo entonces\n        pivote_final = organizar(tabla, primero, ultimo)\n        qsort(tabla, primero, pivote_final - 1)\n        qsort(tabla, pivote_final + 1, ultimo)\n    fin si\nfin funcion\n\nfuncion organizar(tabla, primero, ultimo)\n    valor_referencia = tabla[ultimo]\n    posicion_menor = primero - 1\n    \n    para posicion_actual desde primero hasta ultimo - 1 hacer\n        si tabla[posicion_actual] <= valor_referencia entonces\n            posicion_menor = posicion_menor + 1\n            tmp = tabla[posicion_menor]\n            tabla[posicion_menor] = tabla[posicion_actual]\n            tabla[posicion_actual] = tmp\n        fin si\n    fin para\n    \n    tmp = tabla[posicion_menor + 1]\n    tabla[posicion_menor + 1] = tabla[ultimo]\n    tabla[ultimo] = tmp\n    \n    retornar posicion_menor + 1\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_12",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento sort_quick(nums, start, end)\n    // Caso base\n    si start >= end entonces\n        retornar\n    fin si\n    \n    // Seleccionar pivote y particionar\n    pivot_index = start\n    pivot_value = nums[end]\n    \n    para scan desde start hasta end - 1 hacer\n        si nums[scan] < pivot_value entonces\n            swap(nums[scan], nums[pivot_index])\n            pivot_index = pivot_index + 1\n        fin si\n    fin para\n    \n    swap(nums[pivot_index], nums[end])\n    \n    // Llamadas recursivas\n    sort_quick(nums, start, pivot_index - 1)\n    sort_quick(nums, pivot_index + 1, end)\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_13",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quicksort_clasico(L, inferior, superior)\n    si inferior < superior entonces\n        separador = L[superior]\n        frontera = inferior\n        \n        para explorador desde inferior hasta superior - 1 hacer\n            si L[explorador] <= separador entonces\n                temporal = L[frontera]\n                L[frontera] = L[explorador]\n                L[explorador] = temporal\n                frontera = frontera + 1\n            fin si\n        fin para\n        \n        temporal = L[frontera]\n        L[frontera] = L[superior]\n        L[superior] = temporal\n        \n        quicksort_clasico(L, inferior, frontera - 1)\n        quicksort_clasico(L, frontera + 1, superior)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_14",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "procedimiento ordenamiento_rapido(serie, ini, fin)\n    si ini < fin entonces\n        p_izq = ini\n        p_der = fin\n        medio = serie[(ini + fin) / 2]\n        \n        mientras p_izq <= p_der hacer\n            mientras serie[p_izq] < medio hacer\n                p_izq = p_izq + 1\n            fin mientras\n            \n            mientras serie[p_der] > medio hacer\n                p_der = p_der - 1\n            fin mientras\n            \n            si p_izq <= p_der entonces\n                temp = serie[p_izq]\n                serie[p_izq] = serie[p_der]\n                serie[p_der] = temp\n                p_izq = p_izq + 1\n                p_der = p_der - 1\n            fin si\n        fin mientras\n        \n        ordenamiento_rapido(serie, ini, p_der)\n        ordenamiento_rapido(serie, p_izq, fin)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_quick_15",
    "categoria": "ordenamiento",
    "subcategoria": "quick",
    "pseudocodigo": "funcion quick_ordenar(valores, l, r)\n    si l >= r entonces\n        retornar\n    fin si\n    \n    indice_division = partition_values(valores, l, r)\n    quick_ordenar(valores, l, indice_division - 1)\n    quick_ordenar(valores, indice_division + 1, r)\nfin funcion\n\nfuncion partition_values(valores, l, r)\n    elemento_pivote = valores[r]\n    posicion = l\n    \n    para indice desde l hasta r - 1 hacer\n        si valores[indice] < elemento_pivote entonces\n            tmp = valores[posicion]\n            valores[posicion] = valores[indice]\n            valores[indice] = tmp\n            posicion = posicion + 1\n        fin si\n    fin para\n    \n    tmp = valores[posicion]\n    valores[posicion] = valores[r]\n    valores[r] = tmp\n    \n    retornar posicion\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_1",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion heapSort(arreglo, n)\n    para i desde n/2 - 1 hasta 0 decrementando\n        heapificar(arreglo, n, i)\n    fin para\n    \n    para i desde n-1 hasta 1 decrementando\n        intercambiar(arreglo[0], arreglo[i])\n        heapificar(arreglo, i, 0)\n    fin para\nfin funcion\n\nfuncion heapificar(arreglo, tamaño, raiz)\n    mayor = raiz\n    izq = 2 * raiz + 1\n    der = 2 * raiz + 2\n    \n    si izq < tamaño y arreglo[izq] > arreglo[mayor] entonces\n        mayor = izq\n    fin si\n    \n    si der < tamaño y arreglo[der] > arreglo[mayor] entonces\n        mayor = der\n    fin si\n    \n    si mayor != raiz entonces\n        intercambiar(arreglo[raiz], arreglo[mayor])\n        heapificar(arreglo, tamaño, mayor)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_2",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento ordenarPorMontículo(lista, longitud)\n    construirMonticulo(lista, longitud)\n    \n    mientras longitud > 1 hacer\n        temporal = lista[0]\n        lista[0] = lista[longitud - 1]\n        lista[longitud - 1] = temporal\n        longitud = longitud - 1\n        hundirElemento(lista, 0, longitud)\n    fin mientras\nfin procedimiento\n\nprocedimiento construirMonticulo(lista, longitud)\n    inicio = longitud / 2 - 1\n    mientras inicio >= 0 hacer\n        hundirElemento(lista, inicio, longitud)\n        inicio = inicio - 1\n    fin mientras\nfin procedimiento\n\nprocedimiento hundirElemento(lista, pos, limite)\n    hijoIzq = 2 * pos + 1\n    hijoDer = 2 * pos + 2\n    maximo = pos\n    \n    si hijoIzq < limite y lista[hijoIzq] > lista[maximo] entonces\n        maximo = hijoIzq\n    fin si\n    \n    si hijoDer < limite y lista[hijoDer] > lista[maximo] entonces\n        maximo = hijoDer\n    fin si\n    \n    si maximo != pos entonces\n        swap = lista[pos]\n        lista[pos] = lista[maximo]\n        lista[maximo] = swap\n        hundirElemento(lista, maximo, limite)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_3",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion ordenamientoHeap(datos[], cant)\n    para indice desde cant/2-1 hasta 0 paso -1\n        ajustarHeap(datos, cant, indice)\n    fin para\n    \n    para indice desde cant-1 hasta 1 paso -1\n        temp = datos[0]\n        datos[0] = datos[indice]\n        datos[indice] = temp\n        ajustarHeap(datos, indice, 0)\n    fin para\nfin funcion\n\nfuncion ajustarHeap(datos[], tam, nodo)\n    masGrande = nodo\n    hijo1 = 2*nodo + 1\n    hijo2 = 2*nodo + 2\n    \n    si hijo1 < tam entonces\n        si datos[hijo1] > datos[masGrande] entonces\n            masGrande = hijo1\n        fin si\n    fin si\n    \n    si hijo2 < tam entonces\n        si datos[hijo2] > datos[masGrande] entonces\n            masGrande = hijo2\n        fin si\n    fin si\n    \n    si masGrande != nodo entonces\n        aux = datos[nodo]\n        datos[nodo] = datos[masGrande]\n        datos[masGrande] = aux\n        ajustarHeap(datos, tam, masGrande)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_4",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento heapSort(A, size)\n    buildMaxHeap(A, size)\n    heapSize = size\n    \n    para j desde size hasta 2 paso -1\n        exchange(A[1], A[j])\n        heapSize = heapSize - 1\n        maxHeapify(A, 1, heapSize)\n    fin para\nfin procedimiento\n\nprocedimiento buildMaxHeap(A, size)\n    para k desde size/2 hasta 1 paso -1\n        maxHeapify(A, k, size)\n    fin para\nfin procedimiento\n\nprocedimiento maxHeapify(A, i, heapSize)\n    left = 2 * i\n    right = 2 * i + 1\n    largest = i\n    \n    si left <= heapSize y A[left] > A[largest] entonces\n        largest = left\n    fin si\n    \n    si right <= heapSize y A[right] > A[largest] entonces\n        largest = right\n    fin si\n    \n    si largest != i entonces\n        exchange(A[i], A[largest])\n        maxHeapify(A, largest, heapSize)\n    fin si\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_5",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion sort_heap(vector, num_elementos)\n    crear_heap_maximo(vector, num_elementos)\n    \n    tope = num_elementos - 1\n    mientras tope > 0 hacer\n        permutar(vector[0], vector[tope])\n        tope = tope - 1\n        reajustar_heap(vector, 0, tope)\n    fin mientras\nfin funcion\n\nfuncion crear_heap_maximo(vector, num_elementos)\n    primer_padre = (num_elementos / 2) - 1\n    para p desde primer_padre hasta 0 decrementando\n        reajustar_heap(vector, p, num_elementos - 1)\n    fin para\nfin funcion\n\nfuncion reajustar_heap(vector, padre, ultimo)\n    hijo_izq = padre * 2 + 1\n    hijo_der = padre * 2 + 2\n    mayor_valor = padre\n    \n    si hijo_izq <= ultimo y vector[hijo_izq] > vector[mayor_valor] entonces\n        mayor_valor = hijo_izq\n    fin si\n    \n    si hijo_der <= ultimo y vector[hijo_der] > vector[mayor_valor] entonces\n        mayor_valor = hijo_der\n    fin si\n    \n    si mayor_valor != padre entonces\n        permutar(vector[padre], vector[mayor_valor])\n        reajustar_heap(vector, mayor_valor, ultimo)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_6",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento ordenar_monticulo(elementos[], total)\n    // Construir heap inicial\n    para pos desde total/2-1 hasta 0 paso -1\n        filtrar_abajo(elementos, pos, total)\n    fin para\n    \n    // Extraer elementos uno por uno\n    para pos desde total-1 hasta 1 paso -1\n        cambiar(elementos[0], elementos[pos])\n        filtrar_abajo(elementos, 0, pos)\n    fin para\nfin procedimiento\n\nprocedimiento filtrar_abajo(elementos[], raiz, limite)\n    nodo_actual = raiz\n    continuar = verdadero\n    \n    mientras 2*nodo_actual+1 < limite y continuar hacer\n        hijo_izq = 2*nodo_actual + 1\n        hijo_der = 2*nodo_actual + 2\n        hijo_mayor = hijo_izq\n        \n        si hijo_der < limite entonces\n            si elementos[hijo_der] > elementos[hijo_izq] entonces\n                hijo_mayor = hijo_der\n            fin si\n        fin si\n        \n        si elementos[hijo_mayor] > elementos[nodo_actual] entonces\n            cambiar(elementos[nodo_actual], elementos[hijo_mayor])\n            nodo_actual = hijo_mayor\n        sino\n            continuar = falso\n        fin si\n    fin mientras\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_7",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion heapsort(coleccion, dimension)\n    formar_heap(coleccion, dimension)\n    \n    para idx desde dimension-1 hasta 1 paso -1\n        t = coleccion[0]\n        coleccion[0] = coleccion[idx]\n        coleccion[idx] = t\n        mantener_propiedad_heap(coleccion, 0, idx)\n    fin para\n    \n    retornar coleccion\nfin funcion\n\nfuncion formar_heap(coleccion, dimension)\n    inicio = dimension / 2 - 1\n    para idx desde inicio hasta 0 paso -1\n        mantener_propiedad_heap(coleccion, idx, dimension)\n    fin para\nfin funcion\n\nfuncion mantener_propiedad_heap(coleccion, raiz, tope)\n    maximo = raiz\n    izquierdo = 2 * raiz + 1\n    derecho = 2 * raiz + 2\n    \n    si izquierdo < tope entonces\n        si coleccion[izquierdo] > coleccion[maximo] entonces\n            maximo = izquierdo\n        fin si\n    fin si\n    \n    si derecho < tope entonces\n        si coleccion[derecho] > coleccion[maximo] entonces\n            maximo = derecho\n        fin si\n    fin si\n    \n    si maximo != raiz entonces\n        t = coleccion[raiz]\n        coleccion[raiz] = coleccion[maximo]\n        coleccion[maximo] = t\n        mantener_propiedad_heap(coleccion, maximo, tope)\n    fin si\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_8",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento heap_sort(arr, n)\n    construir_max_heap(arr, n)\n    longitud_heap = n\n    \n    para i desde n-1 hasta 1 paso -1\n        intercambiar_valores(arr, 0, i)\n        longitud_heap = longitud_heap - 1\n        max_heapify(arr, 0, longitud_heap)\n    fin para\nfin procedimiento\n\nprocedimiento construir_max_heap(arr, n)\n    mitad = n / 2\n    para i desde mitad hasta 0 paso -1\n        max_heapify(arr, i, n)\n    fin para\nfin procedimiento\n\nprocedimiento max_heapify(arr, indice, tam_heap)\n    izq = indice * 2 + 1\n    der = indice * 2 + 2\n    mas_grande = indice\n    \n    si izq < tam_heap y arr[izq] > arr[mas_grande] entonces\n        mas_grande = izq\n    fin si\n    \n    si der < tam_heap y arr[der] > arr[mas_grande] entonces\n        mas_grande = der\n    fin si\n    \n    si mas_grande != indice entonces\n        intercambiar_valores(arr, indice, mas_grande)\n        max_heapify(arr, mas_grande, tam_heap)\n    fin si\nfin procedimiento\n\nprocedimiento intercambiar_valores(arr, pos1, pos2)\n    temporal = arr[pos1]\n    arr[pos1] = arr[pos2]\n    arr[pos2] = temporal\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_9",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "funcion ordenamiento_por_heap(secuencia, len)\n    preparar_estructura_heap(secuencia, len)\n    \n    contador = len - 1\n    mientras contador >= 1 hacer\n        mover_elemento(secuencia, 0, contador)\n        contador = contador - 1\n        reorganizar_desde_raiz(secuencia, 0, contador)\n    fin mientras\nfin funcion\n\nfuncion preparar_estructura_heap(secuencia, len)\n    posicion_inicial = len / 2 - 1\n    mientras posicion_inicial >= 0 hacer\n        reorganizar_desde_raiz(secuencia, posicion_inicial, len - 1)\n        posicion_inicial = posicion_inicial - 1\n    fin mientras\nfin funcion\n\nfuncion reorganizar_desde_raiz(secuencia, nodo, final)\n    descendiente_izq = nodo * 2 + 1\n    descendiente_der = nodo * 2 + 2\n    posicion_mayor = nodo\n    \n    si descendiente_izq <= final entonces\n        si secuencia[descendiente_izq] > secuencia[posicion_mayor] entonces\n            posicion_mayor = descendiente_izq\n        fin si\n    fin si\n    \n    si descendiente_der <= final entonces\n        si secuencia[descendiente_der] > secuencia[posicion_mayor] entonces\n            posicion_mayor = descendiente_der\n        fin si\n    fin si\n    \n    si posicion_mayor != nodo entonces\n        mover_elemento(secuencia, nodo, posicion_mayor)\n        reorganizar_desde_raiz(secuencia, posicion_mayor, final)\n    fin si\nfin funcion\n\nfuncion mover_elemento(secuencia, a, b)\n    valor_temp = secuencia[a]\n    secuencia[a] = secuencia[b]\n    secuencia[b] = valor_temp\nfin funcion",
    "label": "ordenamiento"
  },
  {
    "id": "ordenamiento_heap_10",
    "categoria": "ordenamiento",
    "subcategoria": "heap",
    "pseudocodigo": "procedimiento ordenar_con_heap(nums, cantidad)\n    inicializar_heap(nums, cantidad)\n    \n    para indice_actual desde cantidad-1 hasta 1 paso -1\n        realizar_swap(nums, 0, indice_actual)\n        balancear_heap(nums, 0, indice_actual)\n    fin para\nfin procedimiento\n\nprocedimiento inicializar_heap(nums, cantidad)\n    ultimo_padre = (cantidad / 2) - 1\n    \n    para p desde ultimo_padre hasta 0 paso -1\n        balancear_heap(nums, p, cantidad)\n    fin para\nfin procedimiento\n\nprocedimiento balancear_heap(nums, padre, limite)\n    rama_izq = padre * 2 + 1\n    rama_der = padre * 2 + 2\n    indice_max = padre\n    \n    si rama_izq < limite y nums[rama_izq] > nums[indice_max] entonces\n        indice_max = rama_izq\n    fin si\n    \n    si rama_der < limite y nums[rama_der] > nums[indice_max] entonces\n        indice_max = rama_der\n    fin si\n    \n    si indice_max != padre entonces\n        realizar_swap(nums, padre, indice_max)\n        balancear_heap(nums, indice_max, limite)\n    fin si\nfin procedimiento\n\nprocedimiento realizar_swap(nums, i, j)\n    aux = nums[i]\n    nums[i] = nums[j]\n    nums[j] = aux\nfin procedimiento",
    "label": "ordenamiento"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_1",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion fibonacci(n)\n    si n <= 1 entonces\n        retornar n\n    fin si\n    retornar fibonacci(n - 1) + fibonacci(n - 2)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_2",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "// Calcula el n-ésimo número de Fibonacci\nfuncion calcularFib(numero)\n    si numero es igual a 0 entonces\n        retornar 0\n    sino si numero es igual a 1 entonces\n        retornar 1\n    sino\n        resultado1 = calcularFib(numero - 1)\n        resultado2 = calcularFib(numero - 2)\n        retornar resultado1 + resultado2\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_3",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion fib(posicion)\n    // Casos base\n    si posicion < 2 entonces\n        retornar posicion\n    fin si\n    \n    // División del problema\n    anterior = fib(posicion - 1)\n    preAnterior = fib(posicion - 2)\n    \n    // Conquista: combinar resultados\n    retornar anterior + preAnterior\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_4",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion secuenciaFibonacci(indice)\n    si indice == 0 entonces\n        retornar 0\n    fin si\n    si indice == 1 entonces\n        retornar 1\n    fin si\n    retornar secuenciaFibonacci(indice - 1) + secuenciaFibonacci(indice - 2)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_5",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion obtenerFibonacci(pos)\n    // Validación de casos triviales\n    si pos menor o igual que 1 entonces\n        retornar pos\n    de lo contrario\n        // Divide: dos subproblemas más pequeños\n        valorIzq = obtenerFibonacci(pos - 1)\n        valorDer = obtenerFibonacci(pos - 2)\n        // Conquista: suma de ambas ramas\n        suma = valorIzq + valorDer\n        retornar suma\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_6",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion fibonacciRecursivo(term)\n    si term es 0 entonces\n        retornar 0\n    sino\n        si term es 1 entonces\n            retornar 1\n        sino\n            retornar fibonacciRecursivo(term - 1) + fibonacciRecursivo(term - 2)\n        fin si\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_7",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "// Implementación recursiva pura de Fibonacci\nfuncion Fib(k)\n    si k <= 0 entonces\n        retornar 0\n    fin si\n    si k == 1 entonces\n        retornar 1\n    fin si\n    \n    primerLlamada = Fib(k - 1)\n    segundaLlamada = Fib(k - 2)\n    \n    retornar primerLlamada + segundaLlamada\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_8",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion numeroFibonacci(idx)\n    // Condiciones de parada\n    si idx es igual a 0 entonces retornar 0\n    si idx es igual a 1 entonces retornar 1\n    \n    // Recursión dividiendo el problema\n    retornar numeroFibonacci(idx - 1) + numeroFibonacci(idx - 2)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_9",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion calcFibonacci(elemento)\n    si elemento < 2 entonces\n        retornar elemento\n    de lo contrario\n        // Divide y conquista\n        subproblema1 = calcFibonacci(elemento - 1)\n        subproblema2 = calcFibonacci(elemento - 2)\n        solucion = subproblema1 + subproblema2\n        retornar solucion\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_10",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "// Versión con validación explícita\nfuncion fibonacciDivideConquista(valor)\n    si valor == 0 entonces\n        retornar 0\n    fin si\n    \n    si valor == 1 entonces\n        retornar 1\n    fin si\n    \n    // Dividir en dos subproblemas\n    rama1 = fibonacciDivideConquista(valor - 1)\n    rama2 = fibonacciDivideConquista(valor - 2)\n    \n    // Conquistar combinando soluciones\n    resultado = rama1 + rama2\n    retornar resultado\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_11",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion fibRec(num)\n    // Base cases para detener recursión\n    si num menor que 2 entonces\n        retornar num\n    fin si\n    \n    // Llamadas recursivas\n    izquierda = fibRec(num - 1)\n    derecha = fibRec(num - 2)\n    \n    retornar izquierda + derecha\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_fibonacci_12",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "fibonacci",
    "pseudocodigo": "funcion serieF(n)\n    si n es 0 entonces retornar 0\n    si n es 1 entonces retornar 1\n    \n    // Estrategia divide y conquista\n    penultimo = serieF(n - 1)\n    antepenultimo = serieF(n - 2)\n    \n    // Combinar resultados parciales\n    total = penultimo + antepenultimo\n    \n    retornar total\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_1",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion factorial(n)\n    si n es igual a 0 entonces\n        retornar 1\n    sino\n        retornar n * factorial(n - 1)\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_2",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "// Calculo factorial mediante recursion\nfuncion calcularFactorial(numero)\n    si numero menor o igual a 1 entonces\n        retornar 1\n    fin si\n    retornar numero * calcularFactorial(numero - 1)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_3",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion fact(x)\n    // Caso base\n    si x es 0 o x es 1 entonces\n        retornar 1\n    sino\n        // Caso recursivo\n        resultado = x * fact(x - 1)\n        retornar resultado\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_4",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion factorialRecursivo(valor)\n    si valor es igual a 0 entonces\n        retornar 1\n    de lo contrario\n        temporal = factorialRecursivo(valor - 1)\n        retornar valor * temporal\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_5",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion calcFact(num)\n    si num menor o igual que 0 entonces\n        retornar 1\n    fin si\n    producto = num * calcFact(num - 1)\n    retornar producto\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_6",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "// Implementacion recursiva de factorial\n// Usa divide y conquista\nfuncion obtenerFactorial(n)\n    si n es 1 entonces\n        retornar 1\n    sino si n es 0 entonces\n        retornar 1\n    sino\n        retornar n * obtenerFactorial(n - 1)\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_7",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion factRec(entrada)\n    si entrada igual a 0 entonces\n        retornar 1\n    fin si\n    \n    valorAnterior = factRec(entrada - 1)\n    resultadoFinal = entrada * valorAnterior\n    retornar resultadoFinal\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_8",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion factorial_recursivo(parametro)\n    // Verificar caso base\n    si parametro es 0 o parametro es 1 entonces\n        retornar 1\n    de lo contrario\n        retornar parametro * factorial_recursivo(parametro - 1)\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_9",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion factorialDivideConquista(k)\n    si k menor que 2 entonces\n        retornar 1\n    fin si\n    subproblema = factorialDivideConquista(k - 1)\n    solucion = k * subproblema\n    retornar solucion\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_10",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "// Calcula el factorial de un numero entero\nfuncion fact_recursiva(dato)\n    si dato es igual a 1 entonces\n        retornar 1\n    sino si dato es igual a 0 entonces\n        retornar 1\n    sino\n        res = dato * fact_recursiva(dato - 1)\n        retornar res\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_11",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "funcion factorialNumero(m)\n    si m es 0 entonces\n        retornar 1\n    sino\n        llamadaRecursiva = factorialNumero(m - 1)\n        multiplicacion = m * llamadaRecursiva\n        retornar multiplicacion\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_factorial_12",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "factorial",
    "pseudocodigo": "// Funcion factorial con enfoque divide y conquista\nfuncion computarFactorial(entero)\n    // Condicion de parada\n    si entero menor o igual a 1 entonces\n        retornar 1\n    fin si\n    // Division del problema\n    subresultado = computarFactorial(entero - 1)\n    // Conquista: combinar resultados\n    retornar entero * subresultado\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_1",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "funcion moverDiscos(n, origen, destino, auxiliar)\n    si n == 1 entonces\n        escribir \"Mover disco de \" + origen + \" a \" + destino\n        retornar\n    fin si\n    \n    moverDiscos(n-1, origen, auxiliar, destino)\n    escribir \"Mover disco de \" + origen + \" a \" + destino\n    moverDiscos(n-1, auxiliar, destino, origen)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_2",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "funcion hanoi(numDiscos, torreA, torreB, torreC)\n    // Caso base: un solo disco\n    si numDiscos == 1 entonces\n        imprimir \"Transferir disco 1 desde \" + torreA + \" hasta \" + torreB\n    sino\n        // Mover n-1 discos a torre auxiliar\n        hanoi(numDiscos-1, torreA, torreC, torreB)\n        // Mover disco mayor\n        imprimir \"Transferir disco \" + numDiscos + \" desde \" + torreA + \" hasta \" + torreB\n        // Mover n-1 discos desde auxiliar a destino\n        hanoi(numDiscos-1, torreC, torreB, torreA)\n    fin si\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_3",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "procedimiento resolverTorres(cantidad, posteInicial, posteFinal, posteIntermedio)\n    si cantidad > 0 entonces\n        resolverTorres(cantidad-1, posteInicial, posteIntermedio, posteFinal)\n        mostrar \"Mover disco desde poste \" + posteInicial + \" hacia poste \" + posteFinal\n        resolverTorres(cantidad-1, posteIntermedio, posteFinal, posteInicial)\n    fin si\nfin procedimiento",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_4",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "funcion torres(discos, desde, hacia, usando)\n    si discos == 0 entonces\n        retornar\n    fin si\n    torres(discos-1, desde, usando, hacia)\n    escribir \"Disco \" + discos + \": \" + desde + \" -> \" + hacia\n    torres(discos-1, usando, hacia, desde)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_5",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "procedimiento hanoi_recursivo(n, varilla_origen, varilla_destino, varilla_auxiliar)\n    // Divide y conquista: resolver subproblemas\n    si n >= 1 entonces\n        // Paso 1: mover n-1 discos a auxiliar\n        hanoi_recursivo(n-1, varilla_origen, varilla_auxiliar, varilla_destino)\n        \n        // Paso 2: mover el disco más grande\n        imprimir \"Mover disco de tamaño \" + n + \" de \" + varilla_origen + \" a \" + varilla_destino\n        \n        // Paso 3: mover n-1 discos de auxiliar a destino\n        hanoi_recursivo(n-1, varilla_auxiliar, varilla_destino, varilla_origen)\n    fin si\nfin procedimiento",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_6",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "funcion solucionarHanoi(total, A, B, C)\n    si total == 1 entonces\n        retornar \"Mover de \" + A + \" a \" + B\n    fin si\n    \n    solucionarHanoi(total-1, A, C, B)\n    imprimir \"Movimiento: \" + A + \" --> \" + B\n    solucionarHanoi(total-1, C, B, A)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_7",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "procedimiento mover_torres(piezas, torre1, torre2, torre3)\n    si piezas == 1 entonces\n        escribir torre1 + \" a \" + torre2\n    sino\n        mover_torres(piezas-1, torre1, torre3, torre2)\n        escribir torre1 + \" a \" + torre2\n        mover_torres(piezas-1, torre3, torre2, torre1)\n    fin si\nfin procedimiento",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_8",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "funcion transferirDiscos(altura, columnaOrigen, columnaDestino, columnaAux)\n    // Estrategia divide y conquista\n    si altura == 0 entonces\n        retornar 0\n    fin si\n    \n    movimientos := 0\n    \n    // Subproblema 1\n    movimientos := movimientos + transferirDiscos(altura-1, columnaOrigen, columnaAux, columnaDestino)\n    \n    // Resolver problema actual\n    mostrar \"Trasladar disco desde \" + columnaOrigen + \" hasta \" + columnaDestino\n    movimientos := movimientos + 1\n    \n    // Subproblema 2\n    movimientos := movimientos + transferirDiscos(altura-1, columnaAux, columnaDestino, columnaOrigen)\n    \n    retornar movimientos\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_9",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "procedimiento hanoi_clasico(num, P1, P2, P3)\n    si num > 0 entonces\n        hanoi_clasico(num-1, P1, P3, P2)\n        imprimir \"Pasar disco de \" + P1 + \" a \" + P2\n        hanoi_clasico(num-1, P3, P2, P1)\n    fin si\nfin procedimiento",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_10",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "funcion resolver(cantidadDiscos, puntoPartida, puntoLlegada, puntoApoyo)\n    si cantidadDiscos == 1 entonces\n        escribir \"Movimiento: disco 1 de \" + puntoPartida + \" a \" + puntoLlegada\n        retornar\n    fin si\n    \n    resolver(cantidadDiscos-1, puntoPartida, puntoApoyo, puntoLlegada)\n    escribir \"Movimiento: disco \" + cantidadDiscos + \" de \" + puntoPartida + \" a \" + puntoLlegada\n    resolver(cantidadDiscos-1, puntoApoyo, puntoLlegada, puntoPartida)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_11",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "procedimiento torresHanoi(nivel, estacaA, estacaB, estacaC)\n    // Caso base de la recursión\n    si nivel == 1 entonces\n        mostrar \"Mover: \" + estacaA + \" -> \" + estacaB\n        retornar\n    fin si\n    \n    // Primera fase: liberar disco inferior\n    torresHanoi(nivel-1, estacaA, estacaC, estacaB)\n    \n    // Segunda fase: mover disco inferior\n    mostrar \"Mover: \" + estacaA + \" -> \" + estacaB\n    \n    // Tercera fase: reconstruir torre\n    torresHanoi(nivel-1, estacaC, estacaB, estacaA)\nfin procedimiento",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_torres_hanoi_12",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "torres_hanoi",
    "pseudocodigo": "funcion jugarHanoi(elementos, base, objetivo, temporal)\n    si elementos <= 0 entonces\n        retornar\n    fin si\n    \n    jugarHanoi(elementos-1, base, temporal, objetivo)\n    imprimir \"Acción: llevar disco \" + elementos + \" desde \" + base + \" hasta \" + objetivo\n    jugarHanoi(elementos-1, temporal, objetivo, base)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_multiplicacion_matrices_1",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "multiplicacion_matrices",
    "pseudocodigo": "funcion multiplicar_matrices(A, B, n)\n    si n == 1 entonces\n        retornar A[0][0] * B[0][0]\n    fin si\n    \n    mitad = n / 2\n    \n    A11 = submatriz(A, 0, 0, mitad)\n    A12 = submatriz(A, 0, mitad, mitad)\n    A21 = submatriz(A, mitad, 0, mitad)\n    A22 = submatriz(A, mitad, mitad, mitad)\n    \n    B11 = submatriz(B, 0, 0, mitad)\n    B12 = submatriz(B, 0, mitad, mitad)\n    B21 = submatriz(B, mitad, 0, mitad)\n    B22 = submatriz(B, mitad, mitad, mitad)\n    \n    C11 = sumar(multiplicar_matrices(A11, B11, mitad), multiplicar_matrices(A12, B21, mitad))\n    C12 = sumar(multiplicar_matrices(A11, B12, mitad), multiplicar_matrices(A12, B22, mitad))\n    C21 = sumar(multiplicar_matrices(A21, B11, mitad), multiplicar_matrices(A22, B21, mitad))\n    C22 = sumar(multiplicar_matrices(A21, B12, mitad), multiplicar_matrices(A22, B22, mitad))\n    \n    retornar combinar(C11, C12, C21, C22)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_multiplicacion_matrices_2",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "multiplicacion_matrices",
    "pseudocodigo": "funcion mult_mat_recursiva(matriz1, matriz2, tam)\n    si tam == 1 entonces\n        resultado = crear_matriz(1, 1)\n        resultado[0][0] = matriz1[0][0] * matriz2[0][0]\n        retornar resultado\n    fin si\n    \n    nuevo_tam = tam / 2\n    \n    M1_sup_izq = extraer(matriz1, 0, 0, nuevo_tam)\n    M1_sup_der = extraer(matriz1, 0, nuevo_tam, nuevo_tam)\n    M1_inf_izq = extraer(matriz1, nuevo_tam, 0, nuevo_tam)\n    M1_inf_der = extraer(matriz1, nuevo_tam, nuevo_tam, nuevo_tam)\n    \n    M2_sup_izq = extraer(matriz2, 0, 0, nuevo_tam)\n    M2_sup_der = extraer(matriz2, 0, nuevo_tam, nuevo_tam)\n    M2_inf_izq = extraer(matriz2, nuevo_tam, 0, nuevo_tam)\n    M2_inf_der = extraer(matriz2, nuevo_tam, nuevo_tam, nuevo_tam)\n    \n    R1 = sumar_matrices(mult_mat_recursiva(M1_sup_izq, M2_sup_izq, nuevo_tam), mult_mat_recursiva(M1_sup_der, M2_inf_izq, nuevo_tam))\n    R2 = sumar_matrices(mult_mat_recursiva(M1_sup_izq, M2_sup_der, nuevo_tam), mult_mat_recursiva(M1_sup_der, M2_inf_der, nuevo_tam))\n    R3 = sumar_matrices(mult_mat_recursiva(M1_inf_izq, M2_sup_izq, nuevo_tam), mult_mat_recursiva(M1_inf_der, M2_inf_izq, nuevo_tam))\n    R4 = sumar_matrices(mult_mat_recursiva(M1_inf_izq, M2_sup_der, nuevo_tam), mult_mat_recursiva(M1_inf_der, M2_inf_der, nuevo_tam))\n    \n    retornar unir_submatrices(R1, R2, R3, R4, tam)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_multiplicacion_matrices_3",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "multiplicacion_matrices",
    "pseudocodigo": "funcion producto_matrices_DC(X, Y, dimension)\n    // Caso base: matriz 1x1\n    si dimension <= 1 entonces\n        retornar X[0][0] * Y[0][0]\n    fin si\n    \n    d = dimension / 2\n    \n    // Dividir matriz X\n    X_NW = obtener_cuadrante(X, 0, 0, d)\n    X_NE = obtener_cuadrante(X, 0, d, d)\n    X_SW = obtener_cuadrante(X, d, 0, d)\n    X_SE = obtener_cuadrante(X, d, d, d)\n    \n    // Dividir matriz Y\n    Y_NW = obtener_cuadrante(Y, 0, 0, d)\n    Y_NE = obtener_cuadrante(Y, 0, d, d)\n    Y_SW = obtener_cuadrante(Y, d, 0, d)\n    Y_SE = obtener_cuadrante(Y, d, d, d)\n    \n    // Conquistar: 8 multiplicaciones recursivas\n    Z_NW = adicionar(producto_matrices_DC(X_NW, Y_NW, d), producto_matrices_DC(X_NE, Y_SW, d))\n    Z_NE = adicionar(producto_matrices_DC(X_NW, Y_NE, d), producto_matrices_DC(X_NE, Y_SE, d))\n    Z_SW = adicionar(producto_matrices_DC(X_SW, Y_NW, d), producto_matrices_DC(X_SE, Y_SW, d))\n    Z_SE = adicionar(producto_matrices_DC(X_SW, Y_NE, d), producto_matrices_DC(X_SE, Y_SE, d))\n    \n    retornar ensamblar_matriz(Z_NW, Z_NE, Z_SW, Z_SE)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_multiplicacion_matrices_4",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "multiplicacion_matrices",
    "pseudocodigo": "funcion dividir_y_conquistar_mult(P, Q, size)\n    si size == 1 entonces\n        res = nueva_matriz(1)\n        res[0][0] = P[0][0] * Q[0][0]\n        retornar res\n    fin si\n    \n    mitad_size = size / 2\n    \n    P1 = particionar(P, 0, 0, mitad_size)\n    P2 = particionar(P, 0, mitad_size, mitad_size)\n    P3 = particionar(P, mitad_size, 0, mitad_size)\n    P4 = particionar(P, mitad_size, mitad_size, mitad_size)\n    \n    Q1 = particionar(Q, 0, 0, mitad_size)\n    Q2 = particionar(Q, 0, mitad_size, mitad_size)\n    Q3 = particionar(Q, mitad_size, 0, mitad_size)\n    Q4 = particionar(Q, mitad_size, mitad_size, mitad_size)\n    \n    T1 = suma(dividir_y_conquistar_mult(P1, Q1, mitad_size), dividir_y_conquistar_mult(P2, Q3, mitad_size))\n    T2 = suma(dividir_y_conquistar_mult(P1, Q2, mitad_size), dividir_y_conquistar_mult(P2, Q4, mitad_size))\n    T3 = suma(dividir_y_conquistar_mult(P3, Q1, mitad_size), dividir_y_conquistar_mult(P4, Q3, mitad_size))\n    T4 = suma(dividir_y_conquistar_mult(P3, Q2, mitad_size), dividir_y_conquistar_mult(P4, Q4, mitad_size))\n    \n    retornar construir_resultado(T1, T2, T3, T4, size)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_multiplicacion_matrices_5",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "multiplicacion_matrices",
    "pseudocodigo": "funcion mult_rec(mat_a, mat_b, n)\n    si n == 1 entonces\n        retornar mat_a[0][0] * mat_b[0][0]\n    fin si\n    \n    k = n / 2\n    \n    a11 = dividir_matriz(mat_a, 0, 0, k)\n    a12 = dividir_matriz(mat_a, 0, k, k)\n    a21 = dividir_matriz(mat_a, k, 0, k)\n    a22 = dividir_matriz(mat_a, k, k, k)\n    \n    b11 = dividir_matriz(mat_b, 0, 0, k)\n    b12 = dividir_matriz(mat_b, 0, k, k)\n    b21 = dividir_matriz(mat_b, k, 0, k)\n    b22 = dividir_matriz(mat_b, k, k, k)\n    \n    c11 = agregar(mult_rec(a11, b11, k), mult_rec(a12, b21, k))\n    c12 = agregar(mult_rec(a11, b12, k), mult_rec(a12, b22, k))\n    c21 = agregar(mult_rec(a21, b11, k), mult_rec(a22, b21, k))\n    c22 = agregar(mult_rec(a21, b12, k), mult_rec(a22, b22, k))\n    \n    resultado = juntar_bloques(c11, c12, c21, c22, n)\n    retornar resultado\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_multiplicacion_matrices_6",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "multiplicacion_matrices",
    "pseudocodigo": "funcion multiplicacion_por_bloques(primera, segunda, orden)\n    // Verificar caso base\n    si orden == 1 entonces\n        retornar primera[0][0] * segunda[0][0]\n    fin si\n    \n    medio = orden / 2\n    \n    // Extraer bloques de la primera matriz\n    bloque_a11 = copiar_bloque(primera, 0, 0, medio)\n    bloque_a12 = copiar_bloque(primera, 0, medio, medio)\n    bloque_a21 = copiar_bloque(primera, medio, 0, medio)\n    bloque_a22 = copiar_bloque(primera, medio, medio, medio)\n    \n    // Extraer bloques de la segunda matriz\n    bloque_b11 = copiar_bloque(segunda, 0, 0, medio)\n    bloque_b12 = copiar_bloque(segunda, 0, medio, medio)\n    bloque_b21 = copiar_bloque(segunda, medio, 0, medio)\n    bloque_b22 = copiar_bloque(segunda, medio, medio, medio)\n    \n    // Calcular bloques del resultado\n    resultado11 = suma_bloques(multiplicacion_por_bloques(bloque_a11, bloque_b11, medio), multiplicacion_por_bloques(bloque_a12, bloque_b21, medio))\n    resultado12 = suma_bloques(multiplicacion_por_bloques(bloque_a11, bloque_b12, medio), multiplicacion_por_bloques(bloque_a12, bloque_b22, medio))\n    resultado21 = suma_bloques(multiplicacion_por_bloques(bloque_a21, bloque_b11, medio), multiplicacion_por_bloques(bloque_a22, bloque_b21, medio))\n    resultado22 = suma_bloques(multiplicacion_por_bloques(bloque_a21, bloque_b12, medio), multiplicacion_por_bloques(bloque_a22, bloque_b22, medio))\n    \n    retornar fusionar(resultado11, resultado12, resultado21, resultado22, orden)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "recursivo_divide_conquista_multiplicacion_matrices_7",
    "categoria": "recursivo_divide_conquista",
    "subcategoria": "multiplicacion_matrices",
    "pseudocodigo": "funcion matriz_producto_recursivo(M1, M2, tam_matriz)\n    si tam_matriz == 1 entonces\n        salida = [[0]]\n        salida[0][0] = M1[0][0] * M2[0][0]\n        retornar salida\n    fin si\n    \n    nuevo_tamanio = tam_matriz / 2\n    \n    M1_parte1 = segmentar(M1, 0, 0, nuevo_tamanio)\n    M1_parte2 = segmentar(M1, 0, nuevo_tamanio, nuevo_tamanio)\n    M1_parte3 = segmentar(M1, nuevo_tamanio, 0, nuevo_tamanio)\n    M1_parte4 = segmentar(M1, nuevo_tamanio, nuevo_tamanio, nuevo_tamanio)\n    \n    M2_parte1 = segmentar(M2, 0, 0, nuevo_tamanio)\n    M2_parte2 = segmentar(M2, 0, nuevo_tamanio, nuevo_tamanio)\n    M2_parte3 = segmentar(M2, nuevo_tamanio, 0, nuevo_tamanio)\n    M2_parte4 = segmentar(M2, nuevo_tamanio, nuevo_tamanio, nuevo_tamanio)\n    \n    salida_parte1 = sumar_dos_matrices(matriz_producto_recursivo(M1_parte1, M2_parte1, nuevo_tamanio), matriz_producto_recursivo(M1_parte2, M2_parte3, nuevo_tamanio))\n    salida_parte2 = sumar_dos_matrices(matriz_producto_recursivo(M1_parte1, M2_parte2, nuevo_tamanio), matriz_producto_recursivo(M1_parte2, M2_parte4, nuevo_tamanio))\n    salida_parte3 = sumar_dos_matrices(matriz_producto_recursivo(M1_parte3, M2_parte1, nuevo_tamanio), matriz_producto_recursivo(M1_parte4, M2_parte3, nuevo_tamanio))\n    salida_parte4 = sumar_dos_matrices(matriz_producto_recursivo(M1_parte3, M2_parte2, nuevo_tamanio), matriz_producto_recursivo(M1_parte4, M2_parte4, nuevo_tamanio))\n    \n    retornar armar_matriz_completa(salida_parte1, salida_parte2, salida_parte3, salida_parte4)\nfin funcion",
    "label": "recursivo_divide_conquista"
  },
  {
    "id": "iterativo_suma_array_1",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion suma_array(arreglo, tamanio)\n    total = 0\n    para i desde 0 hasta tamanio-1 hacer\n        total = total + arreglo[i]\n    fin para\n    retornar total\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_2",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion calcular_suma(lista, n)\n    // Inicializar acumulador\n    acumulador = 0\n    indice = 0\n    \n    // Recorrer todos los elementos\n    mientras indice < n hacer\n        acumulador = acumulador + lista[indice]\n        indice = indice + 1\n    fin mientras\n    \n    retornar acumulador\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_3",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion sumar_elementos(vector, cantidad_elementos)\n    resultado = 0\n    contador = 0\n    mientras contador < cantidad_elementos hacer\n        resultado = resultado + vector[contador]\n        contador = contador + 1\n    fin mientras\n    retornar resultado\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_4",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion obtener_suma_total(datos, longitud)\n    suma_parcial = 0\n    para cada_posicion desde 0 hasta longitud-1 hacer\n        suma_parcial = suma_parcial + datos[cada_posicion]\n    fin para\n    retornar suma_parcial\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_5",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion sumatoria(arr, tam)\n    s = 0\n    j = 0\n    mientras j < tam hacer\n        s = s + arr[j]\n        j = j + 1\n    fin mientras\n    retornar s\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_6",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion suma_de_arreglo(numeros, dimension)\n    // Variable para almacenar el resultado\n    suma_total = 0\n    \n    // Iterar por cada elemento del arreglo\n    para pos desde 0 hasta dimension-1 hacer\n        suma_total = suma_total + numeros[pos]\n    fin para\n    \n    // Devolver el resultado final\n    retornar suma_total\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_7",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion calcular_sumatoria(coleccion, num_elementos)\n    valor_acumulado = 0\n    posicion_actual = 0\n    \n    mientras posicion_actual < num_elementos hacer\n        valor_acumulado = valor_acumulado + coleccion[posicion_actual]\n        posicion_actual = posicion_actual + 1\n    fin mientras\n    \n    retornar valor_acumulado\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_8",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion suma_iterativa(A, N)\n    resultado_suma = 0\n    para k desde 0 hasta N-1 hacer\n        resultado_suma = resultado_suma + A[k]\n    fin para\n    retornar resultado_suma\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_9",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion agregar_elementos(valores, largo)\n    total_suma = 0\n    idx = 0\n    \n    mientras idx < largo hacer\n        total_suma = total_suma + valores[idx]\n        idx = idx + 1\n    fin mientras\n    \n    retornar total_suma\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_10",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion sumar_valores_array(elementos, cantidad)\n    // Comenzar con suma en cero\n    suma = 0\n    \n    // Procesar cada elemento\n    para i_actual desde 0 hasta cantidad-1 hacer\n        // Agregar elemento actual a la suma\n        suma = suma + elementos[i_actual]\n    fin para\n    \n    // Retornar suma calculada\n    retornar suma\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_11",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion suma_completa(vector_numeros, tamanio_vector)\n    acum = 0\n    p = 0\n    mientras p < tamanio_vector hacer\n        acum = acum + vector_numeros[p]\n        p = p + 1\n    fin mientras\n    retornar acum\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_suma_array_12",
    "categoria": "iterativo",
    "subcategoria": "suma_array",
    "pseudocodigo": "funcion obtener_suma(array_entrada, num_elem)\n    variable_suma = 0\n    \n    para indice_i desde 0 hasta num_elem-1 hacer\n        variable_suma = variable_suma + array_entrada[indice_i]\n    fin para\n    \n    retornar variable_suma\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_1",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion encontrarMaximoMinimo(arreglo, n)\n    max = arreglo[0]\n    min = arreglo[0]\n    para i desde 1 hasta n-1 hacer\n        si arreglo[i] > max entonces\n            max = arreglo[i]\n        fin si\n        si arreglo[i] < min entonces\n            min = arreglo[i]\n        fin si\n    fin para\n    retornar max, min\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_2",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion buscarExtremos(lista, tamaño)\n    // Inicializar con el primer elemento\n    valorMaximo = lista[0]\n    valorMinimo = lista[0]\n    \n    indice = 1\n    mientras indice < tamaño hacer\n        si lista[indice] > valorMaximo entonces\n            valorMaximo = lista[indice]\n        sino si lista[indice] < valorMinimo entonces\n            valorMinimo = lista[indice]\n        fin si\n        indice = indice + 1\n    fin mientras\n    \n    retornar valorMaximo, valorMinimo\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_3",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion calcularMaxMin(datos, cantidad)\n    mayor = datos[0]\n    menor = datos[0]\n    \n    para cada elemento en datos hacer\n        si elemento > mayor entonces\n            mayor = elemento\n        fin si\n        si elemento < menor entonces\n            menor = elemento\n        fin si\n    fin para\n    \n    retornar mayor, menor\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_4",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion obtenerRango(vector, longitud)\n    si longitud = 0 entonces\n        retornar nulo\n    fin si\n    \n    maximo = vector[0]\n    minimo = vector[0]\n    posicion = 0\n    \n    mientras posicion < longitud hacer\n        actual = vector[posicion]\n        si actual > maximo entonces\n            maximo = actual\n        fin si\n        si actual < minimo entonces\n            minimo = actual\n        fin si\n        posicion = posicion + 1\n    fin mientras\n    \n    retornar minimo, maximo\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_5",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion extremosArray(A, tam)\n    maxVal = A[0]\n    minVal = A[0]\n    i = 1\n    mientras i < tam hacer\n        si A[i] > maxVal entonces\n            maxVal = A[i]\n        fin si\n        si A[i] < minVal entonces\n            minVal = A[i]\n        fin si\n        i = i + 1\n    fin mientras\n    retornar maxVal, minVal\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_6",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion hallarMaximoYMinimo(secuencia, total)\n    // Variables para almacenar extremos\n    elementoMaximo = secuencia[0]\n    elementoMinimo = secuencia[0]\n    \n    // Recorrer desde el segundo elemento\n    para j desde 1 hasta total-1 hacer\n        valorActual = secuencia[j]\n        \n        si valorActual > elementoMaximo entonces\n            elementoMaximo = valorActual\n        fin si\n        \n        si valorActual < elementoMinimo entonces\n            elementoMinimo = valorActual\n        fin si\n    fin para\n    \n    retornar elementoMaximo, elementoMinimo\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_7",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion determinarExtremos(numeros, n)\n    limiteInferior = numeros[0]\n    limiteSuperior = numeros[0]\n    contador = 1\n    \n    mientras contador < n hacer\n        si numeros[contador] < limiteInferior entonces\n            limiteInferior = numeros[contador]\n        sino si numeros[contador] > limiteSuperior entonces\n            limiteSuperior = numeros[contador]\n        fin si\n        contador = contador + 1\n    fin mientras\n    \n    retornar limiteSuperior, limiteInferior\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_8",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion maxYMin(arr, len)\n    max = arr[0]\n    min = arr[0]\n    \n    para idx desde 0 hasta len-1 hacer\n        si arr[idx] > max entonces\n            max = arr[idx]\n        sino\n            si arr[idx] < min entonces\n                min = arr[idx]\n            fin si\n        fin si\n    fin para\n    \n    retornar max, min\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_9",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion encontrarLimites(conjunto, dimension)\n    // Validar entrada\n    si dimension <= 0 entonces\n        retornar error\n    fin si\n    \n    valorMayor = conjunto[0]\n    valorMenor = conjunto[0]\n    \n    k = 1\n    mientras k < dimension hacer\n        elementoActual = conjunto[k]\n        \n        si elementoActual > valorMayor entonces\n            valorMayor = elementoActual\n        fin si\n        \n        si elementoActual < valorMenor entonces\n            valorMenor = elementoActual\n        fin si\n        \n        k = k + 1\n    fin mientras\n    \n    retornar valorMayor, valorMenor\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_10",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion buscarMaxMin(valores, size)\n    primerValor = valores[0]\n    maximoEncontrado = primerValor\n    minimoEncontrado = primerValor\n    \n    para p desde 1 hasta size-1 hacer\n        si valores[p] > maximoEncontrado entonces\n            maximoEncontrado = valores[p]\n        fin si\n        si valores[p] < minimoEncontrado entonces\n            minimoEncontrado = valores[p]\n        fin si\n    fin para\n    \n    retornar maximoEncontrado, minimoEncontrado\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_11",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion obtenerMaximoMinimo(serie, numElementos)\n    mayorValor = serie[0]\n    menorValor = serie[0]\n    indiceActual = 0\n    \n    mientras indiceActual < numElementos hacer\n        valorExaminado = serie[indiceActual]\n        \n        si valorExaminado > mayorValor entonces\n            mayorValor = valorExaminado\n        fin si\n        \n        si valorExaminado < menorValor entonces\n            menorValor = valorExaminado\n        fin si\n        \n        indiceActual = indiceActual + 1\n    fin mientras\n    \n    retornar mayorValor, menorValor\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_maximo_minimo_12",
    "categoria": "iterativo",
    "subcategoria": "maximo_minimo",
    "pseudocodigo": "funcion calcularExtremosLista(L, cantidadElementos)\n    // Inicialización\n    maxi = L[0]\n    mini = L[0]\n    \n    // Búsqueda iterativa\n    para pos desde 1 hasta cantidadElementos-1 hacer\n        elemento = L[pos]\n        \n        si elemento > maxi entonces\n            maxi = elemento\n        fin si\n        \n        si elemento < mini entonces\n            mini = elemento\n        fin si\n    fin para\n    \n    // Retornar resultados\n    retornar maxi, mini\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_1",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion contarPositivos(arreglo)\n    contador = 0\n    para cada elemento en arreglo hacer\n        si elemento > 0 entonces\n            contador = contador + 1\n        fin si\n    fin para\n    retornar contador\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_2",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "// Cuenta cuántos números pares hay en una lista\nfuncion totalPares(lista, tamaño)\n    suma = 0\n    indice = 0\n    mientras indice < tamaño hacer\n        si lista[indice] mod 2 == 0 entonces\n            suma = suma + 1\n        fin si\n        indice = indice + 1\n    fin mientras\n    retornar suma\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_3",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion cuantasVocales(cadena)\n    total = 0\n    i = 0\n    mientras i < longitud(cadena) hacer\n        caracter = cadena[i]\n        si caracter == 'a' o caracter == 'e' o caracter == 'i' o caracter == 'o' o caracter == 'u' entonces\n            total = total + 1\n        fin si\n        i = i + 1\n    fin mientras\n    retornar total\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_4",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion conteoNegativos(numeros, n)\n    cuenta = 0\n    para j = 0 hasta n - 1 hacer\n        si numeros[j] < 0 entonces\n            cuenta = cuenta + 1\n        fin si\n    fin para\n    retornar cuenta\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_5",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "// Contar elementos mayores a un umbral dado\nfuncion contarMayoresQue(datos, limite, longitud)\n    resultado = 0\n    posicion = 0\n    mientras posicion < longitud hacer\n        si datos[posicion] > limite entonces\n            resultado = resultado + 1\n        fin si\n        posicion = posicion + 1\n    fin mientras\n    retornar resultado\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_6",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion cuantosImpares(secuencia)\n    cantidadImpares = 0\n    para cada numero en secuencia hacer\n        si numero mod 2 != 0 entonces\n            cantidadImpares = cantidadImpares + 1\n        fin si\n    fin para\n    retornar cantidadImpares\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_7",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion contarCeros(vector, tam)\n    c = 0\n    idx = 0\n    mientras idx < tam hacer\n        si vector[idx] == 0 entonces\n            c = c + 1\n        fin si\n        idx = idx + 1\n    fin mientras\n    retornar c\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_8",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "// Cuenta elementos dentro de un rango específico\nfuncion contarEnRango(arr, min, max, size)\n    contador = 0\n    para k = 0 hasta size - 1 hacer\n        si arr[k] >= min y arr[k] <= max entonces\n            contador = contador + 1\n        fin si\n    fin para\n    retornar contador\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_9",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion contarMayusculas(texto)\n    numMayusculas = 0\n    pos = 0\n    mientras pos < longitud(texto) hacer\n        letra = texto[pos]\n        si letra >= 'A' y letra <= 'Z' entonces\n            numMayusculas = numMayusculas + 1\n        fin si\n        pos = pos + 1\n    fin mientras\n    retornar numMayusculas\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_10",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion cuantosMultiplosDeTres(coleccion, cantidad)\n    conteo = 0\n    para i = 0 hasta cantidad - 1 hacer\n        si coleccion[i] mod 3 == 0 entonces\n            conteo = conteo + 1\n        fin si\n    fin para\n    retornar conteo\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_11",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "// Contar palabras en una cadena separadas por espacios\nfuncion contarPalabras(frase)\n    palabras = 0\n    enPalabra = falso\n    i = 0\n    mientras i < longitud(frase) hacer\n        si frase[i] != ' ' entonces\n            si enPalabra == falso entonces\n                palabras = palabras + 1\n                enPalabra = verdadero\n            fin si\n        sino\n            enPalabra = falso\n        fin si\n        i = i + 1\n    fin mientras\n    retornar palabras\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_conteo_12",
    "categoria": "iterativo",
    "subcategoria": "conteo",
    "pseudocodigo": "funcion contarDuplicados(array, len)\n    totalDuplicados = 0\n    para x = 0 hasta len - 1 hacer\n        para y = x + 1 hasta len - 1 hacer\n            si array[x] == array[y] entonces\n                totalDuplicados = totalDuplicados + 1\n            fin si\n        fin para\n    fin para\n    retornar totalDuplicados\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_1",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion buscar(arreglo, n, objetivo)\n    para i desde 0 hasta n-1\n        si arreglo[i] == objetivo entonces\n            retornar i\n        fin si\n    fin para\n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_2",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion busquedaLineal(lista, tamaño, valorBuscado)\n    indice = 0\n    mientras indice < tamaño hacer\n        si lista[indice] == valorBuscado entonces\n            retornar indice\n        fin si\n        indice = indice + 1\n    fin mientras\n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_3",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "// Búsqueda secuencial con bandera\nfuncion encontrarElemento(datos, longitud, elemento)\n    encontrado = falso\n    posicion = 0\n    \n    para pos desde 0 hasta longitud-1\n        si datos[pos] == elemento entonces\n            encontrado = verdadero\n            posicion = pos\n        fin si\n    fin para\n    \n    si encontrado entonces\n        retornar posicion\n    sino\n        retornar -1\n    fin si\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_4",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion buscarSecuencial(vector, tam, x)\n    i = 0\n    mientras i < tam hacer\n        si vector[i] == x entonces\n            retornar i\n        sino\n            i = i + 1\n        fin si\n    fin mientras\n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_5",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "// Retorna verdadero si encuentra el elemento\nfuncion existeEnArreglo(A, numElementos, valorABuscar)\n    para k desde 0 hasta numElementos-1\n        si A[k] == valorABuscar entonces\n            retornar verdadero\n        fin si\n    fin para\n    retornar falso\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_6",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion busquedaSimple(coleccion, cantidad, clave)\n    contador = 0\n    repetir\n        si coleccion[contador] == clave entonces\n            retornar contador\n        fin si\n        contador = contador + 1\n    hasta que contador >= cantidad\n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_7",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion localizarValor(array, dimension, valor)\n    resultado = -1\n    idx = 0\n    \n    mientras idx < dimension y resultado == -1 hacer\n        si array[idx] == valor entonces\n            resultado = idx\n        fin si\n        idx = idx + 1\n    fin mientras\n    \n    retornar resultado\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_8",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "// Búsqueda con retorno inmediato\nfuncion hallarPosicion(secuencia, largo, objetivo)\n    para j desde 0 hasta largo-1\n        si secuencia[j] == objetivo entonces\n            retornar j\n        fin si\n    fin para\n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_9",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion buscarEnLista(L, N, elem)\n    posActual = 0\n    \n    mientras posActual < N hacer\n        elementoActual = L[posActual]\n        si elementoActual == elem entonces\n            retornar posActual\n        fin si\n        posActual = posActual + 1\n    fin mientras\n    \n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_10",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion busquedaIterativa(matriz, total, item)\n    para indice desde 0 hasta total-1\n        si matriz[indice] == item entonces\n            retornar indice\n        fin si\n    fin para\n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_11",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "// Búsqueda con contador de comparaciones\nfuncion buscarConContador(arr, size, target)\n    comparaciones = 0\n    \n    para p desde 0 hasta size-1\n        comparaciones = comparaciones + 1\n        si arr[p] == target entonces\n            retornar p\n        fin si\n    fin para\n    \n    retornar -1\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "iterativo_busqueda_secuencial_12",
    "categoria": "iterativo",
    "subcategoria": "busqueda_secuencial",
    "pseudocodigo": "funcion busquedaSecuencialBasica(elementos, numeroElementos, valorObjetivo)\n    ubicacion = -1\n    control = 0\n    \n    mientras control < numeroElementos hacer\n        si elementos[control] == valorObjetivo entonces\n            ubicacion = control\n            control = numeroElementos\n        sino\n            control = control + 1\n        fin si\n    fin mientras\n    \n    retornar ubicacion\nfin funcion",
    "label": "iterativo"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_1",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion fibonacci(n)\n    si n <= 1 entonces\n        retornar n\n    fin si\n    \n    crear arreglo memo de tamaño n+1\n    memo[0] = 0\n    memo[1] = 1\n    \n    para i desde 2 hasta n hacer\n        memo[i] = memo[i-1] + memo[i-2]\n    fin para\n    \n    retornar memo[n]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_2",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion calcularFib(numero)\n    // Caso base\n    si numero es 0 retornar 0\n    si numero es 1 retornar 1\n    \n    // Crear tabla de memoización\n    tabla = nuevo arreglo[numero + 1]\n    tabla[0] = 0\n    tabla[1] = 1\n    \n    indice = 2\n    mientras indice <= numero hacer\n        tabla[indice] = tabla[indice - 1] + tabla[indice - 2]\n        indice = indice + 1\n    fin mientras\n    \n    retornar tabla[numero]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_3",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion fib_dinamico(valor)\n    si valor < 2 entonces\n        retornar valor\n    fin si\n    \n    anterior = 0\n    actual = 1\n    \n    para contador desde 2 hasta valor hacer\n        temporal = actual + anterior\n        anterior = actual\n        actual = temporal\n    fin para\n    \n    retornar actual\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_4",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion obtenerFibonacci(pos)\n    // Validación inicial\n    si pos == 0 entonces retornar 0\n    si pos == 1 entonces retornar 1\n    \n    // Inicializar array dinámico\n    dp = arreglo de tamaño pos+1\n    dp[0] = 0\n    dp[1] = 1\n    \n    // Llenar tabla bottom-up\n    para j = 2 hasta pos hacer\n        dp[j] = dp[j-1] + dp[j-2]\n    fin para\n    \n    retornar dp[pos]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_5",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion fibonacciOptimizado(limite)\n    si limite <= 1 entonces\n        retornar limite\n    fin si\n    \n    previo = 0\n    siguiente = 1\n    resultado = 0\n    \n    iterador = 2\n    mientras iterador <= limite hacer\n        resultado = previo + siguiente\n        previo = siguiente\n        siguiente = resultado\n        iterador = iterador + 1\n    fin mientras\n    \n    retornar resultado\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_6",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion calcular_fibonacci_dp(termino)\n    // Manejo de casos triviales\n    si termino es igual a 0 retornar 0\n    si termino es igual a 1 retornar 1\n    \n    // Crear estructura de almacenamiento\n    cache = nuevo arreglo de longitud termino+1\n    cache[0] = 0\n    cache[1] = 1\n    \n    // Computar valores iterativamente\n    para posicion desde 2 hasta termino hacer\n        cache[posicion] = cache[posicion-1] + cache[posicion-2]\n    fin para\n    \n    retornar cache[termino]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_7",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion fibo(num)\n    si num < 2 entonces retornar num\n    \n    a = 0\n    b = 1\n    c = 0\n    \n    para i desde 2 hasta num hacer\n        c = a + b\n        a = b\n        b = c\n    fin para\n    \n    retornar c\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_8",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion secuenciaFibonacci(objetivo)\n    // Verificar entrada básica\n    si objetivo <= 0 entonces retornar 0\n    si objetivo == 1 entonces retornar 1\n    \n    // Inicializar variables de trabajo\n    primerValor = 0\n    segundoValor = 1\n    \n    // Iterar hasta alcanzar objetivo\n    cont = 2\n    mientras cont <= objetivo hacer\n        suma = primerValor + segundoValor\n        primerValor = segundoValor\n        segundoValor = suma\n        cont = cont + 1\n    fin mientras\n    \n    retornar segundoValor\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_9",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion fibonacci_memoizado(entrada)\n    si entrada es 0 o entrada es 1 entonces\n        retornar entrada\n    fin si\n    \n    almacen = arreglo[entrada + 1]\n    almacen[0] = 0\n    almacen[1] = 1\n    \n    idx = 2\n    mientras idx <= entrada hacer\n        almacen[idx] = almacen[idx - 1] + almacen[idx - 2]\n        idx = idx + 1\n    fin mientras\n    \n    retornar almacen[entrada]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_fibonacci_dp_10",
    "categoria": "programacion_dinamica",
    "subcategoria": "fibonacci_dp",
    "pseudocodigo": "funcion fibDP(n_termino)\n    // Casos base directos\n    si n_termino <= 1 entonces\n        retornar n_termino\n    fin si\n    \n    // Variables para optimización de espacio\n    fib_anterior = 0\n    fib_actual = 1\n    fib_nuevo = 0\n    \n    // Calcular iterativamente\n    para paso desde 2 hasta n_termino hacer\n        fib_nuevo = fib_anterior + fib_actual\n        fib_anterior = fib_actual\n        fib_actual = fib_nuevo\n    fin para\n    \n    retornar fib_nuevo\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_1",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion mochila(pesos, valores, capacidad, n)\n    crear tabla[n+1][capacidad+1]\n    \n    para i desde 0 hasta n hacer\n        para w desde 0 hasta capacidad hacer\n            si i == 0 o w == 0 entonces\n                tabla[i][w] = 0\n            sino si pesos[i-1] <= w entonces\n                tabla[i][w] = maximo(valores[i-1] + tabla[i-1][w-pesos[i-1]], tabla[i-1][w])\n            sino\n                tabla[i][w] = tabla[i-1][w]\n            fin si\n        fin para\n    fin para\n    \n    retornar tabla[n][capacidad]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_2",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion resolver_knapsack(w, v, W, items)\n    // Inicializar matriz de programacion dinamica\n    dp = matriz[items+1][W+1] con ceros\n    \n    para item desde 1 hasta items hacer\n        para peso_actual desde 1 hasta W hacer\n            si w[item-1] > peso_actual entonces\n                dp[item][peso_actual] = dp[item-1][peso_actual]\n            sino\n                opcion1 = dp[item-1][peso_actual]\n                opcion2 = v[item-1] + dp[item-1][peso_actual - w[item-1]]\n                dp[item][peso_actual] = max(opcion1, opcion2)\n            fin si\n        fin para\n    fin para\n    \n    retornar dp[items][W]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_3",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion mochila_01(peso_max, lista_pesos, lista_valores, cantidad)\n    M = arreglo_2d[cantidad+1][peso_max+1]\n    \n    para fila desde 0 hasta cantidad hacer\n        M[fila][0] = 0\n    fin para\n    \n    para col desde 0 hasta peso_max hacer\n        M[0][col] = 0\n    fin para\n    \n    para i desde 1 hasta cantidad hacer\n        para p desde 1 hasta peso_max hacer\n            si lista_pesos[i-1] <= p entonces\n                incluir = lista_valores[i-1] + M[i-1][p - lista_pesos[i-1]]\n                excluir = M[i-1][p]\n                M[i][p] = maximo(incluir, excluir)\n            sino\n                M[i][p] = M[i-1][p]\n            fin si\n        fin para\n    fin para\n    \n    retornar M[cantidad][peso_max]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_4",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion optimizar_mochila(capacidad_maxima, objetos, num_objetos)\n    memo = nueva_matriz(num_objetos + 1, capacidad_maxima + 1)\n    \n    para cada i en rango(0, num_objetos + 1) hacer\n        para cada cap en rango(0, capacidad_maxima + 1) hacer\n            si i es 0 o cap es 0 entonces\n                memo[i][cap] = 0\n            sino\n                peso_obj = objetos[i-1].peso\n                valor_obj = objetos[i-1].valor\n                \n                si peso_obj > cap entonces\n                    memo[i][cap] = memo[i-1][cap]\n                sino\n                    con_objeto = valor_obj + memo[i-1][cap - peso_obj]\n                    sin_objeto = memo[i-1][cap]\n                    memo[i][cap] = mayor_entre(con_objeto, sin_objeto)\n                fin si\n            fin si\n        fin para\n    fin para\n    \n    retornar memo[num_objetos][capacidad_maxima]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_5",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion knapsack_dinamico(W_max, pesos_arr, valores_arr, n_elementos)\n    tabla_dp = crear_matriz(n_elementos+1, W_max+1, valor_inicial=0)\n    \n    para elem desde 1 hasta n_elementos hacer\n        para capacidad desde 0 hasta W_max hacer\n            valor_sin_tomar = tabla_dp[elem-1][capacidad]\n            \n            si pesos_arr[elem-1] <= capacidad entonces\n                valor_tomando = valores_arr[elem-1] + tabla_dp[elem-1][capacidad - pesos_arr[elem-1]]\n                tabla_dp[elem][capacidad] = max(valor_sin_tomar, valor_tomando)\n            sino\n                tabla_dp[elem][capacidad] = valor_sin_tomar\n            fin si\n        fin para\n    fin para\n    \n    retornar tabla_dp[n_elementos][W_max]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_6",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion problema_mochila(C, P, V, N)\n    // C: capacidad, P: pesos, V: valores, N: numero de items\n    DP = arreglo[N+1][C+1]\n    \n    inicializar DP con ceros\n    \n    para i desde 1 hasta N hacer\n        para j desde 1 hasta C hacer\n            DP[i][j] = DP[i-1][j]\n            \n            si P[i-1] <= j entonces\n                valor_alternativo = V[i-1] + DP[i-1][j - P[i-1]]\n                si valor_alternativo > DP[i][j] entonces\n                    DP[i][j] = valor_alternativo\n                fin si\n            fin si\n        fin para\n    fin para\n    \n    retornar DP[N][C]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_7",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion calcular_mochila_optima(limite_peso, array_w, array_v, total_items)\n    solucion = matriz_2d(total_items+1, limite_peso+1)\n    \n    para x desde 0 hasta total_items hacer\n        solucion[x][0] = 0\n    fin para\n    \n    para y desde 0 hasta limite_peso hacer\n        solucion[0][y] = 0\n    fin para\n    \n    para indice desde 1 hasta total_items hacer\n        para peso_restante desde 1 hasta limite_peso hacer\n            peso_item_actual = array_w[indice-1]\n            valor_item_actual = array_v[indice-1]\n            \n            si peso_item_actual > peso_restante entonces\n                solucion[indice][peso_restante] = solucion[indice-1][peso_restante]\n            sino\n                tomar = valor_item_actual + solucion[indice-1][peso_restante - peso_item_actual]\n                no_tomar = solucion[indice-1][peso_restante]\n                solucion[indice][peso_restante] = seleccionar_maximo(tomar, no_tomar)\n            fin si\n        fin para\n    fin para\n    \n    retornar solucion[total_items][limite_peso]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_8",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion mochila_pd(cap, w_list, v_list, size)\n    T = tabla[size+1][cap+1]\n    \n    para r desde 0 hasta size hacer\n        para c desde 0 hasta cap hacer\n            si r == 0 o c == 0 entonces\n                T[r][c] = 0\n                continuar\n            fin si\n            \n            peso_elemento = w_list[r-1]\n            valor_elemento = v_list[r-1]\n            \n            si peso_elemento <= c entonces\n                beneficio_con_item = valor_elemento + T[r-1][c - peso_elemento]\n                beneficio_sin_item = T[r-1][c]\n                T[r][c] = maximo_de(beneficio_con_item, beneficio_sin_item)\n            sino\n                T[r][c] = T[r-1][c]\n            fin si\n        fin para\n    fin para\n    \n    retornar T[size][cap]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_9",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion resolver_problema_mochila(peso_limite, pesos, beneficios, cantidad_objetos)\n    mat = nueva_matriz_dinamica(cantidad_objetos+1, peso_limite+1)\n    \n    rellenar mat con 0\n    \n    para obj desde 1 hasta cantidad_objetos hacer\n        para cap_actual desde 1 hasta peso_limite hacer\n            peso_obj = pesos[obj-1]\n            benef_obj = beneficios[obj-1]\n            mejor_anterior = mat[obj-1][cap_actual]\n            \n            si peso_obj > cap_actual entonces\n                mat[obj][cap_actual] = mejor_anterior\n            sino\n                con_actual = benef_obj + mat[obj-1][cap_actual - peso_obj]\n                mat[obj][cap_actual] = maximo(con_actual, mejor_anterior)\n            fin si\n        fin para\n    fin para\n    \n    resultado = mat[cantidad_objetos][peso_limite]\n    retornar resultado\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_mochila_10",
    "categoria": "programacion_dinamica",
    "subcategoria": "mochila",
    "pseudocodigo": "funcion knapsack_programacion_dinamica(W, weights, profits, n)\n    // Crear estructura de datos para almacenar resultados\n    K = arreglo_bidimensional[n+1][W+1]\n    \n    // Inicializacion de casos base\n    para i desde 0 hasta n hacer\n        K[i][0] = 0\n    fin para\n    para j desde 0 hasta W hacer\n        K[0][j] = 0\n    fin para\n    \n    // Llenar la tabla de forma ascendente\n    para item desde 1 hasta n hacer\n        para capacidad desde 1 hasta W hacer\n            peso_actual = weights[item-1]\n            ganancia_actual = profits[item-1]\n            \n            si peso_actual <= capacidad entonces\n                valor_incluyendo = ganancia_actual + K[item-1][capacidad - peso_actual]\n                valor_excluyendo = K[item-1][capacidad]\n                \n                si valor_incluyendo > valor_excluyendo entonces\n                    K[item][capacidad] = valor_incluyendo\n                sino\n                    K[item][capacidad] = valor_excluyendo\n                fin si\n            sino\n                K[item][capacidad] = K[item-1][capacidad]\n            fin si\n        fin para\n    fin para\n    \n    retornar K[n][W]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_1",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion LCS(cadena1, cadena2)\n    n = longitud(cadena1)\n    m = longitud(cadena2)\n    crear matriz[n+1][m+1]\n    \n    para i desde 0 hasta n hacer\n        para j desde 0 hasta m hacer\n            si i == 0 o j == 0 entonces\n                matriz[i][j] = 0\n            sino si cadena1[i-1] == cadena2[j-1] entonces\n                matriz[i][j] = matriz[i-1][j-1] + 1\n            sino\n                matriz[i][j] = maximo(matriz[i-1][j], matriz[i][j-1])\n            fin si\n        fin para\n    fin para\n    \n    retornar matriz[n][m]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_2",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion subsecuenciaComun(texto_a, texto_b)\n    tam_a = tamaño(texto_a)\n    tam_b = tamaño(texto_b)\n    tabla = nueva_matriz(tam_a + 1, tam_b + 1)\n    \n    para fila desde 1 hasta tam_a hacer\n        para columna desde 1 hasta tam_b hacer\n            si texto_a[fila - 1] coincide con texto_b[columna - 1] entonces\n                tabla[fila][columna] = tabla[fila - 1][columna - 1] + 1\n            sino\n                tabla[fila][columna] = max(tabla[fila - 1][columna], tabla[fila][columna - 1])\n            fin si\n        fin para\n    fin para\n    \n    retornar tabla[tam_a][tam_b]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_3",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion calcularLCS(s1, s2)\n    // Inicializar dimensiones\n    largo1 = len(s1)\n    largo2 = len(s2)\n    \n    // Crear tabla DP\n    dp = arreglo_2d(largo1 + 1, largo2 + 1, valor_inicial = 0)\n    \n    // Llenar la tabla\n    para idx1 desde 1 hasta largo1 hacer\n        para idx2 desde 1 hasta largo2 hacer\n            si s1[idx1 - 1] == s2[idx2 - 1] entonces\n                dp[idx1][idx2] = dp[idx1 - 1][idx2 - 1] + 1\n            sino\n                dp[idx1][idx2] = maximo_entre(dp[idx1 - 1][idx2], dp[idx1][idx2 - 1])\n            fin si\n        fin para\n    fin para\n    \n    retornar dp[largo1][largo2]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_4",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion longitudSubsecuencia(secuencia_x, secuencia_y)\n    filas = longitud(secuencia_x)\n    columnas = longitud(secuencia_y)\n    memoria = inicializar_matriz(filas + 1, columnas + 1)\n    \n    para cada i en rango(0, filas) hacer\n        memoria[i][0] = 0\n    fin para\n    \n    para cada j en rango(0, columnas) hacer\n        memoria[0][j] = 0\n    fin para\n    \n    para i desde 1 hasta filas hacer\n        para j desde 1 hasta columnas hacer\n            si secuencia_x[i - 1] es_igual secuencia_y[j - 1] entonces\n                memoria[i][j] = memoria[i - 1][j - 1] + 1\n            sino\n                memoria[i][j] = mayor(memoria[i - 1][j], memoria[i][j - 1])\n            fin si\n        fin para\n    fin para\n    \n    retornar memoria[filas][columnas]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_5",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion encontrarLCS(palabra1, palabra2)\n    dimension1 = tamaño_de(palabra1)\n    dimension2 = tamaño_de(palabra2)\n    \n    tablero = crear_matriz_vacia(dimension1 + 1, dimension2 + 1)\n    \n    para x desde 0 hasta dimension1 hacer\n        tablero[x][0] = 0\n    fin para\n    \n    para y desde 0 hasta dimension2 hacer\n        tablero[0][y] = 0\n    fin para\n    \n    para x desde 1 hasta dimension1 hacer\n        para y desde 1 hasta dimension2 hacer\n            si palabra1[x - 1] == palabra2[y - 1] entonces\n                tablero[x][y] = tablero[x - 1][y - 1] + 1\n            sino\n                tablero[x][y] = max(tablero[x - 1][y], tablero[x][y - 1])\n            fin si\n        fin para\n    fin para\n    \n    retornar tablero[dimension1][dimension2]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_6",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion LCS_longitud(str_primero, str_segundo)\n    len_primero = contar_caracteres(str_primero)\n    len_segundo = contar_caracteres(str_segundo)\n    \n    cache = matriz_nueva((len_primero + 1) x (len_segundo + 1))\n    \n    inicializar cache con ceros\n    \n    para posicion_i desde 1 hasta len_primero hacer\n        para posicion_j desde 1 hasta len_segundo hacer\n            caracter_i = str_primero[posicion_i - 1]\n            caracter_j = str_segundo[posicion_j - 1]\n            \n            si caracter_i == caracter_j entonces\n                cache[posicion_i][posicion_j] = cache[posicion_i - 1][posicion_j - 1] + 1\n            sino\n                opcion1 = cache[posicion_i - 1][posicion_j]\n                opcion2 = cache[posicion_i][posicion_j - 1]\n                cache[posicion_i][posicion_j] = maximo(opcion1, opcion2)\n            fin si\n        fin para\n    fin para\n    \n    retornar cache[len_primero][len_segundo]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_7",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion subsecuencia_mas_larga(A, B)\n    // Obtener longitudes\n    N = tamaño(A)\n    M = tamaño(B)\n    \n    // Tabla de programación dinámica\n    L = nueva_tabla(N + 1, M + 1)\n    \n    // Rellenar primera fila y columna\n    para i desde 0 hasta N hacer\n        L[i][0] = 0\n    fin para\n    para j desde 0 hasta M hacer\n        L[0][j] = 0\n    fin para\n    \n    // Proceso principal\n    para i desde 1 hasta N hacer\n        para j desde 1 hasta M hacer\n            si A[i - 1] coincide_con B[j - 1] entonces\n                L[i][j] = L[i - 1][j - 1] + 1\n            sino\n                L[i][j] = maximo_de(L[i - 1][j], L[i][j - 1])\n            fin si\n        fin para\n    fin para\n    \n    retornar L[N][M]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_8",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion computar_LCS(entrada1, entrada2)\n    size1 = obtener_longitud(entrada1)\n    size2 = obtener_longitud(entrada2)\n    grid = construir_matriz(size1 + 1, size2 + 1)\n    \n    para r desde 0 hasta size1 hacer\n        para c desde 0 hasta size2 hacer\n            si r == 0 o c == 0 entonces\n                grid[r][c] = 0\n                continuar\n            fin si\n            \n            si entrada1[r - 1] == entrada2[c - 1] entonces\n                grid[r][c] = grid[r - 1][c - 1] + 1\n            sino\n                valor_arriba = grid[r - 1][c]\n                valor_izquierda = grid[r][c - 1]\n                grid[r][c] = seleccionar_mayor(valor_arriba, valor_izquierda)\n            fin si\n        fin para\n    fin para\n    \n    resultado = grid[size1][size2]\n    retornar resultado\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_9",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion hallar_longitud_comun(cadena_uno, cadena_dos)\n    n1 = cantidad_elementos(cadena_uno)\n    n2 = cantidad_elementos(cadena_dos)\n    \n    mat = arreglo_bidimensional[n1 + 1][n2 + 1]\n    \n    para indice_i desde 0 hasta n1 hacer\n        mat[indice_i][0] = 0\n    fin para\n    \n    para indice_j desde 0 hasta n2 hacer\n        mat[0][indice_j] = 0\n    fin para\n    \n    para indice_i desde 1 hasta n1 hacer\n        para indice_j desde 1 hasta n2 hacer\n            elemento_i = cadena_uno[indice_i - 1]\n            elemento_j = cadena_dos[indice_j - 1]\n            \n            si elemento_i es_igual_a elemento_j entonces\n                mat[indice_i][indice_j] = mat[indice_i - 1][indice_j - 1] + 1\n            sino\n                mat[indice_i][indice_j] = max(mat[indice_i - 1][indice_j], mat[indice_i][indice_j - 1])\n            fin si\n        fin para\n    fin para\n    \n    retornar mat[n1][n2]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_lcs_10",
    "categoria": "programacion_dinamica",
    "subcategoria": "lcs",
    "pseudocodigo": "funcion LCS_dinamico(seq_a, seq_b)\n    // Determinar tamaños de secuencias\n    largo_a = medir(seq_a)\n    largo_b = medir(seq_b)\n    \n    // Construir estructura de datos\n    estructura = generar_tabla(largo_a + 1, largo_b + 1)\n    \n    // Inicialización de bordes\n    para p desde 0 hasta largo_a hacer\n        estructura[p][0] = 0\n    fin para\n    para q desde 0 hasta largo_b hacer\n        estructura[0][q] = 0\n    fin para\n    \n    // Algoritmo de llenado\n    para p desde 1 hasta largo_a hacer\n        para q desde 1 hasta largo_b hacer\n            si seq_a[p - 1] == seq_b[q - 1] entonces\n                estructura[p][q] = estructura[p - 1][q - 1] + 1\n            sino\n                val_superior = estructura[p - 1][q]\n                val_lateral = estructura[p][q - 1]\n                estructura[p][q] = elegir_maximo(val_superior, val_lateral)\n            fin si\n        fin para\n    fin para\n    \n    longitud_final = estructura[largo_a][largo_b]\n    retornar longitud_final\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_1",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion subsecuenciaComun(texto1, texto2)\n    n = longitud(texto1)\n    m = longitud(texto2)\n    tabla = matriz[n+1][m+1]\n    \n    para i desde 0 hasta n hacer\n        para j desde 0 hasta m hacer\n            si i == 0 o j == 0 entonces\n                tabla[i][j] = 0\n            sino si texto1[i-1] == texto2[j-1] entonces\n                tabla[i][j] = tabla[i-1][j-1] + 1\n            sino\n                tabla[i][j] = maximo(tabla[i-1][j], tabla[i][j-1])\n            fin si\n        fin para\n    fin para\n    \n    retornar tabla[n][m]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_2",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion LCS(cadenaA, cadenaB)\n    tamA = tamaño(cadenaA)\n    tamB = tamaño(cadenaB)\n    dp = crear_matriz(tamA + 1, tamB + 1, 0)\n    \n    para fila desde 1 hasta tamA hacer\n        para col desde 1 hasta tamB hacer\n            si cadenaA[fila - 1] == cadenaB[col - 1] entonces\n                dp[fila][col] = dp[fila - 1][col - 1] + 1\n            sino\n                dp[fila][col] = max(dp[fila - 1][col], dp[fila][col - 1])\n            fin si\n        fin para\n    fin para\n    \n    retornar dp[tamA][tamB]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_3",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion longitudSubsecuencia(s1, s2)\n    largo1 = len(s1)\n    largo2 = len(s2)\n    memo = arreglo2D[largo1 + 1][largo2 + 1]\n    \n    inicializar memo con ceros\n    \n    i = 1\n    mientras i <= largo1 hacer\n        j = 1\n        mientras j <= largo2 hacer\n            si s1[i-1] == s2[j-1] entonces\n                memo[i][j] = memo[i-1][j-1] + 1\n            sino\n                memo[i][j] = mayor(memo[i-1][j], memo[i][j-1])\n            fin si\n            j = j + 1\n        fin mientras\n        i = i + 1\n    fin mientras\n    \n    retornar memo[largo1][largo2]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_4",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion calcularLCS(palabra1, palabra2)\n    filas = longitud(palabra1)\n    columnas = longitud(palabra2)\n    matrizDP = nueva_matriz(filas + 1, columnas + 1)\n    \n    para cada i en rango(0, filas + 1) hacer\n        matrizDP[i][0] = 0\n    fin para\n    \n    para cada j en rango(0, columnas + 1) hacer\n        matrizDP[0][j] = 0\n    fin para\n    \n    para i desde 1 hasta filas hacer\n        para j desde 1 hasta columnas hacer\n            si palabra1[i-1] == palabra2[j-1] entonces\n                matrizDP[i][j] = 1 + matrizDP[i-1][j-1]\n            sino\n                matrizDP[i][j] = maximo(matrizDP[i-1][j], matrizDP[i][j-1])\n            fin si\n        fin para\n    fin para\n    \n    retornar matrizDP[filas][columnas]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_5",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion subsecuenciaMasLarga(str1, str2)\n    n1 = tamaño(str1)\n    n2 = tamaño(str2)\n    \n    cache = matriz_vacia(n1 + 1, n2 + 1)\n    \n    para x desde 0 hasta n1 hacer\n        cache[x][0] = 0\n    fin para\n    \n    para y desde 0 hasta n2 hacer\n        cache[0][y] = 0\n    fin para\n    \n    para x desde 1 hasta n1 hacer\n        para y desde 1 hasta n2 hacer\n            si str1[x - 1] == str2[y - 1] entonces\n                cache[x][y] = cache[x - 1][y - 1] + 1\n            sino\n                opcion1 = cache[x - 1][y]\n                opcion2 = cache[x][y - 1]\n                cache[x][y] = max(opcion1, opcion2)\n            fin si\n        fin para\n    fin para\n    \n    retornar cache[n1][n2]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_6",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion encontrarLCS(secuencia1, secuencia2)\n    len1 = longitud(secuencia1)\n    len2 = longitud(secuencia2)\n    tablaDinamica = crearMatriz(len1 + 1, len2 + 1)\n    \n    inicializarMatrizEnCero(tablaDinamica)\n    \n    indice1 = 1\n    mientras indice1 <= len1 hacer\n        indice2 = 1\n        mientras indice2 <= len2 hacer\n            caracterCoincide = (secuencia1[indice1 - 1] == secuencia2[indice2 - 1])\n            \n            si caracterCoincide entonces\n                tablaDinamica[indice1][indice2] = tablaDinamica[indice1 - 1][indice2 - 1] + 1\n            sino\n                valorArriba = tablaDinamica[indice1 - 1][indice2]\n                valorIzquierda = tablaDinamica[indice1][indice2 - 1]\n                tablaDinamica[indice1][indice2] = maximo(valorArriba, valorIzquierda)\n            fin si\n            \n            indice2 = indice2 + 1\n        fin mientras\n        indice1 = indice1 + 1\n    fin mientras\n    \n    retornar tablaDinamica[len1][len2]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_7",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion LCSLongitud(A, B)\n    m = longitud(A)\n    n = longitud(B)\n    L = matriz[m+1][n+1]\n    \n    para i desde 0 hasta m hacer\n        para j desde 0 hasta n hacer\n            si i == 0 o j == 0 entonces\n                L[i][j] = 0\n            sino\n                si A[i-1] == B[j-1] entonces\n                    L[i][j] = L[i-1][j-1] + 1\n                sino\n                    L[i][j] = max(L[i-1][j], L[i][j-1])\n                fin si\n            fin si\n        fin para\n    fin para\n    \n    retornar L[m][n]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_8",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion subsecuenciaOptima(cad1, cad2)\n    dimension1 = tamaño(cad1)\n    dimension2 = tamaño(cad2)\n    \n    matrizResultados = crearMatrizCeros(dimension1 + 1, dimension2 + 1)\n    \n    para pos1 desde 1 hasta dimension1 hacer\n        para pos2 desde 1 hasta dimension2 hacer\n            caracterActual1 = cad1[pos1 - 1]\n            caracterActual2 = cad2[pos2 - 1]\n            \n            si caracterActual1 == caracterActual2 entonces\n                matrizResultados[pos1][pos2] = matrizResultados[pos1 - 1][pos2 - 1] + 1\n            sino\n                valorSuperior = matrizResultados[pos1 - 1][pos2]\n                valorIzquierdo = matrizResultados[pos1][pos2 - 1]\n                \n                si valorSuperior > valorIzquierdo entonces\n                    matrizResultados[pos1][pos2] = valorSuperior\n                sino\n                    matrizResultados[pos1][pos2] = valorIzquierdo\n                fin si\n            fin si\n        fin para\n    fin para\n    \n    retornar matrizResultados[dimension1][dimension2]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_9",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion longitudComunMaxima(entrada1, entrada2)\n    tam1 = contar_caracteres(entrada1)\n    tam2 = contar_caracteres(entrada2)\n    \n    dp_tabla = nueva_matriz(tam1 + 1, tam2 + 1)\n    \n    para r desde 0 hasta tam1 hacer\n        dp_tabla[r][0] = 0\n    fin para\n    \n    para c desde 0 hasta tam2 hacer\n        dp_tabla[0][c] = 0\n    fin para\n    \n    r = 1\n    mientras r <= tam1 hacer\n        c = 1\n        mientras c <= tam2 hacer\n            si entrada1[r - 1] == entrada2[c - 1] entonces\n                dp_tabla[r][c] = dp_tabla[r - 1][c - 1] + 1\n            sino\n                val1 = dp_tabla[r - 1][c]\n                val2 = dp_tabla[r][c - 1]\n                dp_tabla[r][c] = maximo_entre(val1, val2)\n            fin si\n            c = c + 1\n        fin mientras\n        r = r + 1\n    fin mientras\n    \n    resultado = dp_tabla[tam1][tam2]\n    retornar resultado\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "programacion_dinamica_subsecuencia_10",
    "categoria": "programacion_dinamica",
    "subcategoria": "subsecuencia",
    "pseudocodigo": "funcion calcularSubsecuencia(X, Y)\n    longitudX = tamaño(X)\n    longitudY = tamaño(Y)\n    \n    matrizC = inicializar_matriz(longitudX + 1, longitudY + 1, 0)\n    \n    para idx_i desde 1 hasta longitudX hacer\n        para idx_j desde 1 hasta longitudY hacer\n            elemento_X = X[idx_i - 1]\n            elemento_Y = Y[idx_j - 1]\n            \n            si elemento_X == elemento_Y entonces\n                matrizC[idx_i][idx_j] = matrizC[idx_i - 1][idx_j - 1] + 1\n            sino\n                candidato_arriba = matrizC[idx_i - 1][idx_j]\n                candidato_izq = matrizC[idx_i][idx_j - 1]\n                matrizC[idx_i][idx_j] = seleccionar_maximo(candidato_arriba, candidato_izq)\n            fin si\n        fin para\n    fin para\n    \n    retornar matrizC[longitudX][longitudY]\nfin funcion",
    "label": "programacion_dinamica"
  },
  {
    "id": "greedy_cambio_monedas_1",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion cambioMonedas(cantidad, denominaciones)\n    resultado = []\n    ordenarDescendente(denominaciones)\n    para cada moneda en denominaciones hacer\n        mientras cantidad >= moneda hacer\n            resultado.agregar(moneda)\n            cantidad = cantidad - moneda\n        fin mientras\n    fin para\n    retornar resultado\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_2",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion calcularCambio(monto)\n    // Denominaciones fijas: 100, 50, 25, 10, 5, 1\n    monedas = [100, 50, 25, 10, 5, 1]\n    cambio = []\n    indice = 0\n    mientras monto > 0 hacer\n        si monto >= monedas[indice] entonces\n            monto = monto - monedas[indice]\n            cambio.agregar(monedas[indice])\n        sino\n            indice = indice + 1\n        fin si\n    fin mientras\n    retornar cambio\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_3",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion devolverCambioOptimo(valorTotal, listaValores)\n    contadorMonedas = 0\n    posicion = 0\n    temp = valorTotal\n    mientras temp > 0 y posicion < longitud(listaValores) hacer\n        si temp >= listaValores[posicion] entonces\n            temp = temp - listaValores[posicion]\n            contadorMonedas = contadorMonedas + 1\n        sino\n            posicion = posicion + 1\n        fin si\n    fin mientras\n    retornar contadorMonedas\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_4",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion greedy_cambio(n, coins)\n    solucion = diccionario_vacio()\n    coins.ordenar(reverso=verdadero)\n    para i desde 0 hasta longitud(coins)-1 hacer\n        cantidad_monedas = n dividido_entero coins[i]\n        si cantidad_monedas > 0 entonces\n            solucion[coins[i]] = cantidad_monedas\n            n = n modulo coins[i]\n        fin si\n    fin para\n    retornar solucion\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_5",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion obtenerCambioMinimo(dinero, arrayDenominaciones)\n    respuesta = lista_vacia()\n    arrayDenominaciones = ordenar_mayor_a_menor(arrayDenominaciones)\n    restante = dinero\n    para cada valor en arrayDenominaciones hacer\n        repetir mientras restante >= valor\n            respuesta.añadir(valor)\n            restante = restante - valor\n        fin repetir\n    fin para\n    si restante == 0 entonces\n        retornar respuesta\n    sino\n        retornar \"No es posible dar cambio exacto\"\n    fin si\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_6",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion cambioGreedy(importe)\n    billetes = [200, 100, 50, 20, 10, 5, 2, 1]\n    desglose = []\n    idx = 0\n    mientras importe > 0 hacer\n        numBilletes = importe dividido_entero billetes[idx]\n        para j desde 1 hasta numBilletes hacer\n            desglose.agregar(billetes[idx])\n        fin para\n        importe = importe modulo billetes[idx]\n        idx = idx + 1\n    fin mientras\n    retornar desglose\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_7",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion minimoMonedas(cantidad_a_cambiar, vector_monedas)\n    ordenar_descendente(vector_monedas)\n    total_monedas = 0\n    k = 0\n    mientras cantidad_a_cambiar != 0 hacer\n        si vector_monedas[k] <= cantidad_a_cambiar entonces\n            cantidad_a_cambiar = cantidad_a_cambiar - vector_monedas[k]\n            total_monedas = total_monedas + 1\n        sino\n            k = k + 1\n        fin si\n    fin mientras\n    retornar total_monedas\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_8",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion algoritmo_voraz_cambio(suma, conjunto_denominaciones)\n    // Algoritmo voraz para cambio de monedas\n    conjunto_denominaciones.ordenar_decreciente()\n    resultado_final = diccionario()\n    valor_actual = suma\n    \n    para cada denominacion en conjunto_denominaciones hacer\n        si valor_actual >= denominacion entonces\n            cuantas = valor_actual dividido_entero denominacion\n            resultado_final.insertar(denominacion, cuantas)\n            valor_actual = valor_actual - (denominacion * cuantas)\n        fin si\n    fin para\n    \n    retornar resultado_final\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_9",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion repartirCambio(precio, tipos)\n    salida = arreglo_vacio()\n    tipos = invertir_orden(ordenar(tipos))\n    p = 0\n    mientras precio > 0 y p < tamaño(tipos) hacer\n        moneda_actual = tipos[p]\n        si precio >= moneda_actual entonces\n            precio = precio - moneda_actual\n            salida.push(moneda_actual)\n        sino\n            p = p + 1\n        fin si\n    fin mientras\n    retornar salida\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_cambio_monedas_10",
    "categoria": "greedy",
    "subcategoria": "cambio_monedas",
    "pseudocodigo": "funcion cambioOptimo(monto_total, denominaciones_disponibles)\n    lista_cambio = nueva_lista()\n    denominaciones_disponibles = ordenar_forma_descendente(denominaciones_disponibles)\n    \n    para i = 0 hasta longitud(denominaciones_disponibles) - 1 hacer\n        moneda = denominaciones_disponibles[i]\n        mientras monto_total >= moneda hacer\n            lista_cambio.agregar_elemento(moneda)\n            monto_total = monto_total - moneda\n        fin mientras\n    fin para\n    \n    si monto_total == 0 entonces\n        retornar lista_cambio\n    sino\n        retornar nulo\n    fin si\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_1",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion mochilaFraccionaria(pesos, valores, capacidad)\n    n = longitud(pesos)\n    relacion = arreglo de tamaño n\n    \n    para i desde 0 hasta n-1\n        relacion[i] = valores[i] / pesos[i]\n    fin para\n    \n    ordenarDescendente(relacion, pesos, valores)\n    \n    beneficio = 0\n    para i desde 0 hasta n-1\n        si capacidad >= pesos[i] entonces\n            beneficio = beneficio + valores[i]\n            capacidad = capacidad - pesos[i]\n        sino\n            beneficio = beneficio + (relacion[i] * capacidad)\n            capacidad = 0\n            romper\n        fin si\n    fin para\n    \n    retornar beneficio\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_2",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion resolverMochila(W, p, v, numObjetos)\n    // Crear estructura de objetos con valor/peso\n    objetos = nuevo arreglo[numObjetos]\n    \n    para j desde 1 hasta numObjetos\n        objetos[j].peso = p[j]\n        objetos[j].valor = v[j]\n        objetos[j].ratio = v[j] / p[j]\n    fin para\n    \n    ordenarPorRatioDecreciente(objetos)\n    \n    pesoActual = 0\n    gananciaTotal = 0\n    \n    para j desde 1 hasta numObjetos\n        si pesoActual + objetos[j].peso <= W entonces\n            pesoActual = pesoActual + objetos[j].peso\n            gananciaTotal = gananciaTotal + objetos[j].valor\n        sino\n            fraccion = (W - pesoActual) / objetos[j].peso\n            gananciaTotal = gananciaTotal + (objetos[j].valor * fraccion)\n            romper\n        fin si\n    fin para\n    \n    retornar gananciaTotal\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_3",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion mochila_greedy(capacidadMax, arrayPesos, arrayValores)\n    cantidad = tamaño(arrayPesos)\n    densidades = crearArreglo(cantidad)\n    indices = crearArreglo(cantidad)\n    \n    para idx desde 0 hasta cantidad-1\n        densidades[idx] = arrayValores[idx] / arrayPesos[idx]\n        indices[idx] = idx\n    fin para\n    \n    ordenarIndicesPorDensidad(indices, densidades)\n    \n    espacio = capacidadMax\n    resultado = 0\n    i = 0\n    \n    mientras espacio > 0 y i < cantidad\n        posicion = indices[i]\n        si arrayPesos[posicion] <= espacio entonces\n            resultado = resultado + arrayValores[posicion]\n            espacio = espacio - arrayPesos[posicion]\n        sino\n            resultado = resultado + (densidades[posicion] * espacio)\n            espacio = 0\n        fin si\n        i = i + 1\n    fin mientras\n    \n    retornar resultado\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_4",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion optimizarMochila(C, w, v, n)\n    valorPorUnidad = arregloVacio(n)\n    \n    para k desde 0 hasta n-1\n        valorPorUnidad[k] = v[k] / w[k]\n    fin para\n    \n    ordenarDescendentemente(valorPorUnidad, w, v, n)\n    \n    capacidadRestante = C\n    beneficioAcumulado = 0\n    k = 0\n    \n    mientras k < n y capacidadRestante > 0\n        si w[k] <= capacidadRestante entonces\n            beneficioAcumulado = beneficioAcumulado + v[k]\n            capacidadRestante = capacidadRestante - w[k]\n        sino\n            proporcion = capacidadRestante / w[k]\n            beneficioAcumulado = beneficioAcumulado + (v[k] * proporcion)\n            capacidadRestante = 0\n        fin si\n        k = k + 1\n    fin mientras\n    \n    retornar beneficioAcumulado\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_5",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion knapsackFraccionario(limitePeso, masas, beneficios, total)\n    tasas = nuevo arreglo de tamaño total\n    seleccion = nuevo arreglo de tamaño total\n    \n    para elemento desde 0 hasta total-1\n        tasas[elemento] = beneficios[elemento] / masas[elemento]\n        seleccion[elemento] = 0\n    fin para\n    \n    ordenarDecreciente(tasas, masas, beneficios)\n    \n    cargaActual = 0\n    valorFinal = 0\n    elemento = 0\n    \n    mientras elemento < total\n        si cargaActual + masas[elemento] <= limitePeso entonces\n            seleccion[elemento] = 1\n            cargaActual = cargaActual + masas[elemento]\n            valorFinal = valorFinal + beneficios[elemento]\n        sino\n            cantidadDisponible = limitePeso - cargaActual\n            seleccion[elemento] = cantidadDisponible / masas[elemento]\n            valorFinal = valorFinal + (beneficios[elemento] * seleccion[elemento])\n            cargaActual = limitePeso\n        fin si\n        elemento = elemento + 1\n    fin mientras\n    \n    retornar valorFinal\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_6",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion calcularMochilaOptima(pesoMaximo, listaPesos, listaValores)\n    numeroItems = longitud(listaPesos)\n    eficiencia = arreglo[numeroItems]\n    \n    para pos desde 1 hasta numeroItems\n        eficiencia[pos] = listaValores[pos] / listaPesos[pos]\n    fin para\n    \n    ordenarPorEficiencia(eficiencia, listaPesos, listaValores, numeroItems)\n    \n    valorTotal = 0\n    pesoUsado = 0\n    \n    para pos desde 1 hasta numeroItems\n        pesoDisponible = pesoMaximo - pesoUsado\n        \n        si pesoDisponible >= listaPesos[pos] entonces\n            valorTotal = valorTotal + listaValores[pos]\n            pesoUsado = pesoUsado + listaPesos[pos]\n        sino\n            si pesoDisponible > 0 entonces\n                fraccionTomada = pesoDisponible / listaPesos[pos]\n                valorTotal = valorTotal + (listaValores[pos] * fraccionTomada)\n                pesoUsado = pesoMaximo\n            fin si\n        fin si\n    fin para\n    \n    retornar valorTotal\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_7",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion mochila_voraz(cap, P, V, N)\n    R = arreglo de tamaño N\n    O = arreglo de tamaño N\n    \n    para x desde 0 hasta N-1\n        R[x] = V[x] / P[x]\n        O[x] = x\n    fin para\n    \n    ordenarIndicePorRatio(O, R)\n    \n    ganancia = 0\n    peso_actual = 0\n    x = 0\n    \n    mientras x < N\n        indice_original = O[x]\n        \n        si peso_actual + P[indice_original] <= cap entonces\n            ganancia = ganancia + V[indice_original]\n            peso_actual = peso_actual + P[indice_original]\n        sino\n            resto = cap - peso_actual\n            si resto > 0 entonces\n                ganancia = ganancia + (R[indice_original] * resto)\n            fin si\n            peso_actual = cap\n        fin si\n        \n        x = x + 1\n    fin mientras\n    \n    retornar ganancia\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_8",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion solucionMochilaFraccionada(capacidadTotal, vectorPesos, vectorValores, cantidadElementos)\n    // Calcular densidad de valor\n    densidad = nuevoVector(cantidadElementos)\n    para m desde 0 hasta cantidadElementos-1\n        densidad[m] = vectorValores[m] / vectorPesos[m]\n    fin para\n    \n    // Ordenar por densidad mayor a menor\n    burbuja(densidad, vectorPesos, vectorValores, cantidadElementos)\n    \n    // Llenar mochila\n    espacioLibre = capacidadTotal\n    valorObtenido = 0\n    \n    para m desde 0 hasta cantidadElementos-1\n        si espacioLibre = 0 entonces\n            romper\n        fin si\n        \n        si vectorPesos[m] <= espacioLibre entonces\n            valorObtenido = valorObtenido + vectorValores[m]\n            espacioLibre = espacioLibre - vectorPesos[m]\n        sino\n            parteUsada = espacioLibre / vectorPesos[m]\n            valorObtenido = valorObtenido + (vectorValores[m] * parteUsada)\n            espacioLibre = 0\n        fin si\n    fin para\n    \n    retornar valorObtenido\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_9",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion algoritmoMochilaFraccional(W_max, arreglo_p, arreglo_v, num)\n    coeficientes = crearArreglo(num)\n    \n    para t desde 0 hasta num-1\n        coeficientes[t] = arreglo_v[t] / arreglo_p[t]\n    fin para\n    \n    ordenar_descendente(coeficientes, arreglo_p, arreglo_v)\n    \n    peso_restante = W_max\n    valor_acumulado = 0\n    indice = 0\n    \n    mientras indice < num y peso_restante > 0\n        si arreglo_p[indice] <= peso_restante entonces\n            valor_acumulado = valor_acumulado + arreglo_v[indice]\n            peso_restante = peso_restante - arreglo_p[indice]\n        sino\n            fragmento = peso_restante / arreglo_p[indice]\n            valor_acumulado = valor_acumulado + (arreglo_v[indice] * fragmento)\n            peso_restante = 0\n        fin si\n        indice = indice + 1\n    fin mientras\n    \n    retornar valor_acumulado\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_mochila_fraccionaria_10",
    "categoria": "greedy",
    "subcategoria": "mochila_fraccionaria",
    "pseudocodigo": "funcion procesarMochila(limite, pesos, valores, elementos)\n    ratios = nuevo arreglo[elementos]\n    orden = nuevo arreglo[elementos]\n    fracciones = nuevo arreglo[elementos]\n    \n    para z desde 1 hasta elementos\n        ratios[z] = valores[z] / pesos[z]\n        orden[z] = z\n        fracciones[z] = 0\n    fin para\n    \n    ordenarPorRatios(orden, ratios)\n    \n    capacidad_usada = 0\n    beneficio_total = 0\n    \n    para z desde 1 hasta elementos\n        item = orden[z]\n        \n        si capacidad_usada + pesos[item] <= limite entonces\n            fracciones[item] = 1.0\n            capacidad_usada = capacidad_usada + pesos[item]\n            beneficio_total = beneficio_total + valores[item]\n        sino\n            espacio_sobrante = limite - capacidad_usada\n            si espacio_sobrante > 0 entonces\n                fracciones[item] = espacio_sobrante / pesos[item]\n                beneficio_total = beneficio_total + (valores[item] * fracciones[item])\n                capacidad_usada = limite\n            fin si\n        fin si\n        \n        si capacidad_usada >= limite entonces\n            romper\n        fin si\n    fin para\n    \n    retornar beneficio_total\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_1",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion planificar_tareas(tareas)\n    ordenar tareas por beneficio descendente\n    cronograma = lista_vacia\n    tiempo_actual = 0\n    \n    para cada tarea en tareas hacer\n        si tiempo_actual + tarea.duracion <= limite_tiempo entonces\n            agregar tarea a cronograma\n            tiempo_actual = tiempo_actual + tarea.duracion\n        fin si\n    fin para\n    \n    retornar cronograma\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_2",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion seleccionar_actividades(lista_actividades, tiempo_disponible)\n    // Ordenar por ratio beneficio/tiempo\n    para i desde 0 hasta longitud(lista_actividades) hacer\n        lista_actividades[i].ratio = lista_actividades[i].ganancia / lista_actividades[i].tiempo\n    fin para\n    \n    ordenar_descendente(lista_actividades, por_ratio)\n    \n    resultado = []\n    t = 0\n    \n    mientras t < tiempo_disponible y lista_actividades no_vacia hacer\n        act = extraer_primero(lista_actividades)\n        si t + act.tiempo <= tiempo_disponible entonces\n            agregar act a resultado\n            t = t + act.tiempo\n        fin si\n    fin mientras\n    \n    retornar resultado\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_3",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion asignar_trabajos(trabajos)\n    trabajos_ordenados = ordenar_por_prioridad(trabajos)\n    plan = conjunto_vacio\n    hora = 0\n    beneficio_total = 0\n    \n    para j en trabajos_ordenados hacer\n        si hora + j.horas <= 24 entonces\n            insertar j en plan\n            hora = hora + j.horas\n            beneficio_total = beneficio_total + j.valor\n        fin si\n    fin para\n    \n    retornar plan, beneficio_total\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_4",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion optimizar_agenda(eventos, max_duracion)\n    eventos_por_urgencia = clasificar(eventos, urgencia, descendente)\n    agenda_final = crear_lista\n    duracion_acumulada = 0\n    \n    para cada e desde 0 hasta tamaño(eventos_por_urgencia) hacer\n        evento_actual = eventos_por_urgencia[e]\n        si duracion_acumulada + evento_actual.tiempo <= max_duracion entonces\n            añadir evento_actual a agenda_final\n            duracion_acumulada = duracion_acumulada + evento_actual.tiempo\n        fin si\n    fin para\n    \n    retornar agenda_final\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_5",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion greedy_scheduling(T, capacidad)\n    ordenar T por valor decreciente\n    S = []\n    suma_tiempo = 0\n    indice = 0\n    \n    mientras indice < longitud(T) hacer\n        tarea_candidata = T[indice]\n        si suma_tiempo + tarea_candidata.duracion <= capacidad entonces\n            S = S + [tarea_candidata]\n            suma_tiempo = suma_tiempo + tarea_candidata.duracion\n        fin si\n        indice = indice + 1\n    fin mientras\n    \n    retornar S\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_6",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion distribuir_tareas(conjunto_tareas, deadline)\n    // Estrategia: maximizar utilidad por unidad de tiempo\n    para cada tarea en conjunto_tareas hacer\n        tarea.eficiencia = tarea.utilidad / tarea.costo_temporal\n    fin para\n    \n    conjunto_ordenado = ordenar_por(conjunto_tareas, eficiencia, desc)\n    \n    seleccion = lista_vacia\n    tiempo_usado = 0\n    \n    para tarea en conjunto_ordenado hacer\n        si tiempo_usado + tarea.costo_temporal <= deadline entonces\n            agregar tarea a seleccion\n            tiempo_usado = tiempo_usado + tarea.costo_temporal\n        fin si\n    fin para\n    \n    retornar seleccion, tiempo_usado\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_7",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion planificacion_voraz(actividades)\n    ordenar actividades por peso de mayor a menor\n    planificacion = arreglo_vacio\n    tiempo_total = 0\n    max_tiempo = 100\n    pos = 0\n    \n    repetir\n        act = actividades[pos]\n        si tiempo_total + act.extension <= max_tiempo entonces\n            insertar act en planificacion\n            tiempo_total = tiempo_total + act.extension\n        fin si\n        pos = pos + 1\n    hasta que pos >= tamaño(actividades) o tiempo_total >= max_tiempo\n    \n    retornar planificacion\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_8",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion organizar_proyectos(proyectos, presupuesto_temporal)\n    calcular_metricas(proyectos)\n    proyectos_rankeados = rankear_por_importancia(proyectos)\n    \n    cola_ejecucion = nueva_cola\n    contador_tiempo = 0\n    i = 0\n    \n    mientras i < cantidad(proyectos_rankeados) hacer\n        p = proyectos_rankeados[i]\n        tiempo_necesario = p.dias\n        \n        si contador_tiempo + tiempo_necesario <= presupuesto_temporal entonces\n            encolar p en cola_ejecucion\n            contador_tiempo = contador_tiempo + tiempo_necesario\n        fin si\n        \n        i = i + 1\n    fin mientras\n    \n    retornar cola_ejecucion\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_9",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion seleccion_tareas_optima(lista_t, limite_t)\n    // Greedy por beneficio directo\n    lista_t = ordenar_descendente_por_beneficio(lista_t)\n    \n    solucion = conjunto_vacio\n    acumulador_tiempo = 0\n    acumulador_beneficio = 0\n    \n    para cada elemento en lista_t hacer\n        si acumulador_tiempo + elemento.duracion <= limite_t entonces\n            agregar elemento a solucion\n            acumulador_tiempo = acumulador_tiempo + elemento.duracion\n            acumulador_beneficio = acumulador_beneficio + elemento.beneficio\n        fin si\n    fin para\n    \n    retornar solucion, acumulador_beneficio\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "greedy_planificacion_tareas_10",
    "categoria": "greedy",
    "subcategoria": "planificacion_tareas",
    "pseudocodigo": "funcion asignacion_greedy(tareas_pendientes)\n    ordenar tareas_pendientes por prioridad descendente\n    tareas_asignadas = []\n    tiempo_disponible = 480\n    tiempo_consumido = 0\n    \n    para idx desde 0 hasta longitud(tareas_pendientes) - 1 hacer\n        t = tareas_pendientes[idx]\n        si tiempo_consumido + t.minutos <= tiempo_disponible entonces\n            añadir t a tareas_asignadas\n            tiempo_consumido = tiempo_consumido + t.minutos\n        fin si\n    fin para\n    \n    retornar tareas_asignadas, tiempo_consumido\nfin funcion",
    "label": "greedy"
  },
  {
    "id": "grafos_bfs_1",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "funcion BFS(grafo, nodoInicial)\n    cola = CrearCola()\n    visitados = ConjuntoVacio()\n    \n    Encolar(cola, nodoInicial)\n    Agregar(visitados, nodoInicial)\n    \n    mientras no EstaVacia(cola) hacer\n        actual = Desencolar(cola)\n        Procesar(actual)\n        \n        para cada vecino en grafo[actual] hacer\n            si vecino no esta en visitados entonces\n                Agregar(visitados, vecino)\n                Encolar(cola, vecino)\n            fin si\n        fin para\n    fin mientras\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_2",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "// Recorrido en anchura con seguimiento de niveles\nprocedimiento RecorridoAnchura(G, origen)\n    Q = nueva cola\n    marcados = arreglo booleano de tamaño |V|\n    nivel = arreglo entero de tamaño |V|\n    \n    para todo v en V hacer\n        marcados[v] = falso\n        nivel[v] = infinito\n    fin para\n    \n    insertar(Q, origen)\n    marcados[origen] = verdadero\n    nivel[origen] = 0\n    \n    mientras Q no vacia hacer\n        u = extraer(Q)\n        para todo w adyacente a u hacer\n            si no marcados[w] entonces\n                marcados[w] = verdadero\n                nivel[w] = nivel[u] + 1\n                insertar(Q, w)\n            fin si\n        fin para\n    fin mientras\nfin procedimiento",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_3",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "funcion BusquedaAmplitud(red, verticeOrigen, verticeDestino)\n    colaAuxiliar = []\n    explorados = {}\n    padres = {}\n    \n    AgregarAlFinal(colaAuxiliar, verticeOrigen)\n    explorados[verticeOrigen] = cierto\n    padres[verticeOrigen] = nulo\n    \n    mientras Longitud(colaAuxiliar) > 0 hacer\n        nodoActual = RemoverPrimero(colaAuxiliar)\n        \n        si nodoActual == verticeDestino entonces\n            retornar ReconstruirCamino(padres, verticeDestino)\n        fin si\n        \n        para cada adyacente en ObtenerVecinos(red, nodoActual) hacer\n            si adyacente no pertenece a explorados entonces\n                explorados[adyacente] = cierto\n                padres[adyacente] = nodoActual\n                AgregarAlFinal(colaAuxiliar, adyacente)\n            fin si\n        fin para\n    fin mientras\n    \n    retornar nulo\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_4",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "procedimiento ExploracionPorNiveles(mapa, inicio)\n    buffer = ColaVacia()\n    visto = []\n    distancias = DiccionarioVacio()\n    \n    Push(buffer, inicio)\n    Anexar(visto, inicio)\n    distancias[inicio] = 0\n    \n    mientras Tamaño(buffer) != 0 hacer\n        elemento = Pop(buffer)\n        Imprimir(elemento)\n        \n        para n en ListaAdyacencia(mapa, elemento) hacer\n            si n no esta en visto entonces\n                Anexar(visto, n)\n                distancias[n] = distancias[elemento] + 1\n                Push(buffer, n)\n            fin si\n        fin para\n    fin mientras\n    \n    retornar distancias\nfin procedimiento",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_5",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "funcion TraversalBFS(graph, startNode)\n    queue = InitializeQueue()\n    discovered = CreateSet()\n    result = []\n    \n    Enqueue(queue, startNode)\n    AddToSet(discovered, startNode)\n    \n    mientras not IsEmpty(queue) hacer\n        current = Dequeue(queue)\n        Append(result, current)\n        \n        neighbors = GetAdjacent(graph, current)\n        para cada neighbor en neighbors hacer\n            si not Contains(discovered, neighbor) entonces\n                AddToSet(discovered, neighbor)\n                Enqueue(queue, neighbor)\n            fin si\n        fin para\n    fin mientras\n    \n    retornar result\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_6",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "// BFS con detección de componentes conexas\nprocedimiento BFS_Componentes(grafo)\n    visitado = arreglo[1..n] de booleanos inicializado en falso\n    componente = 0\n    \n    para cada vertice v desde 1 hasta n hacer\n        si no visitado[v] entonces\n            componente = componente + 1\n            Q = crearCola()\n            agregar(Q, v)\n            visitado[v] = verdadero\n            \n            mientras Q no esta vacia hacer\n                x = quitar(Q)\n                Etiquetar(x, componente)\n                \n                para cada y en Adyacentes(grafo, x) hacer\n                    si no visitado[y] entonces\n                        visitado[y] = verdadero\n                        agregar(Q, y)\n                    fin si\n                fin para\n            fin mientras\n        fin si\n    fin para\nfin procedimiento",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_7",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "funcion AnchuraPrimero(estructura, raiz)\n    fila = NuevaCola()\n    procesados = ConjuntoVacio()\n    orden = ListaVacia()\n    \n    Insertar(fila, raiz)\n    Marcar(procesados, raiz)\n    \n    mientras Longitud(fila) > 0 hacer\n        nodo = ExtraerPrimero(fila)\n        AgregarAlFinal(orden, nodo)\n        \n        sucesores = Vecindad(estructura, nodo)\n        para cada s en sucesores hacer\n            si no Pertenece(s, procesados) entonces\n                Marcar(procesados, s)\n                Insertar(fila, s)\n            fin si\n        fin para\n    fin mientras\n    \n    retornar orden\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_8",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "procedimiento RecorridoBFS(G, s)\n    color = nuevo arreglo[|V|]\n    distancia = nuevo arreglo[|V|]\n    predecesor = nuevo arreglo[|V|]\n    \n    para cada u en V[G] - {s} hacer\n        color[u] = BLANCO\n        distancia[u] = INFINITO\n        predecesor[u] = NIL\n    fin para\n    \n    color[s] = GRIS\n    distancia[s] = 0\n    predecesor[s] = NIL\n    COLA = CrearColaVacia()\n    Encolar(COLA, s)\n    \n    mientras COLA no vacia hacer\n        u = Desencolar(COLA)\n        para cada v en Ady[u] hacer\n            si color[v] = BLANCO entonces\n                color[v] = GRIS\n                distancia[v] = distancia[u] + 1\n                predecesor[v] = u\n                Encolar(COLA, v)\n            fin si\n        fin para\n        color[u] = NEGRO\n    fin mientras\nfin procedimiento",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_9",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "funcion BusquedaEnAmplitud(matrizAdy, nodoPartida, nodoBuscado)\n    pendientes = ColaFIFO()\n    yaVistos = ArregloBool(tamaño)\n    encontrado = falso\n    \n    Meter(pendientes, nodoPartida)\n    yaVistos[nodoPartida] = verdadero\n    \n    mientras no Vacia(pendientes) y no encontrado hacer\n        v = Sacar(pendientes)\n        \n        si v == nodoBuscado entonces\n            encontrado = verdadero\n        sino\n            para i desde 0 hasta tamaño-1 hacer\n                si matrizAdy[v][i] == 1 y no yaVistos[i] entonces\n                    yaVistos[i] = verdadero\n                    Meter(pendientes, i)\n                fin si\n            fin para\n        fin si\n    fin mientras\n    \n    retornar encontrado\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_bfs_10",
    "categoria": "grafos",
    "subcategoria": "bfs",
    "pseudocodigo": "procedimiento ExploracionNivelPorNivel(digrafo, origen)\n    frontera = []\n    alcanzados = ConjuntoVacio()\n    profundidad = 0\n    \n    Agregar(frontera, origen)\n    Incluir(alcanzados, origen)\n    \n    mientras Cardinalidad(frontera) > 0 hacer\n        Imprimir(\"Nivel\", profundidad, \":\", frontera)\n        siguienteNivel = []\n        \n        para cada vertice en frontera hacer\n            para cada destino en Sucesores(digrafo, vertice) hacer\n                si destino no pertenece a alcanzados entonces\n                    Incluir(alcanzados, destino)\n                    Agregar(siguienteNivel, destino)\n                fin si\n            fin para\n        fin para\n        \n        frontera = siguienteNivel\n        profundidad = profundidad + 1\n    fin mientras\nfin procedimiento",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_1",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "funcion DFS(grafo, nodoInicial):\n    visitados = conjunto_vacio()\n    pila = nueva_pila()\n    pila.agregar(nodoInicial)\n    \n    mientras pila no este vacia:\n        nodo = pila.extraer()\n        si nodo no esta en visitados:\n            visitados.agregar(nodo)\n            procesar(nodo)\n            para cada vecino en grafo.adyacentes(nodo):\n                pila.agregar(vecino)\n    \n    retornar visitados",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_2",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "procedimiento RecorridoProfundidad(G, v, marcados):\n    marcados[v] = verdadero\n    imprimir(v)\n    \n    para cada w en G.listaAdyacencia[v]:\n        si marcados[w] == falso entonces:\n            RecorridoProfundidad(G, w, marcados)",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_3",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "funcion exploracion_profunda(red, origen):\n    // Algoritmo DFS iterativo con seguimiento de camino\n    conjunto_explorado = arreglo_booleano(red.tamaño)\n    stack = []\n    ruta_completa = []\n    \n    stack.insertar_final(origen)\n    \n    mientras longitud(stack) > 0:\n        actual = stack.quitar_final()\n        \n        si no conjunto_explorado[actual]:\n            conjunto_explorado[actual] = verdadero\n            ruta_completa.agregar(actual)\n            \n            para i desde red.vecinos[actual].tamaño - 1 hasta 0:\n                siguiente = red.vecinos[actual][i]\n                si no conjunto_explorado[siguiente]:\n                    stack.insertar_final(siguiente)\n    \n    retornar ruta_completa",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_4",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "funcion busqueda_profundidad(matriz_adyacencia, inicio, n):\n    visto = arreglo[n] inicializado en falso\n    resultado = lista_vacia()\n    \n    procedimiento dfs_recursivo(u):\n        visto[u] = verdadero\n        resultado.añadir(u)\n        \n        para j desde 0 hasta n-1:\n            si matriz_adyacencia[u][j] == 1 y visto[j] == falso:\n                dfs_recursivo(j)\n    \n    dfs_recursivo(inicio)\n    retornar resultado",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_5",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "algoritmo DFS_Completo(grafo):\n    estado = diccionario_vacio()\n    orden_visita = []\n    \n    para cada vertice en grafo.vertices():\n        estado[vertice] = \"no_visitado\"\n    \n    funcion visitar(x):\n        estado[x] = \"visitando\"\n        orden_visita.agregar(x)\n        \n        para cada y en grafo.obtener_vecinos(x):\n            si estado[y] == \"no_visitado\":\n                visitar(y)\n        \n        estado[x] = \"visitado\"\n    \n    para cada nodo en grafo.vertices():\n        si estado[nodo] == \"no_visitado\":\n            visitar(nodo)\n    \n    retornar orden_visita",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_6",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "procedimiento recorrido_DFS(G, s):\n    crear pila P\n    crear conjunto V\n    P.push(s)\n    \n    repetir hasta que P este vacia:\n        elemento = P.pop()\n        \n        si elemento no pertenece a V:\n            V.insertar(elemento)\n            ejecutar_accion(elemento)\n            \n            adyacentes = G.obtenerAdyacentes(elemento)\n            para cada adj en adyacentes hacer:\n                P.push(adj)",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_7",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "funcion depth_first_search(graph, start_node, objetivo):\n    // DFS con búsqueda de objetivo específico\n    visitado = conjunto()\n    pila_nodos = pila_nueva()\n    pila_nodos.empujar(start_node)\n    \n    mientras no pila_nodos.esta_vacia():\n        current = pila_nodos.tope()\n        pila_nodos.desapilar()\n        \n        si current == objetivo entonces:\n            retornar verdadero\n        \n        si current no en visitado:\n            visitado.agregar(current)\n            \n            lista_ady = graph.adyacencias(current)\n            para cada nodo_adj en lista_ady:\n                si nodo_adj no en visitado:\n                    pila_nodos.empujar(nodo_adj)\n    \n    retornar falso",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_8",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "algoritmo BusquedaEnProfundidad(grafo, raiz):\n    marcas = mapa_vacio()\n    \n    funcion explorar(nodo_actual):\n        marcas[nodo_actual] = cierto\n        mostrar(nodo_actual)\n        \n        conexiones = grafo[nodo_actual]\n        para cada conexion en conexiones:\n            si marcas[conexion] != cierto:\n                explorar(conexion)\n    \n    explorar(raiz)",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_9",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "procedimiento DFS_con_tiempo(G, vertice_inicial):\n    // DFS con marcas de tiempo de descubrimiento y finalización\n    color = arreglo[G.num_vertices] = \"blanco\"\n    tiempo_desc = arreglo[G.num_vertices]\n    tiempo_fin = arreglo[G.num_vertices]\n    tiempo = 0\n    \n    procedimiento DFS_visita(u):\n        tiempo = tiempo + 1\n        tiempo_desc[u] = tiempo\n        color[u] = \"gris\"\n        \n        para cada v en G.ady[u]:\n            si color[v] == \"blanco\":\n                DFS_visita(v)\n        \n        color[u] = \"negro\"\n        tiempo = tiempo + 1\n        tiempo_fin[u] = tiempo\n    \n    DFS_visita(vertice_inicial)",
    "label": "grafos"
  },
  {
    "id": "grafos_dfs_10",
    "categoria": "grafos",
    "subcategoria": "dfs",
    "pseudocodigo": "funcion recorrido_profundidad_iterativo(red, punto_partida):\n    explorados = conjunto_nuevo()\n    frontera = pila_nueva()\n    secuencia = lista_nueva()\n    \n    frontera.apilar(punto_partida)\n    \n    mientras frontera.tamaño() > 0:\n        nodo_actual = frontera.desapilar()\n        \n        si nodo_actual no esta en explorados:\n            explorados.añadir(nodo_actual)\n            secuencia.añadir(nodo_actual)\n            \n            vecindad = red.obtener_vecinos(nodo_actual)\n            vecindad.invertir()\n            \n            para cada vecino en vecindad:\n                si vecino no esta en explorados:\n                    frontera.apilar(vecino)\n    \n    retornar secuencia",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_1",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion dijkstra(grafo, origen)\n    distancias = arreglo infinito para todos los nodos\n    distancias[origen] = 0\n    visitados = conjunto vacío\n    cola = todos los nodos del grafo\n    \n    mientras cola no esté vacía hacer\n        u = nodo con menor distancia en cola\n        remover u de cola\n        agregar u a visitados\n        \n        para cada vecino v de u hacer\n            si v no está en visitados entonces\n                nueva_distancia = distancias[u] + peso(u, v)\n                si nueva_distancia < distancias[v] entonces\n                    distancias[v] = nueva_distancia\n                fin si\n            fin si\n        fin para\n    fin mientras\n    \n    retornar distancias\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_2",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion caminoMasCorto(red, nodoInicial)\n    costo = mapa con valores infinitos\n    costo[nodoInicial] = 0\n    procesados = lista vacía\n    pendientes = cola_prioridad con nodoInicial\n    \n    mientras pendientes tenga elementos hacer\n        actual = extraer_minimo(pendientes)\n        \n        si actual en procesados entonces\n            continuar\n        fin si\n        \n        marcar actual como procesado\n        \n        para cada adyacente en red[actual] hacer\n            costoNuevo = costo[actual] + red[actual][adyacente]\n            si costoNuevo < costo[adyacente] entonces\n                costo[adyacente] = costoNuevo\n                insertar adyacente en pendientes\n            fin si\n        fin para\n    fin mientras\n    \n    retornar costo\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_3",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion encontrarRutaMinima(G, s)\n    d = vector de tamaño n con valores INFINITO\n    d[s] = 0\n    Q = conjunto de todos los vértices\n    predecesor = vector de tamaño n con valores nulo\n    \n    mientras Q no sea vacío hacer\n        extraer vértice u con d[u] mínimo de Q\n        \n        para cada arista (u,w) hacer\n            alternativa = d[u] + longitud(u,w)\n            si alternativa < d[w] entonces\n                d[w] = alternativa\n                predecesor[w] = u\n            fin si\n        fin para\n    fin mientras\n    \n    retornar d, predecesor\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_4",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion algoritmo_dijkstra(matriz_adyacencia, inicio)\n    n = número de nodos\n    dist = arreglo[n] inicializado en infinito\n    dist[inicio] = 0\n    visitado = arreglo[n] de booleanos en falso\n    \n    para i desde 1 hasta n hacer\n        minimo = infinito\n        indice_minimo = -1\n        \n        para j desde 0 hasta n-1 hacer\n            si no visitado[j] y dist[j] < minimo entonces\n                minimo = dist[j]\n                indice_minimo = j\n            fin si\n        fin para\n        \n        visitado[indice_minimo] = verdadero\n        \n        para k desde 0 hasta n-1 hacer\n            si matriz_adyacencia[indice_minimo][k] > 0 entonces\n                si dist[indice_minimo] + matriz_adyacencia[indice_minimo][k] < dist[k] entonces\n                    dist[k] = dist[indice_minimo] + matriz_adyacencia[indice_minimo][k]\n                fin si\n            fin si\n        fin para\n    fin para\n    \n    retornar dist\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_5",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion buscarDistanciasMinimas(grafo, verticeOrigen)\n    distancia = diccionario vacío\n    anterior = diccionario vacío\n    noVisitados = heap_minimo vacío\n    \n    para cada nodo en grafo hacer\n        distancia[nodo] = infinito\n        anterior[nodo] = indefinido\n        insertar nodo en noVisitados con prioridad infinito\n    fin para\n    \n    distancia[verticeOrigen] = 0\n    actualizar_prioridad(noVisitados, verticeOrigen, 0)\n    \n    mientras noVisitados no esté vacío hacer\n        v = extraer_minimo(noVisitados)\n        \n        para cada vecino en grafo.adyacentes(v) hacer\n            distAlternativa = distancia[v] + grafo.peso_arista(v, vecino)\n            \n            si distAlternativa < distancia[vecino] entonces\n                distancia[vecino] = distAlternativa\n                anterior[vecino] = v\n                actualizar_prioridad(noVisitados, vecino, distAlternativa)\n            fin si\n        fin para\n    fin mientras\n    \n    retornar distancia, anterior\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_6",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion calcular_caminos_cortos(listaAdyacencia, raiz)\n    tamano = longitud(listaAdyacencia)\n    costos = nuevo arreglo[tamano]\n    explorado = nuevo arreglo[tamano]\n    \n    para idx desde 0 hasta tamano-1 hacer\n        costos[idx] = INFINITO\n        explorado[idx] = falso\n    fin para\n    \n    costos[raiz] = 0\n    contador = 0\n    \n    mientras contador < tamano hacer\n        minCosto = INFINITO\n        nodoActual = -1\n        \n        para i desde 0 hasta tamano-1 hacer\n            si explorado[i] es falso y costos[i] < minCosto entonces\n                minCosto = costos[i]\n                nodoActual = i\n            fin si\n        fin para\n        \n        explorado[nodoActual] = verdadero\n        contador = contador + 1\n        \n        para cada arista en listaAdyacencia[nodoActual] hacer\n            destino = arista.destino\n            peso = arista.peso\n            \n            si costos[nodoActual] + peso < costos[destino] entonces\n                costos[destino] = costos[nodoActual] + peso\n            fin si\n        fin para\n    fin mientras\n    \n    retornar costos\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_7",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion dijkstra_con_camino(G, origen, destino)\n    D = tabla_hash con distancias infinitas\n    D[origen] = 0\n    P = tabla_hash para padres\n    S = conjunto de nodos resueltos\n    Q = cola_prioridad_minima\n    Q.insertar(origen, 0)\n    \n    mientras no Q.esta_vacia() hacer\n        u = Q.extraer_minimo()\n        \n        si u igual destino entonces\n            romper\n        fin si\n        \n        si u en S entonces\n            continuar\n        fin si\n        \n        S.agregar(u)\n        \n        para cada vecino v de G.vecinos(u) hacer\n            peso_arista = G.obtener_peso(u, v)\n            distancia_candidata = D[u] + peso_arista\n            \n            si distancia_candidata < D[v] entonces\n                D[v] = distancia_candidata\n                P[v] = u\n                Q.insertar(v, distancia_candidata)\n            fin si\n        fin para\n    fin mientras\n    \n    camino = reconstruir_camino(P, origen, destino)\n    retornar D[destino], camino\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_8",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion ruta_optima(mapa, puntoPartida)\n    longitudes = inicializar_infinito()\n    longitudes[puntoPartida] = 0\n    sinProcesar = conjunto_todos_nodos(mapa)\n    \n    mientras sinProcesar.tamano() > 0 hacer\n        nodoMinimo = nulo\n        valorMinimo = infinito\n        \n        para cada elemento en sinProcesar hacer\n            si longitudes[elemento] < valorMinimo entonces\n                valorMinimo = longitudes[elemento]\n                nodoMinimo = elemento\n            fin si\n        fin para\n        \n        sinProcesar.eliminar(nodoMinimo)\n        \n        para cada conexion en mapa.obtener_conexiones(nodoMinimo) hacer\n            nodoVecino = conexion.nodo\n            pesoConexion = conexion.peso\n            longitudAlternativa = longitudes[nodoMinimo] + pesoConexion\n            \n            si longitudAlternativa < longitudes[nodoVecino] entonces\n                longitudes[nodoVecino] = longitudAlternativa\n            fin si\n        fin para\n    fin mientras\n    \n    retornar longitudes\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_9",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion distancias_minimas_dijkstra(grafo, nodo_inicio)\n    num_vertices = grafo.cantidad_nodos()\n    distancias_finales = arreglo[num_vertices]\n    conjunto_visitados = conjunto_vacio\n    heap = monticulo_minimo\n    \n    para v desde 0 hasta num_vertices-1 hacer\n        distancias_finales[v] = VALOR_INFINITO\n    fin para\n    \n    distancias_finales[nodo_inicio] = 0\n    heap.agregar(nodo_inicio, 0)\n    \n    mientras heap.no_vacio() hacer\n        nodo_actual = heap.extraer_minimo()\n        \n        si nodo_actual en conjunto_visitados entonces\n            continuar\n        fin si\n        \n        conjunto_visitados.insertar(nodo_actual)\n        \n        lista_vecinos = grafo.obtener_vecinos(nodo_actual)\n        \n        para cada vecino en lista_vecinos hacer\n            si vecino no en conjunto_visitados entonces\n                peso_enlace = grafo.peso_entre(nodo_actual, vecino)\n                nueva_distancia = distancias_finales[nodo_actual] + peso_enlace\n                \n                si nueva_distancia < distancias_finales[vecino] entonces\n                    distancias_finales[vecino] = nueva_distancia\n                    heap.agregar(vecino, nueva_distancia)\n                fin si\n            fin si\n        fin para\n    fin mientras\n    \n    retornar distancias_finales\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_dijkstra_10",
    "categoria": "grafos",
    "subcategoria": "dijkstra",
    "pseudocodigo": "funcion resolver_camino_minimo(red, vertice_inicial)\n    tabla_distancias = crear_tabla()\n    tabla_previos = crear_tabla()\n    procesados = conjunto_vacio\n    por_procesar = heap_fibonacci\n    \n    inicializar_tabla(tabla_distancias, infinito)\n    tabla_distancias[vertice_inicial] = 0\n    por_procesar.insertar(vertice_inicial, 0)\n    \n    mientras por_procesar.tiene_elementos() hacer\n        v_actual = por_procesar.eliminar_minimo()\n        \n        si v_actual ya_esta_en procesados entonces\n            saltar_iteracion\n        fin si\n        \n        procesados.agregar(v_actual)\n        aristas_salientes = red.aristas_desde(v_actual)\n        \n        para cada arista en aristas_salientes hacer\n            v_destino = arista.obtener_destino()\n            peso_arista = arista.obtener_peso()\n            distancia_propuesta = tabla_distancias[v_actual] + peso_arista\n            \n            si distancia_propuesta < tabla_distancias[v_destino] entonces\n                tabla_distancias[v_destino] = distancia_propuesta\n                tabla_previos[v_destino] = v_actual\n                \n                si v_destino no_esta_en procesados entonces\n                    por_procesar.insertar(v_destino, distancia_propuesta)\n                fin si\n            fin si\n        fin para\n    fin mientras\n    \n    retornar tabla_distancias, tabla_previos\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_1",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion prim(grafo, inicio)\n    visitados = conjunto_vacio\n    arbol = lista_vacia\n    cola_prioridad = nueva_cola_prioridad()\n    \n    agregar visitados(inicio)\n    para cada arista en grafo.aristas(inicio) hacer\n        insertar cola_prioridad(arista, arista.peso)\n    fin para\n    \n    mientras no esta_vacia(cola_prioridad) hacer\n        arista_minima = extraer_minimo(cola_prioridad)\n        vertice_destino = arista_minima.destino\n        \n        si vertice_destino no esta en visitados entonces\n            agregar visitados(vertice_destino)\n            agregar arbol(arista_minima)\n            \n            para cada arista en grafo.aristas(vertice_destino) hacer\n                si arista.destino no esta en visitados entonces\n                    insertar cola_prioridad(arista, arista.peso)\n                fin si\n            fin para\n        fin si\n    fin mientras\n    \n    retornar arbol\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_2",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion algoritmo_prim(G, nodo_raiz)\n    conjunto_S = {nodo_raiz}\n    aristas_MST = []\n    costo_total = 0\n    \n    mientras tamaño(conjunto_S) < numero_vertices(G) hacer\n        menor_peso = infinito\n        arista_elegida = nulo\n        \n        para u en conjunto_S hacer\n            para v en adyacentes(G, u) hacer\n                si v no pertenece a conjunto_S entonces\n                    si peso(u, v) < menor_peso entonces\n                        menor_peso = peso(u, v)\n                        arista_elegida = (u, v)\n                    fin si\n                fin si\n            fin para\n        fin para\n        \n        agregar conjunto_S(arista_elegida.segundo)\n        agregar aristas_MST(arista_elegida)\n        costo_total = costo_total + menor_peso\n    fin mientras\n    \n    retornar aristas_MST, costo_total\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_3",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion construir_arbol_minimo(red, v_inicial)\n    marcados = arreglo[tamaño_red] inicializado en falso\n    padre = arreglo[tamaño_red] inicializado en -1\n    clave = arreglo[tamaño_red] inicializado en infinito\n    \n    clave[v_inicial] = 0\n    \n    para i desde 0 hasta tamaño_red - 1 hacer\n        u = extraer_vertice_minimo_no_marcado(clave, marcados)\n        marcados[u] = verdadero\n        \n        para cada vecino w de u hacer\n            si marcados[w] == falso y red[u][w] < clave[w] entonces\n                clave[w] = red[u][w]\n                padre[w] = u\n            fin si\n        fin para\n    fin para\n    \n    retornar padre\nfin funcion\n\nfuncion extraer_vertice_minimo_no_marcado(clave, marcados)\n    minimo = infinito\n    indice_min = -1\n    para i desde 0 hasta longitud(clave) - 1 hacer\n        si marcados[i] == falso y clave[i] < minimo entonces\n            minimo = clave[i]\n            indice_min = i\n        fin si\n    fin para\n    retornar indice_min\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_4",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion MST_Prim(matriz_adyacencia, origen)\n    n = numero_nodos(matriz_adyacencia)\n    incluido = nuevo_arreglo_booleano(n, falso)\n    distancia_minima = nuevo_arreglo(n, INFINITO)\n    resultado = lista_vacia\n    \n    distancia_minima[origen] = 0\n    incluido[origen] = verdadero\n    nodos_procesados = 1\n    \n    mientras nodos_procesados < n hacer\n        borde_minimo = INFINITO\n        desde = -1\n        hacia = -1\n        \n        para i desde 0 hasta n-1 hacer\n            si incluido[i] entonces\n                para j desde 0 hasta n-1 hacer\n                    si no incluido[j] y matriz_adyacencia[i][j] > 0 entonces\n                        si matriz_adyacencia[i][j] < borde_minimo entonces\n                            borde_minimo = matriz_adyacencia[i][j]\n                            desde = i\n                            hacia = j\n                        fin si\n                    fin si\n                fin para\n            fin si\n        fin para\n        \n        incluido[hacia] = verdadero\n        agregar_a_lista(resultado, {desde, hacia, borde_minimo})\n        nodos_procesados = nodos_procesados + 1\n    fin mientras\n    \n    retornar resultado\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_5",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion prim_con_heap(grafo_G, vertice_s)\n    // Inicialización de estructuras\n    Q = crear_heap_minimo()\n    arbol_expansion = conjunto_vacio\n    costo = arreglo_de_tamaño(G.vertices) con valores infinito\n    predecesor = arreglo_de_tamaño(G.vertices) con valores nulo\n    \n    costo[vertice_s] = 0\n    \n    // Insertar todos los vértices en el heap\n    para cada v en grafo_G.vertices hacer\n        insertar_en_heap(Q, v, costo[v])\n    fin para\n    \n    // Algoritmo principal\n    mientras Q no este vacio hacer\n        u = extraer_minimo(Q)\n        \n        si predecesor[u] != nulo entonces\n            agregar arbol_expansion({predecesor[u], u})\n        fin si\n        \n        para cada v adyacente a u hacer\n            si v esta en Q y peso(u,v) < costo[v] entonces\n                predecesor[v] = u\n                costo[v] = peso(u,v)\n                decrementar_clave(Q, v, costo[v])\n            fin si\n        fin para\n    fin mientras\n    \n    retornar arbol_expansion\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_6",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion arbol_recubridor_minimo(G, raiz)\n    T = grafo_vacio\n    vertices_en_T = {raiz}\n    aristas_candidatas = obtener_aristas_incidentes(G, raiz)\n    \n    repetir hasta que tamaño(vertices_en_T) == tamaño(G.vertices)\n        e = arista_de_peso_minimo(aristas_candidatas)\n        eliminar aristas_candidatas(e)\n        \n        sean u, v los extremos de e\n        \n        si u en vertices_en_T y v no en vertices_en_T entonces\n            agregar T(e)\n            agregar vertices_en_T(v)\n            nuevas_aristas = obtener_aristas_incidentes(G, v)\n            para cada arista_nueva en nuevas_aristas hacer\n                si arista_nueva no conecta dos vertices en vertices_en_T entonces\n                    agregar aristas_candidatas(arista_nueva)\n                fin si\n            fin para\n        sino si v en vertices_en_T y u no en vertices_en_T entonces\n            agregar T(e)\n            agregar vertices_en_T(u)\n            nuevas_aristas = obtener_aristas_incidentes(G, u)\n            para cada arista_nueva en nuevas_aristas hacer\n                si arista_nueva no conecta dos vertices en vertices_en_T entonces\n                    agregar aristas_candidatas(arista_nueva)\n                fin si\n            fin para\n        fin si\n    fin repetir\n    \n    retornar T\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_7",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion ejecutar_prim(malla, punto_partida)\n    explorados = conjunto_vacio\n    frontera = heap_minimo_vacio\n    solucion = lista_vacia\n    peso_total = 0\n    \n    insertar explorados(punto_partida)\n    \n    para cada conexion c saliendo de punto_partida hacer\n        push frontera(c.destino, c.costo, punto_partida, c.destino)\n    fin para\n    \n    mientras tamaño(explorados) < malla.cantidad_nodos hacer\n        registro = pop frontera()\n        nodo_actual = registro.nodo_destino\n        \n        si nodo_actual no esta en explorados entonces\n            insertar explorados(nodo_actual)\n            insertar solucion({registro.nodo_origen, registro.nodo_destino, registro.costo})\n            peso_total = peso_total + registro.costo\n            \n            para cada conexion c saliendo de nodo_actual hacer\n                si c.destino no esta en explorados entonces\n                    push frontera(c.destino, c.costo, nodo_actual, c.destino)\n                fin si\n            fin para\n        fin si\n    fin mientras\n    \n    retornar solucion, peso_total\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_8",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion prim_simple(red, nodo_inicial)\n    seleccionados = [nodo_inicial]\n    enlaces = []\n    \n    mientras longitud(seleccionados) < total_nodos(red) hacer\n        peso_min = INFINITO\n        enlace_optimo = nulo\n        \n        para cada n en seleccionados hacer\n            para cada m en vecinos(red, n) hacer\n                si m no esta en seleccionados entonces\n                    w = obtener_peso(red, n, m)\n                    si w < peso_min entonces\n                        peso_min = w\n                        enlace_optimo = crear_enlace(n, m, w)\n                    fin si\n                fin si\n            fin para\n        fin para\n        \n        agregar_nodo seleccionados(enlace_optimo.segundo_nodo)\n        agregar_enlace enlaces(enlace_optimo)\n    fin mientras\n    \n    retornar enlaces\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_9",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion generar_MST_prim(grafo, v0)\n    visitado = mapa_booleano vacio\n    distancia = mapa_numerico vacio\n    previo = mapa vacio\n    cola = cola_prioridad_minima vacia\n    \n    para cada vertice en grafo hacer\n        visitado[vertice] = falso\n        distancia[vertice] = infinito\n        previo[vertice] = indefinido\n    fin para\n    \n    distancia[v0] = 0\n    encolar cola(v0, 0)\n    \n    mientras cola no vacia hacer\n        actual = desencolar cola()\n        \n        si visitado[actual] entonces\n            continuar\n        fin si\n        \n        visitado[actual] = verdadero\n        \n        para cada adyacente en grafo.obtener_adyacentes(actual) hacer\n            peso_arista = grafo.obtener_peso(actual, adyacente)\n            \n            si no visitado[adyacente] y peso_arista < distancia[adyacente] entonces\n                distancia[adyacente] = peso_arista\n                previo[adyacente] = actual\n                encolar cola(adyacente, peso_arista)\n            fin si\n        fin para\n    fin mientras\n    \n    retornar reconstruir_arbol(previo, v0)\nfin funcion\n\nfuncion reconstruir_arbol(previo, raiz)\n    aristas = lista_vacia\n    para cada vertice, padre en previo hacer\n        si padre != indefinido entonces\n            agregar aristas({padre, vertice})\n        fin si\n    fin para\n    retornar aristas\nfin funcion",
    "label": "grafos"
  },
  {
    "id": "grafos_prim_10",
    "categoria": "grafos",
    "subcategoria": "prim",
    "pseudocodigo": "funcion algoritmo_expansion_minima(G, s)\n    N = cantidad_vertices(G)\n    procesado = arreglo[N] de falsos\n    costo_minimo = arreglo[N] de infinitos\n    conexion_previa = arreglo[N] de nulos\n    resultado_aristas = lista_vacia\n    suma_pesos = 0\n    \n    costo_minimo[s] = 0\n    contador = 0\n    \n    mientras contador < N hacer\n        minimo_actual = infinito\n        vertice_seleccionado = -1\n        \n        para idx desde 0 hasta N-1 hacer\n            si no procesado[idx] y costo_minimo[idx] < minimo_actual entonces\n                minimo_actual = costo_minimo[idx]\n                vertice_seleccionado = idx\n            fin si\n        fin para\n        \n        procesado[vertice_seleccionado] = verdadero\n        contador = contador + 1\n        \n        si conexion_previa[vertice_seleccionado] != nulo entonces\n            agregar resultado_aristas({conexion_previa[vertice_seleccionado], vertice_seleccionado})\n            suma_pesos = suma_pesos + minimo_actual\n        fin si\n        \n        para cada ady en adyacentes(G, vertice_seleccionado) hacer\n            peso_ady = G.peso_arista(vertice_seleccionado, ady)\n            si no procesado[ady] y peso_ady < costo_minimo[ady] entonces\n                costo_minimo[ady] = peso_ady\n                conexion_previa[ady] = vertice_seleccionado\n            fin si\n        fin para\n    fin mientras\n    \n    retornar resultado_aristas, suma_pesos\nfin funcion",
    "label": "grafos"
  }
]