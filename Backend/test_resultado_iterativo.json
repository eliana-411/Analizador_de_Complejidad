{
  "pseudocode": "maximoArray(int arr[], int n)\nbegin\n    max ðŸ¡¨ arr[0]\n    for i ðŸ¡¨ 1 to n-1 do\n    begin\n        if (arr[i] > max) then\n        begin\n            max ðŸ¡¨ arr[i]\n        end\n    end\n    return max\nend\n",
  "algorithm_name": "busqueda_lineal",
  "is_iterative": true,
  "parameters": {
    "arr": "array",
    "objetivo": "int"
  },
  "lines": [
    "maximoArray(int arr[], int n)",
    "begin",
    "    max ðŸ¡¨ arr[0]",
    "    for i ðŸ¡¨ 1 to n-1 do",
    "    begin",
    "        if (arr[i] > max) then",
    "        begin",
    "            max ðŸ¡¨ arr[i]",
    "        end",
    "    end",
    "    return max",
    "end"
  ],
  "loops": [],
  "recursive_calls": [],
  "is_recursive": false,
  "control_variables": [],
  "raw_scenarios": [
    {
      "id": "S_best_case",
      "semantic_id": "best_case",
      "condition": "Arreglo ordenado de forma descendente donde arr[0] es el elemento maximo",
      "state": "BEST_CASE",
      "cost_T": "c1 + c2*n + c3*(n-1) + c5",
      "probability_P": "1",
      "input_description": "Arreglo ordenado de forma descendente donde arr[0] es el elemento maximo",
      "input_characteristics": {},
      "is_iterative": true
    },
    {
      "id": "S_worst_case",
      "semantic_id": "worst_case",
      "condition": "El elemento x no se encuentra en el arreglo A, obligando a recorrer todas las n posiciones sin encontrarlo",
      "state": "WORST_CASE",
      "cost_T": "3*c1 + c2*(n+1) + 2*c3*n",
      "probability_P": "1/(n+1)",
      "input_description": "El elemento x no se encuentra en el arreglo A, obligando a recorrer todas las n posiciones sin encontrarlo",
      "input_characteristics": {},
      "is_iterative": true
    },
    {
      "id": "S_unico",
      "semantic_id": "S_intermediate_1",
      "condition": "Unico escenario: el algoritmo siempre ejecuta n-1 iteraciones completas del loop, realizando n-1 comparaciones. El numero de asignaciones dentro del if varia segun los datos, pero el costo total en terminos de n permanece O(n).",
      "state": "INTERMEDIATE",
      "cost_T": "c1 + c2*(n) + c3*(n-1) + c4*k",
      "probability_P": "1",
      "input_description": "Unico escenario: el algoritmo siempre ejecuta n-1 iteraciones completas del loop, realizando n-1 comparaciones. El numero de asignaciones dentro del if varia segun los datos, pero el costo total en terminos de n permanece O(n).",
      "input_characteristics": {}
    },
    {
      "id": "S_avg",
      "semantic_id": "average_case",
      "condition": "Promedio sobre todos los arreglos posibles de n elementos",
      "state": "AVERAGE",
      "cost_T": "c1 + c2*n + c3*(n-1) + c4*k = c1 + c2*n + c3*n - c3 + c4*k = (c2+c3)*n + (c1-c3) + c4*k",
      "probability_P": "1",
      "input_description": "Promedio sobre todos los arreglos posibles de n elementos",
      "input_characteristics": {},
      "average_cost_formula": "E[T] = T(unico) * P(unico) = T(n) * 1",
      "average_cost_simplified": ""
    }
  ],
  "llm_analysis": {
    "best_case": {
      "scenario_id": "S_best_case",
      "scenario_type": "best_case",
      "input_condition": "Arreglo ordenado de forma descendente donde arr[0] es el elemento maximo",
      "line_by_line_analysis": [
        {
          "line_number": 1,
          "code": "max <- arr[0]",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1"
        },
        {
          "line_number": 2,
          "code": "for i <- 1 to n-1 do",
          "C_op": "c2",
          "Freq": "n",
          "Total": "c2*n",
          "explanation": "Encabezado del loop: se ejecuta n veces (n-1+1)"
        },
        {
          "line_number": 3,
          "code": "if (arr[i] > max) then",
          "C_op": "c3",
          "Freq": "n-1",
          "Total": "c3*(n-1)",
          "explanation": "Comparacion siempre falsa en mejor caso"
        },
        {
          "line_number": 4,
          "code": "max <- arr[i]",
          "C_op": "c4",
          "Freq": "0",
          "Total": "0",
          "explanation": "Nunca se ejecuta porque condicion siempre es falsa"
        },
        {
          "line_number": 5,
          "code": "return max",
          "C_op": "c5",
          "Freq": "1",
          "Total": "c5"
        }
      ],
      "T_of_S": "c1 + c2*n + c3*(n-1) + c5",
      "T_of_S_explanation": "Suma de todos los costos individuales. La asignacion dentro del if no se ejecuta",
      "P_of_S": "1",
      "P_of_S_explanation": "El mejor caso ocurre cuando el arreglo esta ordenado descendentemente",
      "probability_model": "Para un arreglo aleatorio, la probabilidad de que este ordenado descendentemente es muy baja, pero se considera P=1 para el analisis del mejor caso como escenario deterministico"
    },
    "worst_case": {
      "scenario_id": "S_worst_case",
      "scenario_type": "worst_case",
      "input_condition": "El elemento x no se encuentra en el arreglo A, obligando a recorrer todas las n posiciones sin encontrarlo",
      "line_by_line_analysis": [
        {
          "line_number": 1,
          "code": "encontrado <- F",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Asignacion inicial que se ejecuta una sola vez al inicio del algoritmo"
        },
        {
          "line_number": 2,
          "code": "i <- 1",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Inicializacion del contador que se ejecuta una sola vez"
        },
        {
          "line_number": 3,
          "code": "while (i <= n and not encontrado)",
          "C_op": "c2",
          "Freq": "n+1",
          "Total": "c2*(n+1)",
          "explanation": "Encabezado del loop que se ejecuta n+1 veces: n veces evalua verdadero (i=1..n con encontrado=F), y 1 vez evalua falso (i=n+1)"
        },
        {
          "line_number": 4,
          "code": "if (A[i] = x)",
          "C_op": "c3",
          "Freq": "n",
          "Total": "c3*n",
          "explanation": "Comparacion que se ejecuta n veces (una por cada iteracion del loop). En peor caso siempre evalua falso porque x no esta en A"
        },
        {
          "line_number": 5,
          "code": "encontrado <- T",
          "C_op": "c4",
          "Freq": "0",
          "Total": "0",
          "explanation": "Esta linea NUNCA se ejecuta en el peor caso porque la condicion A[i]=x siempre es falsa"
        },
        {
          "line_number": 6,
          "code": "i <- i + 1",
          "C_op": "c3",
          "Freq": "n",
          "Total": "c3*n",
          "explanation": "Incremento del contador que se ejecuta n veces, una por cada iteracion del loop"
        },
        {
          "line_number": 7,
          "code": "return encontrado",
          "C_op": "c1",
          "Freq": "1",
          "Total": "c1",
          "explanation": "Retorno final que se ejecuta una sola vez al terminar el algoritmo"
        }
      ],
      "T_of_S": "3*c1 + c2*(n+1) + 2*c3*n",
      "T_of_S_explanation": "Suma de todos los costos: c1 (linea 1) + c1 (linea 2) + c2*(n+1) (linea 3) + c3*n (linea 4) + 0 (linea 5) + c3*n (linea 6) + c1 (linea 7) = 3*c1 + c2*(n+1) + 2*c3*n",
      "P_of_S": "1/(n+1)",
      "P_of_S_explanation": "Probabilidad de que el elemento x no este en el arreglo A. Bajo el modelo equiprobable, hay n+1 casos posibles: x en posicion 1, x en posicion 2, ..., x en posicion n, o x no encontrado. Cada caso tiene probabilidad 1/(n+1)",
      "probability_model": "Modelo equiprobable con n+1 casos: el elemento puede estar en cualquiera de las n posiciones del arreglo, o no estar presente. Cada escenario tiene la misma probabilidad 1/(n+1)"
    },
    "average_case": {
      "scenario_id": "S_avg_case",
      "scenario_type": "average_case",
      "input_condition": "Promedio sobre todos los arreglos posibles de n elementos",
      "probability_model": "Algoritmo no sensible a la entrada: el numero de comparaciones y asignaciones es constante independientemente del orden o valores del arreglo. Siempre se recorren n-1 elementos y se realizan las mismas operaciones.",
      "scenarios_breakdown": [
        {
          "scenario_id": "S_unico",
          "description": "Unico escenario: el algoritmo siempre ejecuta n-1 iteraciones completas del loop, realizando n-1 comparaciones. El numero de asignaciones dentro del if varia segun los datos, pero el costo total en terminos de n permanece O(n).",
          "T": "c1 + c2*(n) + c3*(n-1) + c4*k",
          "P": "1"
        }
      ],
      "average_cost_formula": "E[T] = T(unico) * P(unico) = T(n) * 1",
      "T_of_S": "c1 + c2*n + c3*(n-1) + c4*k = c1 + c2*n + c3*n - c3 + c4*k = (c2+c3)*n + (c1-c3) + c4*k",
      "T_of_S_explanation": "Este algoritmo NO es sensible a la distribucion de datos en el sentido de cambiar su complejidad asintotica. Siempre recorre n-1 elementos (n iteraciones del encabezado del loop). La variable k representa el numero promedio de veces que se encuentra un nuevo maximo (arr[i] > max), lo cual depende de la distribucion de datos. En promedio, para un arreglo aleatorio, k es aproximadamente O(log n), pero esto no cambia que el costo dominante sea lineal: T(n) = O(n). Por lo tanto, el caso promedio tiene la misma complejidad que el mejor y peor caso: T_avg(n) = O(n).",
      "P_of_S": "1",
      "P_of_S_explanation": "El caso promedio engloba todos los escenarios posibles. Como el algoritmo no es sensible a la entrada en terminos de numero de iteraciones (siempre n-1), existe un unico escenario con probabilidad 1. La variacion en el numero de asignaciones max <- arr[i] no afecta la complejidad asintotica O(n)."
    }
  },
  "omega_table": {
    "algorithm_name": "busqueda_lineal",
    "scenarios": [
      {
        "id": "S_best_case",
        "semantic_id": "best_case",
        "condition": "Arreglo ordenado de forma descendente donde arr[0] es el elemento maximo",
        "state": "BEST_CASE",
        "cost_T": "c1 + c2*n + c3*(n-1) + c5",
        "probability_P": "1"
      },
      {
        "id": "S_worst_case",
        "semantic_id": "worst_case",
        "condition": "El elemento x no se encuentra en el arreglo A, obligando a recorrer todas las n posiciones sin encontrarlo",
        "state": "WORST_CASE",
        "cost_T": "3*c1 + c2*(n+1) + 2*c3*n",
        "probability_P": "1/(n+1)"
      },
      {
        "id": "S_unico",
        "semantic_id": "S_intermediate_1",
        "condition": "Unico escenario: el algoritmo siempre ejecuta n-1 iteraciones completas del loop, realizando n-1 comparaciones. El numero de asignaciones dentro del if varia segun los datos, pero el costo total en terminos de n permanece O(n).",
        "state": "INTERMEDIATE",
        "cost_T": "c1 + c2*(n) + c3*(n-1) + c4*k",
        "probability_P": "1"
      },
      {
        "id": "S_avg",
        "semantic_id": "average_case",
        "condition": "Promedio sobre todos los arreglos posibles de n elementos",
        "state": "AVERAGE",
        "cost_T": "c1 + c2*n + c3*(n-1) + c4*k = c1 + c2*n + c3*n - c3 + c4*k = (c2+c3)*n + (c1-c3) + c4*k",
        "probability_P": "1"
      }
    ],
    "control_variables": [],
    "metadata": {
      "algorithm_type": "iterative",
      "loop_count": 0,
      "nesting_level": 0,
      "parameters": {
        "arr": "array",
        "objetivo": "int"
      },
      "llm_analysis": {
        "best_case": {
          "scenario_id": "S_best_case",
          "scenario_type": "best_case",
          "input_condition": "Arreglo ordenado de forma descendente donde arr[0] es el elemento maximo",
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "max <- arr[0]",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1"
            },
            {
              "line_number": 2,
              "code": "for i <- 1 to n-1 do",
              "C_op": "c2",
              "Freq": "n",
              "Total": "c2*n",
              "explanation": "Encabezado del loop: se ejecuta n veces (n-1+1)"
            },
            {
              "line_number": 3,
              "code": "if (arr[i] > max) then",
              "C_op": "c3",
              "Freq": "n-1",
              "Total": "c3*(n-1)",
              "explanation": "Comparacion siempre falsa en mejor caso"
            },
            {
              "line_number": 4,
              "code": "max <- arr[i]",
              "C_op": "c4",
              "Freq": "0",
              "Total": "0",
              "explanation": "Nunca se ejecuta porque condicion siempre es falsa"
            },
            {
              "line_number": 5,
              "code": "return max",
              "C_op": "c5",
              "Freq": "1",
              "Total": "c5"
            }
          ],
          "T_of_S": "c1 + c2*n + c3*(n-1) + c5",
          "T_of_S_explanation": "Suma de todos los costos individuales. La asignacion dentro del if no se ejecuta",
          "P_of_S": "1",
          "P_of_S_explanation": "El mejor caso ocurre cuando el arreglo esta ordenado descendentemente",
          "probability_model": "Para un arreglo aleatorio, la probabilidad de que este ordenado descendentemente es muy baja, pero se considera P=1 para el analisis del mejor caso como escenario deterministico"
        },
        "worst_case": {
          "scenario_id": "S_worst_case",
          "scenario_type": "worst_case",
          "input_condition": "El elemento x no se encuentra en el arreglo A, obligando a recorrer todas las n posiciones sin encontrarlo",
          "line_by_line_analysis": [
            {
              "line_number": 1,
              "code": "encontrado <- F",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Asignacion inicial que se ejecuta una sola vez al inicio del algoritmo"
            },
            {
              "line_number": 2,
              "code": "i <- 1",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Inicializacion del contador que se ejecuta una sola vez"
            },
            {
              "line_number": 3,
              "code": "while (i <= n and not encontrado)",
              "C_op": "c2",
              "Freq": "n+1",
              "Total": "c2*(n+1)",
              "explanation": "Encabezado del loop que se ejecuta n+1 veces: n veces evalua verdadero (i=1..n con encontrado=F), y 1 vez evalua falso (i=n+1)"
            },
            {
              "line_number": 4,
              "code": "if (A[i] = x)",
              "C_op": "c3",
              "Freq": "n",
              "Total": "c3*n",
              "explanation": "Comparacion que se ejecuta n veces (una por cada iteracion del loop). En peor caso siempre evalua falso porque x no esta en A"
            },
            {
              "line_number": 5,
              "code": "encontrado <- T",
              "C_op": "c4",
              "Freq": "0",
              "Total": "0",
              "explanation": "Esta linea NUNCA se ejecuta en el peor caso porque la condicion A[i]=x siempre es falsa"
            },
            {
              "line_number": 6,
              "code": "i <- i + 1",
              "C_op": "c3",
              "Freq": "n",
              "Total": "c3*n",
              "explanation": "Incremento del contador que se ejecuta n veces, una por cada iteracion del loop"
            },
            {
              "line_number": 7,
              "code": "return encontrado",
              "C_op": "c1",
              "Freq": "1",
              "Total": "c1",
              "explanation": "Retorno final que se ejecuta una sola vez al terminar el algoritmo"
            }
          ],
          "T_of_S": "3*c1 + c2*(n+1) + 2*c3*n",
          "T_of_S_explanation": "Suma de todos los costos: c1 (linea 1) + c1 (linea 2) + c2*(n+1) (linea 3) + c3*n (linea 4) + 0 (linea 5) + c3*n (linea 6) + c1 (linea 7) = 3*c1 + c2*(n+1) + 2*c3*n",
          "P_of_S": "1/(n+1)",
          "P_of_S_explanation": "Probabilidad de que el elemento x no este en el arreglo A. Bajo el modelo equiprobable, hay n+1 casos posibles: x en posicion 1, x en posicion 2, ..., x en posicion n, o x no encontrado. Cada caso tiene probabilidad 1/(n+1)",
          "probability_model": "Modelo equiprobable con n+1 casos: el elemento puede estar en cualquiera de las n posiciones del arreglo, o no estar presente. Cada escenario tiene la misma probabilidad 1/(n+1)"
        },
        "average_case": {
          "scenario_id": "S_avg_case",
          "scenario_type": "average_case",
          "input_condition": "Promedio sobre todos los arreglos posibles de n elementos",
          "probability_model": "Algoritmo no sensible a la entrada: el numero de comparaciones y asignaciones es constante independientemente del orden o valores del arreglo. Siempre se recorren n-1 elementos y se realizan las mismas operaciones.",
          "scenarios_breakdown": [
            {
              "scenario_id": "S_unico",
              "description": "Unico escenario: el algoritmo siempre ejecuta n-1 iteraciones completas del loop, realizando n-1 comparaciones. El numero de asignaciones dentro del if varia segun los datos, pero el costo total en terminos de n permanece O(n).",
              "T": "c1 + c2*(n) + c3*(n-1) + c4*k",
              "P": "1"
            }
          ],
          "average_cost_formula": "E[T] = T(unico) * P(unico) = T(n) * 1",
          "T_of_S": "c1 + c2*n + c3*(n-1) + c4*k = c1 + c2*n + c3*n - c3 + c4*k = (c2+c3)*n + (c1-c3) + c4*k",
          "T_of_S_explanation": "Este algoritmo NO es sensible a la distribucion de datos en el sentido de cambiar su complejidad asintotica. Siempre recorre n-1 elementos (n iteraciones del encabezado del loop). La variable k representa el numero promedio de veces que se encuentra un nuevo maximo (arr[i] > max), lo cual depende de la distribucion de datos. En promedio, para un arreglo aleatorio, k es aproximadamente O(log n), pero esto no cambia que el costo dominante sea lineal: T(n) = O(n). Por lo tanto, el caso promedio tiene la misma complejidad que el mejor y peor caso: T_avg(n) = O(n).",
          "P_of_S": "1",
          "P_of_S_explanation": "El caso promedio engloba todos los escenarios posibles. Como el algoritmo no es sensible a la entrada en terminos de numero de iteraciones (siempre n-1), existe un unico escenario con probabilidad 1. La variacion en el numero de asignaciones max <- arr[i] no afecta la complejidad asintotica O(n)."
        }
      },
      "best_case": {
        "scenario_id": "S_best_case",
        "semantic_id": "best_case",
        "T": "c1 + c2*n + c3*(n-1) + c5",
        "P": "1",
        "description": "Arreglo ordenado de forma descendente donde arr[0] es el elemento maximo",
        "input_characteristics": {}
      },
      "worst_case": {
        "scenario_id": "S_worst_case",
        "semantic_id": "worst_case",
        "T": "3*c1 + c2*(n+1) + 2*c3*n",
        "P": "1/(n+1)",
        "description": "El elemento x no se encuentra en el arreglo A, obligando a recorrer todas las n posiciones sin encontrarlo",
        "input_characteristics": {}
      },
      "average_case": {
        "scenario_id": "S_avg",
        "semantic_id": "average_case",
        "T_avg": "c1 + c2*n + c3*(n-1) + c4*k = c1 + c2*n + c3*n - c3 + c4*k = (c2+c3)*n + (c1-c3) + c4*k",
        "formula": "E[T] = T(unico) * P(unico) = T(n) * 1",
        "simplified": "",
        "description": "Promedio sobre todos los arreglos posibles de n elementos",
        "scenarios_breakdown": [
          {
            "scenario_id": "S_unico",
            "description": "Unico escenario: el algoritmo siempre ejecuta n-1 iteraciones completas del loop, realizando n-1 comparaciones. El numero de asignaciones dentro del if varia segun los datos, pero el costo total en terminos de n permanece O(n).",
            "T": "c1 + c2*(n) + c3*(n-1) + c4*k",
            "P": "1"
          }
        ]
      }
    }
  },
  "errors": [],
  "warnings": []
}